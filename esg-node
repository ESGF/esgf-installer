#!/bin/bash

#####
# esg-node: ESGF Node Application Stack
# chkconfig: 345 98 02
# description: Installer for the ESGF Node application stack
#
#****************************************************************************
#*                                                                          *
#*  Organization: Lawrence Livermore National Lab (LLNL)                    *
#*   Directorate: Computation                                               *
#*    Department: Computing Applications and Research                       *
#*      Division: S&T Global Security                                       *
#*        Matrix: Atmospheric, Earth and Energy Division                    *
#*       Program: PCMDI                                                     *
#*       Project: Earth Systems Grid Fed (ESGF) Node Software Stack         *
#*  First Author: Gavin M. Bell (gavin@llnl.gov)                            *
#*                                                                          *
#****************************************************************************
#*                                                                          *
#*   Copyright (c) 2009, Lawrence Livermore National Security, LLC.         *
#*   Produced at the Lawrence Livermore National Laboratory                 *
#*   Written by: Gavin M. Bell (gavin@llnl.gov)                             *
#*   LLNL-CODE-420962                                                       *
#*                                                                          *
#*   All rights reserved. This file is part of the:                         *
#*   Earth System Grid Fed (ESGF) Node Software Stack, Version 1.0          *
#*                                                                          *
#*   For details, see http://esgf.org/                                      *
#*   Please also read this link                                             *
#*    http://esgf.org/LICENSE                                               *
#*                                                                          *
#*   * Redistribution and use in source and binary forms, with or           *
#*   without modification, are permitted provided that the following        *
#*   conditions are met:                                                    *
#*                                                                          *
#*   * Redistributions of source code must retain the above copyright       *
#*   notice, this list of conditions and the disclaimer below.              *
#*                                                                          *
#*   * Redistributions in binary form must reproduce the above copyright    *
#*   notice, this list of conditions and the disclaimer (as noted below)    *
#*   in the documentation and/or other materials provided with the          *
#*   distribution.                                                          *
#*                                                                          *
#*   Neither the name of the LLNS/LLNL nor the names of its contributors    *
#*   may be used to endorse or promote products derived from this           *
#*   software without specific prior written permission.                    *
#*                                                                          *
#*   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
#*   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
#*   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
#*   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE    *
#*   LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR     *
#*   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,           *
#*   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       *
#*   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF       *
#*   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND    *
#*   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,     *
#*   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT     *
#*   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF     *
#*   SUCH DAMAGE.                                                           *
#*                                                                          *
#****************************************************************************
#####

#uses: perl, awk, ifconfig, tar, wget, curl, su, useradd, groupadd,
#      id, chmod, chown, chgrp, cut, svn, mkdir, killall, java, egrep,
#      lsof, unlink, ln, pax, keytool, openssl

#note: usage of readlink not macosx friendly :-( usage of useradd /
#      groupadd is RedHat/CentOS dependent :-(

DEBUG=${DEBUG:-0}
VERBOSE=${VERBOSE:-0}

progname="esg-node"
version="v1.0.2 (Stuyvesant)"
envfile="/etc/esg.env"
install_logfile=${install_logfile:-"/etc/esg.install_log"}

#--------------
#User Defined / Settable (public)
#--------------
t=${0%.*}
install_prefix=${install_prefix:-"/usr/local"}
esg_root_dir=${esg_root_dir:-${ESGF_HOME:-"/esg"}}
esg_config_dir=${esg_root_dir}/config
esg_config_type_file=${esg_config_dir}/config_type
pg_secret_file=${esg_config_dir}/.esg_pg_pass
ks_secret_file=${esg_config_dir}/.esg_keystore_pass
logfile=${logfile:-"/var/tmp/${t##*/}.out"}
#--------------

[ -e "${envfile}" ] && source ${envfile} && ((VERBOSE)) && printf "sourcing environment from: ${envfile} \n"

init() {
    debug_print "esg-node initilizing..."

    #--------------------------------
    # Internal data-node code versions and supporting external libraries
    #--------------------------------
    #cdat_version=${cdat_version:-"eb8b668"}
    cdat_version=${cdat_version:-"6.0.alpha"}
    esgcet_version=${esgcet_version:-"2.7.8"}

    #see esgf-node-manager project:
    esgf_node_manager_version=${esgf_node_manager_version:-"0.4.2"}
    esgf_node_manager_db_version=${esgf_node_manager_db_version:-"0.1.4"}

    #see esg-orp project:
    esg_orp_version=${esg_orp_version:-"1.0.3"}

    #see esgf-security project:
    esgf_security_version=${esgf_security_version:-"1.2.1"}
    esgf_security_db_version=${esgf_security_db_version:-"0.1.4"}
    opensaml_version=${opensaml_version:-"2.3.2"}
    openws_version=${openws_version:-"1.3.1"}
    xmltooling_version=${xmltooling_version:-"1.2.2"}
    xsgroup_role_version=${xsgroup_role_version:-"1.0.0"}

    #see esgf-idp project:
    esgf_idp_version=${esgf_idp_version:-"1.1.0"}
    
    #--------------------------------
    # External programs' versions
    #--------------------------------
    curl_version=${curl_version:="7.20.1"} ; curl_min_version=${curl_version:="7.20.1"}
    git_version=${git_version:="1.7.3"} ; git_min_version=${git_min_version:="1.7.3"}
    java_version=${java_version:-"1.6.0_23"} ; java_min_version=${java_min_version:-"1.6.0_23"}
    ant_version=${ant_version:-"1.8.2"} ; ant_min_version=${ant_min_version:-"1.8.2"}
    postgress_version=${postgress_version:-"8.4.7"} ; postgress_min_version=${postgress_min_version:-"8.4.7"}
    tomcat_version=${tomcat_version:-"6.0.32"} ; tomcat_min_version=${tomcat_min_version:-"6.0.29"}
    tds_version=${tds_version:-"4.2.20100908.2246"} ; tds_min_version=${tds_version:-"4.2.20100908.2246"}

    python_version=${python_version:-"2.6"}

    #--------------------------------
    # Script vars (~external)
    #--------------------------------
    curl_install_dir=${CURL_HOME:-${install_prefix}/curl}
    git_install_dir=${GIT_HOME:-${install_prefix}/git}
    postgress_install_dir=${PGHOME:-${install_prefix}/pgsql}
    postgress_user=${PGUSER:-dbsuper}
    local pg_secret=$(cat ${pg_secret_file} 2> /dev/null)
    pg_sys_acct_passwd=${pg_sys_acct_passwd:=${pg_secret:=changeme}}
    unset pg_secret #only here to hold the tertiary ephemeral value from file, unset asap
    postgress_host=${PGHOST:-localhost}
    postgress_port=${PGPORT:-5432}
    cdat_home=${CDAT_HOME:-${install_prefix}/cdat}
    java_opts=${JAVA_OPTS:-""}
    java_install_dir=${JAVA_HOME:-${install_prefix}/java}
    ant_install_dir=${ANT_HOME:-${install_prefix}/ant}
    tomcat_install_dir=${CATALINA_HOME:-${install_prefix}/tomcat}
    tomcat_conf_dir=${tomcat_install_dir}/conf
    #tomcat_conf_dir=${esg_root_dir}/config/tomcat
    tomcat_opts=${CATALINA_OPTS}
    tomcat_user=${tomcat_user:-tomcat}
    tomcat_group=${tomcat_group:-$tomcat_user}
    globus_location=${GLOBUS_LOCATION:-${install_prefix}/globus}
    gateway_name=${ESG_GATEWAY_NAME}
    gateway_service_root=${ESG_GATEWAY_SVC_ROOT}
    myproxy_endpoint=${myproxy_endpoint:-${gateway_service_root%%/*}}
    myproxy_port=${myproxy_port:-7512}
    esgf_host=$(hostname --fqdn)
    esg_root_id=${ESG_ROOT_ID:-$(echo `hostname -s`.`hostname --domain` | awk -F. ' {print $(NF-1)} ')}
    mail_smtp_host=${mail_smtp_host:-smtp.`hostname --domain`} #standard guess.
    mail_admin_address=${mail_admin_address}
    gridftp_config_args=${gridftp_config_args:-""}
    
    ############################################
    ####  DO NOT EDIT BELOW THIS POINT!!!!! ####
    ############################################
    
    export CURL_HOME=${curl_install_dir}
    export GIT_HOME=${git_install_dir}
    export PGHOME=${postgress_install_dir}
    export PGUSER=${postgress_user}
    export PGHOST=${postgress_host}
    export PGPORT=${postgress_port}
    export CDAT_HOME=${cdat_home}
    export JAVA_HOME=${java_install_dir}
    export JAVA_OPTS=${java_opts}
    export ANT_HOME=${ant_install_dir}
    export CATALINA_HOME=${tomcat_install_dir}
    export CATALINA_BASE=${CATALINA_HOME}
    export CATALINA_OPTS=${tomcat_opts}
    export GLOBUS_LOCATION=${globus_location}
    export X509_CERT_DIR=${X509_CERT_DIR:-${HOME}/.globus/certificates}
    export ESG_ROOT_ID=${esg_root_id}
    
    myPATH=${install_prefix}/bin:$CURL_HOME/bin:$GIT_HOME/bin:$JAVA_HOME/bin:$ANT_HOME/bin:$PGHOME/bin:$CDAT_HOME/bin:$CDAT_HOME/Externals/bin:$CATALINA_HOME/bin:$GLOBUS_LOCATION/bin:/bin:/sbin:/usr/bin:/usr/sbin
    myLD_LIBRARY_PATH=$CURL_HOME/lib:$PGHOME/lib:$CDAT_HOME/Externals/lib:$GLOBUS_LOCATION/lib
    export PATH=$myPATH:$PATH
    export LD_LIBRARY_PATH=$myLD_LIBRARY_PATH:$LD_LIBRARY_PATH
    export CFLAGS="-I$CURL_HOME/include $CFLAGS"
    export LDFLAGS="-L$CURL_HOME/lib"
    
    #--------------
    # ID Setting
    #--------------

    installer_uid=${ESG_USER_UID:-${SUDO_UID:-$(id -u)}}
    installer_gid=${ESG_USER_GID:-${SUDO_GID:-$(id -g)}}
    installer_home=${ESG_USER_HOME:-$(getent passwd ${installer_uid} | awk -F : '{print $6}')}

    verbose_print "${installer_uid}:${installer_gid}:${installer_home}"

    #--------------
    # Script vars (internal)
    #--------------
    esg_backup_dir=${esg_backup_dir:-"${esg_root_dir}/backups"}
    esg_config_dir=${esg_config_dir:-"${esg_root_dir}/config"}
    esg_log_dir=${esg_log_dir:-"${esg_root_dir}/log"}
    esg_tools_dir=${esg_tools_dir:-"${esg_root_dir}/tools"}
    workdir=${workdir:-${installer_home}/workbench/esg}

    word_size=${word_size:-$(file /bin/bash | perl -ple 's/^.*ELF\s*(32|64)-bit.*$/$1/g')}
    esg_dist_url=http://198.128.245.140/dist
    date_format="+%Y_%m_%d_%H%M%S"
    num_backups_to_keep=${num_backups_to_keep:-7}
    compress_extensions=".tar.gz|.tar.bz2|.tgz|.bz2|.tar"
    certificate_extensions="pem|crt|cert|key"
    java_dist_url=${esg_dist_url}/java/${java_version}/jdk${java_version}-${word_size}.tar.gz
    ant_dist_url=http://www.trieuvan.com/apache/ant/binaries/apache-ant-${ant_version}-bin.tar.gz
    curl_workdir=${workdir}/curl
    curl_dist_url=http://curl.haxx.se/download/curl-${curl_version}.tar.gz
    git_workdir=${workdir}/git
    git_dist_url=http://kernel.org/pub/software/scm/git/git-${git_version}.tar.gz
    node_db_name=esgcet
    postgress_workdir=${workdir}/postgress
    postgress_jar=postgresql-8.3-603.jdbc3.jar
    postgress_driver=org.postgresql.Driver
    postgress_protocol=jdbc:postgresql:
    pg_sys_acct=${pg_sys_acct:-postgres}
    pg_sys_acct_group=${pg_sys_acct_group:-$pg_sys_acct}
    postgress_dist_url=http://ftp9.us.postgresql.org/pub/mirrors/postgresql/source/v${postgress_version}/postgresql-${postgress_version}.tar.gz
    cdat_repo=git://uv-cdat.llnl.gov/cdat.git
    cdat_repo_http=http://uv-cdat.llnl.gov/git/cdat.git
    esgcet_egg_file=esgcet-${esgcet_version}-py${python_version}.egg
    esg_testdir=${workdir}/../esg_test
    tomcat_dist_url=http://download.filehat.com/apache/tomcat/tomcat-6/v${tomcat_version}/bin/apache-tomcat-${tomcat_version}.tar.gz
    tomcat_pid_file=/var/run/tomcat-jsvc.pid
    utils_url=${esg_dist_url}/utils
    thredds_dist_url=ftp://ftp.unidata.ucar.edu/pub/thredds/$(echo ${tds_version} | sed  -n 's/\(.*\).201[0-9]*.[0-9]*/\1/p')/thredds.war
    thredds_esg_dist_url=${esg_dist_url}/thredds/$(echo ${tds_version} | sed  -n 's/\(.*\).201[0-9]*.[0-9]*/\1/p')/thredds.war
    thredds_content_dir=${thredds_content_dir:-${esg_root_dir}/content}
    #NOTE: This root dir should match a root set in the thredds setup 
    thredds_root_dir=${esg_root_dir}/data
    thredds_replica_dir=${thredds_root_dir}/replica
    #NOTE: This is another RedHat/CentOS specific portion!!! it will break on another OS!
    my_ip_address=$(ifconfig | grep "inet[^6]" | awk '$0 !~ /127.0.0.1/ { gsub (" *inet [^:]*:",""); print $1}')
    show_summary_latch=0
    source_latch=0
    node_host_ip_address=${my_ip_address}
    scripts_dir=${install_prefix}/bin
    no_globus=${no_globus:-0}
    force_install=${force_install:-0}
    extkeytool_download_url=${esg_dist_url}/etc/idptools.tar.gz
    tomcat_users_file=${tomcat_conf_dir}/tomcat-users.xml
    keystore_file=${tomcat_conf_dir}/keystore-tomcat
    keystore_alias=my_esgf_node
    keystore_password=changeit
    truststore_file=${tomcat_conf_dir}/esg-truststore.ts
    globus_global_certs_dir=/etc/grid-security/certificates
    #NOTE: java keystore style DN...
    dname=${dname:-"OU=simpleCA-pcmdi3.llnl.gov, OU=GlobusTest, O=Grid"}
    config_file=${esg_config_dir}/esgf.properties

    mkdir -p ${scripts_dir}
    [ $? != 0 ] && echo "ERROR: could not create ${scripts_dir}... required for installation" && checked_done 1

    mkdir -p ${esg_backup_dir}  && \
        mkdir -p ${esg_tools_dir} && \
        mkdir -p ${esg_log_dir} && \
        mkdir -p ${esg_config_dir} && \
        mkdir -p ${tomcat_conf_dir}
    [ $? != 0 ] && echo "ERROR: could not create ${esg_root_dir} dir and/or subdirectories" && checked_done 1

    [ -w "${envfile}" ] && write_paths
}

write_paths() {
    ((show_summary_latch++))
    echo "export ESGF_HOME=${esg_root_dir}" >> ${envfile}
    echo "export PATH=$myPATH:\$PATH" >> ${envfile}
    echo "export LD_LIBRARY_PATH=$myLD_LIBRARY_PATH:\$LD_LIBRARY_PATH" >> ${envfile}
    echo "export ESG_USER_HOME=${installer_home}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
}

#checking for what we expect to be on the system a-priori
#that we are not going to install or be responsible for
check_prerequisites() {
    printf "Checking that you have root privs on $(hostname)... " 
    id | grep root >& /dev/null
    [ $? != 0 ] && printf "[FAIL] \n\tMust run this program with root's effective UID\n\n" && return 1
    echo "[OK]"

    #----------------------------------------
    echo "Checking requisites... "

    verbose_print -n "Checking for gcc or g++... "
    gcc --version >& /dev/null || gg++ --version >& /dev/null && verbose_print "[OK]" || (verbose_print "[FAIL]" && return 1)
    
    verbose_print -n "Checking for gmake... "
    gmake --version >& /dev/null && verbose_print "[OK]" || (verbose_print "[FAIL]" && return 1)

    verbose_print -n "Checking for openssl... "
    openssl version >& /dev/null && verbose_print "[OK]" || (verbose_print "[FAIL]" && return 1)
    
    verbose_print -n "Checking for X11 libs... "
    Xorg -version >& /dev/null && verbose_print "[OK]" || verbose_print "[WARNING] X11 is needed for publisher UI..."
    #----------------------------------------

    echo
    return 0
}


#####
# Curl/libcurl (support library - needed to support HTTP protocol in GIT)
#####
setup_curl() {

    echo -n "Checking for curl >= ${curl_min_version} "
    check_version curl ${curl_min_version}
    [ $? == 0 ] && (( ! force_install )) && echo " [OK]" && return 0
    
    echo
    echo "*******************************"
    echo "Setting up Curl/Libcurl ${curl_version}"
    echo "*******************************"
    echo
    
    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${curl_install_dir}/bin/curl ]; then 
        echo "Detected an existing CURL installation..."
        read -p "Do you want to continue with CURL installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}        
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping CURL installation and setup - will assume CURL is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${curl_workdir}
    [ $? != 0 ] && checked_done 1
    chmod a+rw ${curl_workdir}
    pushd ${curl_workdir} >& /dev/null
    
    local curl_dist_file=${curl_dist_url##*/}
    #strip off .tar.gz at the end
    local curl_dist_dir=$(echo ${curl_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')
    
    #There is this pesky case of having a zero sized dist file... WTF!?
    if [ -e ${curl_dist_file} ]; then
        ls -l ${curl_dist_file}
        local size=$(stat -c%s ${curl_dist_file})
        (( size == 0 )) && rm -v ${curl_dist_file}
    fi

    #Check to see if we have postgres distribution directory
    if [ ! -e ${curl_dist_dir} ]; then
        echo "Don't see CURL distribution dir ${curl_dist_dir}"
        if [ ! -e ${curl_dist_file} ]; then
            echo "Don't see CURL distribution file ${curl_dist_file} either"
            echo "Downloading CURL from ${curl_dist_url}"
            wget -O ${curl_dist_file} ${curl_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download CURL:${curl_dist_file}" && popd && checked_done 1
            echo "unpacking ${curl_dist_file}..."
            tar xzf ${curl_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract CURL: ${curl_dist_file}" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it and go from there....
    if [ -e ${curl_dist_file} ] && [ ! -e ${curl_dist_dir} ]; then
        echo "unpacking ${curl_dist_file}..."
        tar xzf ${curl_dist_file}
    fi

    pushd ${curl_dist_dir}
    echo "./configure --prefix=${curl_install_dir}"
    if ./configure --prefix=${curl_install_dir} \
        && gmake all \
        && gmake install 
    then
        echo "Successfully Configured and Built CURL in: ${curl_install_dir}"
        #this is the "test"
        ${curl_install_dir}/bin/curl --version
        [ $? != 0 ] &&  echo" ERROR: Could NOT successfully build CURL!!" && popd >& /dev/null && checked_done 1
    else
        echo" ERROR: Could NOT successfully build CURL!!"
        popd >& /dev/null
        checked_done 1
    fi

    popd >& /dev/null
    popd >& /dev/null

    write_curl_env
    write_curl_install_log
    checked_done 0
}

write_curl_env() {
    ((show_summary_latch++))
    echo "export CURL_HOME=${curl_install_dir}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_curl_install_log() {
    echo "$(date ${date_format}) curl=${curl_version} ${curl_install_dir}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

#####
# GIT
#####
setup_git() {

    echo -n "Checking for git >= ${git_min_version}"
    check_version git ${git_min_version}
    [ $? == 0 ] && (( ! force_install )) && echo " [OK]" && return 0
    
    echo
    echo "*******************************"
    echo "Setting up GIT (dvcs) ${git_version}"
    echo "*******************************"
    echo

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${git_install_dir}/bin/git ]; then 
        echo "Detected an existing GIT installation..."
        read -p "Do you want to continue with GIT installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping GIT installation and setup - will assume GIT is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${git_workdir}
    [ $? != 0 ] && checked_done 1
    chmod a+rw ${git_workdir}
    pushd ${git_workdir} >& /dev/null

    local git_dist_file=${git_dist_url##*/}
    #strip off .tar.gz at the end, i.e. last 7 chars, to get untarred dir name
    local git_dist_dir=$(echo ${git_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')
    
    #There is this pesky case of having a zero sized dist file... WTF!?
    if [ -e ${git_dist_file} ]; then
        ls -l ${git_dist_file}
        local size=$(stat -c%s ${git_dist_file})
        (( size == 0 )) && rm -v ${git_dist_file}
    fi

    #Check to see if we have git distribution directory
    if [ ! -e ${git_dist_dir} ]; then
        echo "Don't see GIT distribution dir ${git_dist_dir}"
        if [ ! -e ${git_dist_file} ]; then
            echo "Don't see GIT distribution file ${git_dist_file} either"
            echo "Downloading GIT from ${git_dist_url}"
            wget -O ${git_dist_file} ${git_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download GIT:${git_dist_file}" && popd && checked_done 1
            echo "unpacking ${git_dist_file}..."
            tar xzf ${git_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract GIT: ${git_dist_file}" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it and go from there....
    if [ -e ${git_dist_file} ] && [ ! -e ${git_dist_dir} ]; then
        echo "unpacking ${git_dist_file}..."
        tar xzf ${git_dist_file}
    fi

    pushd ${git_dist_dir}
    echo "./configure --prefix=${git_install_dir}"
    if ./configure --prefix=${git_install_dir} \
        && gmake all \
        && gmake install 
    then
        echo "Successfully Configured and Built GIT in: ${git_install_dir}"
        #this is the "test"
        ${git_install_dir}/bin/git --version
        [ $? != 0 ] &&  echo" ERROR: Could NOT successfully build GIT!!" && popd >& /dev/null && checked_done 1
    else
        echo" ERROR: Could NOT successfully build GIT!!"
        popd >& /dev/null
        checked_done 1
    fi

    popd >& /dev/null
    popd >& /dev/null

    write_git_env
    write_git_install_log
    checked_done 0
}

write_git_env() {
    ((show_summary_latch++))
    echo "export GIT_HOME=${git_install_dir}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_git_install_log() {
    echo "$(date ${date_format}) git=${git_version} ${git_install_dir}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

#####
# Java
#####
setup_java() {

    echo -n "Checking for java >= ${java_min_version} and valid JAVA_HOME... "
    [ -e ${java_install_dir} ] && check_version $java_install_dir/bin/java ${java_min_version}
    [ $? == 0 ] && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up Java... ${java_version}"
    echo "*******************************"
    echo

    local last_java_truststore_file

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${java_install_dir}/bin/java ]; then 
        echo "Detected an existing java installation..."
        read -p "Do you want to continue with Java installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping Java installation and setup - will assume Java is setup properly"
            return 0
        fi
        last_java_truststore_file=$(readlink -f ${truststore_file}) 
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} #>& /dev/null
    
    local java_dist_file=${java_dist_url##*/}
    #strip off -(32|64).tar.gz at the end
    java_dist_dir=$(echo ${java_dist_file} | awk 'gsub(/-(32|64)('$compress_extensions')/,"")')

    #Check to see if we have an Java distribution directory
    if [ ! -e ${java_install_dir%/*}/${java_dist_dir} ]; then
        echo "Don't see java distribution dir ${java_install_dir%/*}/${java_dist_dir}"
        if [ ! -e ${java_dist_file} ]; then
            echo "Don't see java distribution file $(pwd)/${java_dist_file} either"
            echo "Downloading Java from ${java_dist_url}"
            checked_get ${java_dist_file} ${java_dist_url} $((force_install))
            [ $? != 0 ] && echo " ERROR: Could not download Java" && popd && checked_done 1
            echo "unpacking ${java_dist_file}..."
            tar xzf ${java_dist_file} -C ${java_install_dir%/*} # i.e. /usr/local
            [ $? != 0 ] && echo " ERROR: Could not extract Java" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it
    if [ -e ${java_dist_file} ] && [ ! -e ${java_install_dir%/*}/${java_dist_dir} ]; then
        echo "unpacking ${java_dist_file}..."
        tar xzf ${java_dist_file} -C ${java_install_dir%/*} # i.e. /usr/local
        [ $? != 0 ] && echo " ERROR: Could not extract Java..." && popd && checked_done 1
    fi

    if [ ! -e ${java_install_dir} ]; then
        ln -s ${java_install_dir%/*}/${java_dist_dir} ${java_install_dir}
        [ $? != 0 ] && \
            echo " ERROR: Could not create sym link ${java_install_dir%/*}/${java_dist_dir} -> ${java_install_dir}" && popd && checked_done 1
    else
        unlink ${java_install_dir} 
        [ $? != 0 ] && mv ${java_install_dir} ${java_install_dir}.$(date ${date_format}).bak
        
        ln -s ${java_install_dir%/*}/${java_dist_dir} ${java_install_dir}
        [ $? != 0 ] && \
            echo " ERROR*: Could not create sym link ${java_install_dir%/*}/${java_dist_dir} -> ${java_install_dir}" && popd && checked_done 1
    fi
    debug_print "chown -R ${installer_uid}:${installer_gid} ${java_install_dir}"
    chown    ${installer_uid}:${installer_gid} ${java_install_dir}
    chown -R ${installer_uid}:${installer_gid} $(readlink -f ${java_install_dir})

    popd >& /dev/null

    ${java_install_dir}/bin/java -version
    [ $? != 0 ] && echo "ERROR cannot run ${java_install_dir}/bin/java" && checked_done 1
    write_java_env
    write_java_install_log

    #-----------------------------
    #In the situation where this function is called under update
    #semantics i.e. there is already a previous installation of java
    #an installation of tomcat with tomcat setup with a properly
    #generated/configured jssecacerts file and there is a valid
    #ESG_GATEWAY_SVC_ROOT being pointed to.  We should copy over that
    #jssecacerts into this newly installed VM to satisfy SSL.
    if [ -e "${last_java_truststore_file}" ]; then
        cp -v ${last_java_truststore_file} ${java_install_dir}/conf
        chmod 644 ${java_install_dir}/conf/${last_java_truststore_file##*/}
    fi
    #-----------------------------

    checked_done 0
}

write_java_env() {
    ((show_summary_latch++))
    echo "export JAVA_HOME=${java_install_dir}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_java_install_log() {
    echo "$(date ${date_format}) java=${java_version} ${java_install_dir%/*}/${java_dist_dir}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}


#####
# Ant
#####
setup_ant() {

    echo -n "Checking for ant >= ${ant_min_version}"
    [ -e ${ant_install_dir} ] &&  check_version ${ant_install_dir}/bin/ant ${ant_min_version}
    [ $? == 0 ] && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up Ant... ${ant_version}"
    echo "*******************************"
    echo

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${ant_install_dir}/bin/ant ]; then 
        echo "Detected an existing ant installation..."
        read -p "Do you want to continue with Ant installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping Ant installation and setup - will assume ant is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null
    
    local ant_dist_file=${ant_dist_url##*/}
    #strip off -bin.tar.gz at the end
    ant_dist_dir=${ant_dist_file/-bin.tar.gz}

    #There is this pesky case of having a zero sized dist file... WTF!?
    if [ -e ${ant_dist_file} ]; then
        ls -l ${ant_dist_file}
        local size=$(stat -c%s ${ant_dist_file})
        (( size == 0 )) && rm -v ${ant_dist_file}
    fi

    #Check to see if we have an Ant distribution directory
    if [ ! -e ${ant_install_dir%/*}/${ant_dist_dir} ]; then
        echo "Don't see ant distribution dir ${ant_install_dir%/*}/${ant_dist_dir}"
        if [ ! -e ${ant_dist_file} ]; then
            echo "Don't see ant distribution file $(pwd)/${ant_dist_file} either"
            echo "Downloading Ant from ${ant_dist_url}"
            wget -O ${ant_dist_file} ${ant_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download Ant" && popd && checked_done 1
            echo "unpacking ${ant_dist_file}..."
            tar xzf ${ant_dist_file} -C ${ant_install_dir%/*} # i.e. /usr/local
            [ $? != 0 ] && echo " ERROR: Could not extract Ant" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it
    if [ -e ${ant_dist_file} ] && [ ! -e ${ant_install_dir%/*}/${ant_dist_dir} ]; then
        echo "unpacking ${ant_dist_file}..."
        tar xzf ${ant_dist_file} -C ${ant_install_dir%/*} # i.e. /usr/local
        [ $? != 0 ] && echo " ERROR: Could not extract Ant..." && popd && checked_done 1
    fi

    if [ ! -e ${ant_install_dir} ]; then
        ln -s ${ant_install_dir%/*}/${ant_dist_dir} ${ant_install_dir}
        [ $? != 0 ] && \
            echo " ERROR: Could not create sym link ${ant_install_dir%/*}/${ant_dist_dir} -> ${ant_install_dir}" && popd && checked_done 1
    else
        unlink ${ant_install_dir} 
        [ $? != 0 ] && mv ${ant_install_dir} ${ant_install_dir}.$(date ${date_format}).bak

        ln -s ${ant_install_dir%/*}/${ant_dist_dir} ${ant_install_dir}
        [ $? != 0 ] && \
            echo " ERROR: Could not create sym link ${ant_install_dir%/*}/${ant_dist_dir} -> ${ant_install_dir}" && popd && checked_done 1
    fi

    ${ant_install_dir}/bin/ant -version
    [ $? != 0 ] && echo "ERROR cannot run ${ant_install_dir}/bin/ant" && checked_done 1
    write_ant_env
    write_ant_install_log
    checked_done 0

}

write_ant_env() {
    ((show_summary_latch++))
    echo "export ANT_HOME=${ant_install_dir}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_ant_install_log() {
    echo "$(date ${date_format}) ant=${ant_version} $(readlink -f ${ant_install_dir})" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

#####
# PostgreSQL
#####
setup_postgress() {

    echo -n "Checking for postgresql >= ${postgress_min_version}"
    check_version psql ${postgress_min_version}
    local ret=$?
    (($ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0

    
    local upgrade=$(( (ret==1) ? 1 : 0 )) #see check_version() function comments for meaning of return values

    echo
    echo    "*******************************"
    echo -n "Setting up PostgreSQL... ${postgress_version} " && ( ((upgrade)) && echo "(upgrade)" ) || echo "(install)"
    echo    "*******************************"
    echo

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${postgress_install_dir}/bin/psql ]; then 
        echo "Detected an existing postgress installation..."
        read -p "Do you want to continue with Postgres installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping postgres installation and setup - will assume postgres is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${postgress_workdir}
    [ $? != 0 ] && checked_done 1
    chmod a+rw ${postgress_workdir}
    pushd ${postgress_workdir} >& /dev/null

    local postgress_dist_file=${postgress_dist_url##*/}
    #strip off .tar.gz at the end
    postgress_dist_dir=$(echo ${postgress_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')
    
    #There is this pesky case of having a zero sized dist file... WTF!?
    if [ -e ${postgress_dist_file} ]; then
        ls -l ${postgress_dist_file}
        local size=$(stat -c%s ${postgress_dist_file})
        (( size == 0 )) && rm -v ${postgress_dist_file}
    fi

    #Check to see if we have postgres distribution directory
    if [ ! -e ${postgress_dist_dir} ]; then
        echo "Don't see postgress distribution dir ${postgress_dist_dir}"
        if [ ! -e ${postgress_dist_file} ]; then
            echo "Don't see postgress distribution file ${postgress_dist_file} either"
            echo "Downloading Postgress from ${postgress_dist_url}"
            wget -O ${postgress_dist_file} ${postgress_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download Postgress:${postgress_dist_file}" && popd && checked_done 1
            echo "unpacking ${postgress_dist_file}..."
            tar xzf ${postgress_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract Postgress: ${postgress_dist_file}" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it and go from there....
    if [ -e ${postgress_dist_file} ] && [ ! -e ${postgress_dist_dir} ]; then
        echo "unpacking ${postgress_dist_file}..."
        tar xzf ${postgress_dist_file}
    fi

    pushd ${postgress_dist_dir}
    echo "./configure --prefix=${postgress_install_dir} --enable-thread-safety"
    if ./configure --prefix=${postgress_install_dir} --enable-thread-safety \
        && gmake \
        && gmake install \
        && cd contrib/tablefunc/ \
        && gmake
    then
        stop_postgress
        gmake install
        echo "Successfully Configured and Built PostgresSQL in: ${postgress_install_dir}"
    else
        echo" ERROR: Could NOT successfully build POSTGRESS!"
        popd >& /dev/null
        checked_done 1
    fi

    popd >& /dev/null

    if ((upgrade)); then 
        echo "UPGRADE of postgress to ${postgress_version} completed"
        echo "It is recommended to restart the entire node as to not leave"
        echo "orphaned db connections that have been created by the rest of"
        echo "the application stack"

        echo "Restarting Database..."
        stop_postgress
        start_postgress
        checked_done $?
    fi

    ########
    #Create the system account for postgress to run as.
    ########
    id $pg_sys_acct
    if [ $? != 0 ]; then
        echo " Hmmm...: There is no postgres system account user \"$pg_sys_acct\" present on system, making one..."
        #NOTE: "useradd/groupadd" are a RedHat/CentOS thing... to make this cross distro compatible clean this up.
        /usr/sbin/groupadd -r -f ${pg_sys_acct_group}
        [ $? != 0 ] && [ $? != 9 ] && echo "ERROR: Could not add postgres system group: ${pg_sys_acct_group}" && popd && checked_done 1
        
        if [ -z "${pg_sys_acct_passwd}" ]; then
            #set the password for the system user...
            while [ 1 ]; do 
                local input
                read -s -p "Create password for postgress system account: " input
                [ -n "${input}" ] && pg_sys_acct_passwd=${input}  && unset input && break
            done
        fi
        echo "Creating account..."
        /usr/sbin/useradd -r -c"PostgreSQL Service" -g $pg_sys_acct_group -p $pg_sys_acct_passwd -s /bin/bash $pg_sys_acct
        [ $? != 0 ] && [ $? != 9 ] && echo "ERROR: Could not add postgres system account user" && popd && checked_done 1
        echo "${pg_sys_acct_passwd}" > ${pg_secret_file}
        chmod 600 ${pg_secret_file}
        chown ${installer_uid}:${installer_gid} ${pg_secret_file}
    fi

    ########
    sleep 3
    #double check that the account is really there!
    echo
    id $pg_sys_acct >& /dev/null
    [ $? != 0 ] && grep $pg_sys_acct /etc/passwd && echo " ERROR: Problem with $pg_sys_acct creation!!!" && checked_done 1

    chown -R $pg_sys_acct $postgress_install_dir
    chgrp -R $pg_sys_acct_group $postgress_install_dir
    

    #Create the database:
    mkdir -p ${postgress_install_dir}/data
    chown -R ${pg_sys_acct} ${postgress_install_dir}/data
    [ $? != 0 ] && " ERROR: Could not change ownership of postgres' data to \"$pg_sys_acct\" user" && popd && checked_done 1

    chmod 700 $postgress_install_dir/data
    su $pg_sys_acct -c "$postgress_install_dir/bin/initdb -D $postgress_install_dir/data"
    mkdir $postgress_install_dir/log
    chown -R $pg_sys_acct $postgress_install_dir/log
    [ $? != 0 ] && " ERROR: Could not change ownership of postgres' log to \"$pg_sys_acct\" user" && popd && checked_done 1


    #Start the database 
    start_postgress

    #Check to see if there is a ${postgress_user} already on the system if not, make one
    if [ -x ${postgress_install_dir}/bin/psql ] && (( $(psql -c "select count(*) from pg_roles where rolname='${postgress_user}'" postgres | tail -n +3 | head -n 1) > 0 )); then
        echo "${postgress_user} exists!! :-)";
    else
        echo "$postgress_install_dir/bin/createuser -U $pg_sys_acct -P -s -e $postgress_user"
        $postgress_install_dir/bin/createuser -U $pg_sys_acct -P -s -e $postgress_user
        [ $? != 0 ] && echo " ERROR: Unable to create user on the system" && popd && checked_done 1
    fi
    #stop_postgress && return 1 #See trap in 'main'... that is who calls this.
    
    local fetch_file

    cd $postgress_install_dir/data
    #Get files
    fetch_file=pg_hba.conf
    checked_get ./${fetch_file} ${esg_dist_url}/externals/bootstrap/${fetch_file} $((force_install))
    (( $? > 1 )) && popd && checked_done 1
    chmod 600 ${fetch_file}


    #Get File...
    fetch_file=postgresql.conf
    checked_get ./${fetch_file} ${esg_dist_url}/externals/bootstrap/${fetch_file} $((force_install))
    (( $? > 1 )) && popd && checked_done 1
    chmod 600 ${fetch_file}

    #-----
    #NOTE: This database is an internal database to this esg
    #application stack... I don't think it would even be prudent to
    #offer then opportunity for someone to bind to the public
    #interface.  If they choose to do so after the fact, then they are
    #making that conscious decision, but I won't make it a part of
    #this process.

    #@@postgress_host@@ #Token in file...

    #local input
    #read -p "Please Enter the IP address or name of this host [${postgress_host}]:> " input
    #[ ! -z "${input}" ] && postgress_host=${input}
    #printf "\nUsing IP: ${postgress_host}\n"
    #eval "perl -p -i -e 's/\\@\\@postgress_host\\@\\@/${postgress_host}/g' ${fetch_file}"    
    #-----

    #@@postgress_port@@ #Token in file...

    unset input
    read -p "Please Enter PostgreSQL port number [${postgress_port}]:> " input
    [ ! -z "${input}" ] && postgress_port=${input}
    printf "\nSetting Postgress Port: ${postgress_port} "
    eval "perl -p -i -e 's/\\@\\@postgress_port\\@\\@/${postgress_port}/g' ${fetch_file}"    
    [ $? == 0 ] && printf "[OK]\n" || printf "[FAIL]\n"

    printf "Setting Postgress Log Dir: ${postgress_install_dir} "
    eval "perl -p -i -e 's#\\@\\@postgress_install_dir\\@\\@#${postgress_install_dir}#g' ${fetch_file}"    
    [ $? == 0 ] && printf "[OK]\n" || printf "[FAIL]\n"

    chown -R $pg_sys_acct $postgress_install_dir
    chgrp -R $pg_sys_acct_group $postgress_install_dir
    
    popd >& /dev/null
    echo
    check_shmmax
    echo
    write_postgress_env
    write_postgress_install_log
    checked_done 0
}

write_postgress_env() {
    ((show_summary_latch++))
    echo "export PGHOME=$PGHOME" >> ${envfile}
    echo "export PGUSER=$PGUSER" >> ${envfile}
    echo "export PGHOST=$PGHOST" >> ${envfile}
    echo "export PGPORT=$PGPORT" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_postgress_install_log() {
    echo "$(date ${date_format}) postgres=${postgress_version} ${postgress_install_dir}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

#returns 1 if it is already running (if check_postgress_process returns 0 - true)
start_postgress() {
    check_postgress_process && return 1
    
    echo "Starting Postgress..."
    echo "su $pg_sys_acct -c \"$postgress_install_dir/bin/pg_ctl -D $postgress_install_dir/data start\""
    su $pg_sys_acct -c "$postgress_install_dir/bin/pg_ctl -D $postgress_install_dir/data start"
    [ $? != 0 ] && echo " ERROR: Could not start database!" && popd && return 1

    #NOTE: How long does it take for the database to come up? Set sleep appropriately
    echo -n "Giving database time to startup... 3 seconds " 
    sleep 3
    /bin/ps -elf | grep postgres | grep -v grep
    checked_done 0
}

stop_postgress() {
    sleep 1
    #Stop the database
    #su postgres -c "pg_ctl -D /usr/local/pgsql/data stop" #(gently stop server) 
    #

    check_postgress_process 
    [ $? != 0 ] && return 1    

    echo 
    echo "stop postgress: su $pg_sys_acct -c \"pg_ctl -D $postgress_install_dir/data -m i stop\""
    su $pg_sys_acct -c "pg_ctl -D $postgress_install_dir/data -m i stop" #(stop server immediately)
    if [ $? != 0 ]; then
        echo " WARNING: Unable to stop the database (nicely)" 
        echo " Hmmm...  okay no more mr nice guy... issuing \"killall postgres\""
        killall postgres
        [ $? != 0 ] && echo "Hmmm... still could not shutdown... do so manually"
    fi
    /bin/ps -elf | grep postgres | grep -v grep
    return 0
}

test_postgress() {
    echo
    echo "----------------------------"
    echo "Postgress Test...  "
    echo "----------------------------"
    echo 
    start_postgress

    ${postgress_install_dir}/bin/psql --version
    [ $? != 0 ] && echo" ERROR: Could NOT successfully locate postgres installation!!" && popd >& /dev/null && checked_done 1

    local ret=$(PGPASSWORD=${PGPASSWORD:-${pg_sys_acct_passwd}} psql -qt -c "select table_name from information_schema.tables;" postgres ${postgress_user} | grep -v ^$ | wc -l)
    ((ret == 0)) && echo " ERROR: Could not verify database installation! (perhaps \"pg_sys_acct_passwd\"  was not set correctly?)" && checked_done 1
    echo "[OK]"
    checked_done 0
}

#####
# Python/CDMS
#####
setup_cdat() {
    echo -n "Checking for CDAT (Python+CDMS) ${cdat_version}"
    check_version_with "cdat" ${cdat_version} '${cdat_home}/bin/python -c "import cdat_info; print cdat_info.Version"'
    local ret=$?
    ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up CDAT - (Python + CDMS)... ${cdat_version}"
    echo "*******************************"
    echo

    local dosetup
    if [ -x ${cdat_home}/bin/cdat ]; then 
        echo "Detected an existing CDAT installation..."
        read -p "Do you want to continue with CDAT installation and setup? [y/N] " dosetup
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping CDAT installation and setup - will assume CDAT is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null
    if [ ! -d ${workdir}/cdat ]; then
        echo "Fetching the cdat project from GIT Repo..."
        git clone ${cdat_repo}
        if [ ! -d ${workdir}/cdat/.git ]; then
            echo "Apparently was not able to fetch from GIT repo using git protocol... trying http protocol..."
            git clone ${cdat_repo_http}
            [ ! -d ${workdir}/cdat/.git ] && echo "Could not fetch from cdat's repo (with git nor http protocol)" && checked_done 1
        fi
    fi
    cd cdat >& /dev/null
    git checkout ${cdat_version}
    [ $? != 0 ] && echo " WARNING: Problem with checking out cdat revision [${cdat_version}] from repository :-("

    echo "cleaning things out" 
    ./clean_script

    #NOTE: 
    #cdms configuration with --enable-esg flag looks for pg_config in
    #$postgress_install_dir/bin.  This location is created and added
    #to the executable PATH by the 'setup_postgress' function.
    
    echo "./configure --prefix=$cdat_home --enable-esg"
    ./configure --prefix=${cdat_home} --enable-esg   
    [ $? != 0 ] && echo " ERROR: Configure did not complete successfully" && popd && checked_done 1
    make
    [ $? != 0 ] && echo " ERROR: Could not compile (make) cdat code" && popd && checked_done 1

    ${cdat_home}/bin/python -c "import cdms2" 2>/dev/null
    [ $? != 0 ] && echo " ERROR: Could not load CDMS (cdms2) module" && popd && checked_done 1

    popd >& /dev/null    
    echo
    write_cdat_env
    write_cdat_install_log
    checked_done 0
}

write_cdat_env() {
    ((show_summary_latch++))
    echo "export CDAT_HOME=${cdat_home}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_cdat_install_log() {
    echo "$(date ${date_format}) cdat=${cdat_version} ${cdat_home}" >> ${install_logfile}
    
    #Parse the cdat installation config.log file and entries to the install log
    if [ -e ${workdir}/cdat/config.log ]; then
        awk '/building/ {print "'"$(date ${date_format})"' cdat->"$(NF-1)":"$2"="$NF" '"${cdat_home}"'"}' ${workdir}/cdat/config.log >> ${install_logfile}
    else
        echo " WARNING: Could not find cdat config.log file [${workdir}/cdat/config.log] installation log entries could not be generated!"
    fi
    
    dedup ${install_logfile}
    return 0
}


#####
# ESGCET Package
#####
setup_esgcet() {

    echo -n "Checking for esgcet (publisher) ${esgcet_version}"
    check_module_version esgcet ${esgcet_version}
    local ret=$?
    ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0
    
    local upgrade=${1:-${ret}}

    local mode="I"
    ( ((upgrade < 2)) && (( ! force_install )) ) && mode="U" || mode="I"
    
    echo
    echo "*******************************"
    echo "Setting up ESGCET Package...(${esgcet_egg_file}) [${mode}]"
    echo "*******************************"
    echo
    
    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -e ${HOME}/.esgcet/esg.ini ]; then 
        echo "Detected an existing esgcet installation..."
        read -p "Do you want to continue with esgcet installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping esgcet installation and setup - will assume esgcet is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && return 1
    pushd ${workdir} >& /dev/null
    
    #Gives you 30 seconds to make a choice or will choose "I" by default
    #local choice
    #while [ 1 ]; do
    #    read -t $((1*60)) -p "Is this an install or update of the esgcet module? $([ "${mode}" = "I" ] && echo "[I/u]" || echo "[i/U]"): " choice
    #    [ -z "${choice}" ] && choice=$(echo "${mode}" | tr [a-z] [A-Z])
    #    if [ "${choice}" = "i" ] || [ "${choice}" = "I" ]; then
    #        #echo "$cdat_home/bin/easy_install -f ${esg_dist_url}/externals esgcet"
    #        #$cdat_home/bin/easy_install -f ${esg_dist_url}/externals esgcet
             checked_get ${esgcet_egg_file} ${esg_dist_url}/externals/${esgcet_egg_file} $((force_install))
             (( $? > 1 )) && return 0
             $cdat_home/bin/easy_install ${esgcet_egg_file}
             [ $? != 0 ] && checked_done 1
    #    elif [ "${choice}" = "u" ] || [ "${choice}" = "U" ]; then
    #        #echo "$cdat_home/bin/easy_install --upgrade -f ${esg_dist_url}/externals esgcet"
    #        #$cdat_home/bin/easy_install --upgrade -f ${esg_dist_url}/externals esgcet
    #        checked_get ${esgcet_egg_file} ${esg_dist_url}/externals/${esgcet_egg_file} $((force_install))
    #        (( $? > 1 )) && return 0
    #        $cdat_home/bin/easy_install --upgrade ${esgcet_egg_file}
    #        [ $? != 0 ] && checked_done 1
    #    else
    #        echo "Not a valid selection... [${choice}] try again"
    #        continue
    #    fi
    #    break
    #done

    if [ "${mode}" = "I" ]; then
        local input=""
        read -p "What is your organization's id? [${esg_root_id}]: " input
        [ ! -z "${input}" ] && esg_root_id=${input}
        
        echo "$cdat_home/bin/esgsetup --config --rootid ${esg_root_id}" 
        $cdat_home/bin/esgsetup --config --rootid ${esg_root_id}
        [ $? != 0 ] && popd && checked_done 1
    fi

    echo "chown -R ${installer_uid}:${installer_gid} $HOME/.esgcet"
    chown -R ${installer_uid}:${installer_gid} $HOME/.esgcet 
    [ $? != 0 ] && echo "**WARNING**: Could not change owner successfully - this will lead to inability to use the publisher properly!"
    #Let's make sure the group is there before we attempt to assign a file to it....
    /usr/sbin/groupadd -r -f ${tomcat_group}
    [ $? != 0 ] && [ $? != 9 ] && echo "ERROR: *Could not add tomcat system group: ${tomcat_group}" && popd && checked_done 1
    chgrp ${tomcat_group} ${HOME}/.esgcet/esg.ini && chmod 640 ${HOME}/.esgcet/esg.ini && chmod 755 ${HOME}
    [ $? != 0 ] && echo "**WARNING**: Could not change group successfully - this will lead to inability to use the publisher properly!"
    start_postgress

    if [ "${mode}" = "U" ]; then
        echo "${cdat_home}/bin/esginitialize -c"
        ${cdat_home}/bin/esginitialize -c
        [ $? != 0 ] && popd && checked_done 1
    else
        echo "$cdat_home/bin/esgsetup --db"
        $cdat_home/bin/esgsetup --db
        [ $? != 0 ] && popd && checked_done 1
    fi

    popd >& /dev/null
    echo
    echo
    write_esgcet_env
    write_esgcet_install_log
    checked_done 0
}

write_esgcet_env() {
    echo "export ESG_ROOT_ID=$esg_root_id" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_esgcet_install_log() {
    echo "$(date ${date_format}) python:esgcet=${esgcet_version}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}


test_esgcet() {
    echo
    echo "----------------------------"
    echo "ESGCET Test... "
    echo "----------------------------"
    echo
    pushd $workdir >& /dev/null

    start_postgress

    #esgcet_testdir=$(readlink -f ${thredds_root_dir})/test
    esgcet_testdir=${thredds_root_dir}/test
    mkdir -p ${esgcet_testdir}
    [ $? != 0 ] && checked_done 1
    mkdir -p ${thredds_replica_dir}
    [ $? != 0 ] && checked_done 1

    echo "esgcet test directory: [${esgcet_testdir}]"
    local fetch_file
    fetch_file=sftlf.nc
    checked_get ${esgcet_testdir}/${fetch_file} ${esg_dist_url}/externals/${fetch_file} $((force_install))
    (( $? > 1 )) && echo " ERROR: Problem pulling down ${fetch_file} from esg distribution" && popd && checked_done 1


    #Run test...
    echo "$cdat_home/bin/esginitialize -c "
    $cdat_home/bin/esginitialize -c 
    echo "$cdat_home/bin/esgscan_directory --dataset pcmdi.${esg_root_id}.test.mytest --project test ${esgcet_testdir} > mytest.txt"
    $cdat_home/bin/esgscan_directory --dataset pcmdi.${esg_root_id}.test.mytest --project test ${esgcet_testdir} > mytest.txt
    [ $? != 0 ] && echo " ERROR: ESG directory scan failed" && popd && checked_done 1
    
    echo "$cdat_home/bin/esgpublish --map mytest.txt --project test --model test"
    $cdat_home/bin/esgpublish --map mytest.txt --project test --model test
    [ $? != 0 ] && echo " ERROR: ESG publish failed" && popd && checked_done 1
    

    popd >& /dev/null
    echo
    echo
    checked_done 0
}

#####
# Apache Tomcat
# arg 1 -> The password for the current keystore
#####
setup_tomcat() {
    echo -n "Checking for tomcat >= ${tomcat_min_version}"
    check_app_version ${tomcat_install_dir} ${tomcat_min_version}
    local ret=$?
    ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up Apache Tomcat...(v${tomcat_version})"
    echo "*******************************"
    echo 

    local upgrade=${1:-0}
    local last_install=$(readlink -f ${tomcat_install_dir})

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${tomcat_install_dir}/bin/jsvc ]; then 
        echo "Detected an existing tomcat installation..."
        read -p "Do you want to continue with Tomcat installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z "${dosetup}" ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping tomcat installation and setup - will assume tomcat is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null
    
    local tomcat_dist_file=${tomcat_dist_url##*/}
    #strip off .tar.gz at the end
    tomcat_dist_dir=$(echo ${tomcat_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')

    #There is this pesky case of having a zero sized dist file... WTF!?                                                                            
    if [ -e ${tomcat_dist_file} ]; then
        ls -l ${tomcat_dist_file}
        local size=$(stat -c%s ${tomcat_dist_file})
        (( size == 0 )) && rm -v ${tomcat_dist_file}
    fi

    #Check to see if we have a tomcat distribution directory
    if [ ! -e ${tomcat_install_dir%/*}/${tomcat_dist_dir} ]; then
        echo "Don't see tomcat distribution dir ${tomcat_install_dir%/*}/${tomcat_dist_dir}"
        if [ ! -e ${tomcat_dist_file} ]; then
            echo "Don't see tomcat distribution file $(pwd)/${tomcat_dist_file} either"
            echo "Downloading Tomcat from ${tomcat_dist_url}"
            wget -O ${tomcat_dist_file} ${tomcat_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download Tomcat" && popd && checked_done 1
            echo "unpacking ${tomcat_dist_file}..."
            tar xzf ${tomcat_dist_file} -C ${tomcat_install_dir%/*} # i.e. /usr/local
            [ $? != 0 ] && echo " ERROR: Could not extract Tomcat" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it
    if [ -e ${tomcat_dist_file} ] && [ ! -e ${tomcat_install_dir%/*}/${tomcat_dist_dir} ]; then
        echo "unpacking ${tomcat_dist_file}..."
        tar xzf ${tomcat_dist_file} -C ${tomcat_install_dir%/*} # i.e. /usr/local
        [ $? != 0 ] && echo " ERROR: Could not extract Tomcat..." && popd && checked_done 1
    fi

    if [ ! -e ${tomcat_install_dir} ]; then
        ln -s ${tomcat_install_dir%/*}/${tomcat_dist_dir} ${tomcat_install_dir}
        [ $? != 0 ] && \
            echo " ERROR: Could not create sym link ${tomcat_install_dir%/*}/${tomcat_dist_dir} -> ${tomcat_install_dir}" && popd && checked_done 1
    else
        unlink ${tomcat_install_dir}
        [ $? != 0 ] && mv ${tomcat_install_dir} ${tomcat_install_dir}.$(date ${date_format}).bak

        ln -s ${tomcat_install_dir%/*}/${tomcat_dist_dir} ${tomcat_install_dir}
        [ $? != 0 ] && \
            echo " ERROR: Could not create sym link ${tomcat_install_dir%/*}/${tomcat_dist_dir} -> ${tomcat_install_dir}" && popd && checked_done 1
    fi

    #If there is no tomcat user on the system create one (double check that usradd does the right thing)
    id $tomcat_user
    if [ $? != 0 ]; then 
        echo " WARNING: There is no tomcat user \"$tomcat_user\" present on system"
        #NOTE: "useradd/groupadd" are a RedHat/CentOS thing... to make this cross distro compatible clean this up.
        /usr/sbin/groupadd -r -f ${tomcat_group}
        [ $? != 0 ] && [ $? != 9 ] && echo "ERROR: Could not add tomcat system group: ${tomcat_group}" && popd && checked_done 1
        /usr/sbin/useradd -r -c"Tomcat Server Identity" -g $tomcat_group $tomcat_user
        [ $? != 0 ] && [ $? != 9 ] && echo "ERROR: Could not add tomcat system account user \"$tomcat_user\"" && popd && checked_done 1
    fi
    

    cd $tomcat_install_dir

    #----------
    #build jsvc (if necessary)
    #----------
    echo -n "Checking for jsvc... "
    pushd ./bin >& /dev/null
    if [ -e ./jsvc ] && [ -x ./jsvc ]; then
        echo "[OK]"
    else
        echo "[NOT PRESENT]"
        stop_tomcat
        echo "Building jsvc... (JAVA_HOME=$java_install_dir)"

        if [ -e commons-daemon-native.tar.gz ]; then
            echo "unpacking commons-daemon-native.tar.gz..."
            tar xzf commons-daemon-native.tar.gz
            cd commons-daemon-*-native-src/unix
            #It turns out they shipped with a conflicting .o file in there (oops) so I have to remove it manually.
            rm -f ./native/libservice.a
            make clean
        elif [ -e jsvc.tar.gz ]; then
            echo "unpacking jsvc.tar.gz..."
            tar xzf jsvc.tar.gz
            cd jsvc-src
            autoconf
        else
            echo "NOT ABLE TO INSTALL JSVC!" && checked_done 1
        fi

        chmod 755 ./configure
        ./configure --with-java=${java_install_dir}
        make
        [ -x ./jsvc ] && cp ./jsvc ${tomcat_install_dir}/bin
    fi
    popd >& /dev/null
    #----------
    
    #----------------------------------
    # Upgrade logic...
    #----------------------------------
    if ((upgrade)) ; then
        stop_tomcat
        echo "Upgrading tomcat installation from $(readlink -f ${last_install} | sed -ne 's/.*-\(.*\)$/\1/p') to $(readlink -f ${tomcat_install_dir} | sed -ne 's/.*-\(.*\)$/\1/p')"

        echo -n "copying webapps... "
        cp -R ${last_install}/webapps ${tomcat_install_dir}/
        [ $? == 0 ] && echo "[OK]" || echo "[FAIL]"

        echo -n "copying configuration... "
        cp -R ${last_install}/conf ${tomcat_install_dir}/
        [ $? == 0 ] && echo "[OK]" || echo "[FAIL]"

        echo -n "copying logs... "
        cp -R ${last_install}/logs ${tomcat_install_dir}/
        [ $? == 0 ] && echo "[OK]" || echo "[FAIL]"

        echo "upgrade migration complete"
    else
        local store_password=${1}
        configure_tomcat ${store_password}
    fi
    #----------------------------------
        
    chown -R $tomcat_user $(readlink -f ${tomcat_install_dir})
    [ $? != 0 ] && " ERROR: Could not change ownership of tomcat to \"$tomcat_user\" user" && popd && checked_done 1
    chgrp -R $tomcat_group $(readlink -f ${tomcat_install_dir})
    [ $? != 0 ] && " ERROR: Could not change group of tomcat to \"$tomcat_user\" user" && popd && checked_done 1
    
    #-------------------------------
    # For Security Reasons...
    #-------------------------------

    if [ -d ${tomcat_install_dir}/webapps/examples ]; then
        local dodel="Y"
        echo "For security reasons we recommend removing the examples web app [$(readlink -f ${tomcat_install_dir}/webapps/examples)]"
        readlink -f ${tomcat_install_dir}/webapps/examples
        ((VERBOSE)) && read -p "Is the directory shown above correct? [Y/n] " dodel
        if [ "${dodel}" = "Y" ] || [ "${dodel}" = "y" ] || [ -z "${dodel}" ]; then
            rm -rf ${tomcat_install_dir}/webapps/examples && echo "removed the examples webapp..."
        fi
    fi

    checked_get ${tomcat_install_dir}/webapps/ROOT/robots.txt ${esg_dist_url}/robots.txt $((force_install))

    start_tomcat

    #---
    #port testing for http and https
    #---
    local ret_all=0
    local ports=$(sed -n 's/.*Connector.*port="\([0-9]*\)".*/\1/p' ${tomcat_install_dir}/conf/server.xml)
    echo "checking connection at all ports described in server.xml: "${ports}
    for port in ${ports[@]}; do
        echo -n "checking http://localhost:${port} "
        local wait_time=5
        local ret=1
        while [[ $wait_time > 0 ]]; do
            curl http://localhost:${port} >& /dev/null
            ret=$?
            [ $ret == 0 ] && break
            sleep 1
            : $((wait_time--))
            echo -n "."
        done
        [ $ret == 0 ] && echo " [OK]" || echo " [FAIL]"

        #We only care about reporting a failure for ports below 1024 
        #specifically 80 (http) and 443 (https)
        (($port < 1024)) && ((ret_all+=ret))

    done
    
    [ $ret_all != 0 ] && echo "[FAILED]" && echo " ERROR: Not able to contact top level tomcat page on this server" && popd && checked_done 1
    echo "[OK]"
    #---

    echo
    popd >& /dev/null
    echo
    echo
    write_tomcat_env
    write_tomcat_install_log
    return 0
}

write_tomcat_env() {
    ((show_summary_latch++))
    echo "export CATALINA_HOME=${CATALINA_HOME}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_tomcat_install_log() {
    echo "$(date ${date_format}) tomcat=${tomcat_version} $(readlink -f ${tomcat_install_dir})" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

configure_tomcat() {
    #----------------------------
    # TOMCAT Configuration...
    #----------------------------

    echo
    echo "*******************************"
    echo "Configuring Tomcat... (for Node Manager)"
    echo "*******************************"
    echo

    pushd ${tomcat_install_dir}/conf #>& /dev/null
    
    local fetch_file
    local genreq=N

    fetch_file=server.xml
    checked_get ./${fetch_file} ${esg_dist_url}/externals/bootstrap/node.${fetch_file} $((force_install))
    (( $? > 1 )) && popd && checked_done 1
    chmod 600 ${fetch_file}

    #Create a keystore in $tomcat_conf_dir
    echo "Keystore setup: "
    local store_password=${1}
    if [ ! -e ${keystore_file} ]; then
        echo "Launching Java's keytool:"
        
        if [ -z "${store_password}" ]; then
            local verify_password
            while [ 1 ]; do
                echo
                read -s -p "Please enter the password for this keystore   : " store_password
                [ "${store_password}" = "changeit" ] && break
                [ -z "${store_password}" ] && echo "Invalid password [${store_password}]" && continue
                echo
                read -s -p "Please re-enter the password for this keystore: " verify_password
                if [ "${store_password}" = "${verify_password}" ] ; then
                    echo
                    break
                else
                    echo "Sorry, values did not match"
                    echo
                fi
            done
            unset verify_password
            echo
        else 
            echo "store_password = ******"
        fi

        #NOTE:
        #As Reference on Distingueshed Names (DNs)
        #http://download.oracle.com/javase/1.4.2/docs/tooldocs/windows/keytool.html
        #According to that document, case does not matter but ORDER DOES!
        #See script scope declaration of this variable (dname="OU=simpleCA-pcmdi3.llnl.gov, OU=GlobusTest, O=Grid")

        if [ -z "${dname}" ]; then
            $java_install_dir/bin/keytool -genkey -alias ${keystore_alias} -keyalg RSA -keystore ${keystore_file} -validity 365 -storepass ${store_password}
            [ $? != 0 ] && echo " ERROR: keytool genkey command failed" && popd && checked_done 1
        else
            echo "${dname}" | grep -i 'cn='
            [ $? != 0 ] && dname="CN=$(hostname --fqdn), ${dname}"
            echo "Using keystore DN = ${dname}"
            $java_install_dir/bin/keytool -genkey -dname "${dname}" -alias ${keystore_alias} -keyalg RSA -keystore ${keystore_file} -validity 365 -storepass ${store_password}
            [ $? != 0 ] && echo " ERROR*: keytool genkey command failed" && popd && checked_done 1
        fi
        
        genreq="Y"
    else
        echo "Using existing keystore \"${keystore_file}\""
    fi

    local answer
    read -p "Do you wish to generate a Certificate Signing Request at this time? $([ $genreq = "Y" ] && echo "[Y/n]" || echo "[y/N]") " answer
    [ -n "${answer}" ] && genreq=${answer}
    unset answer
    echo " -> [${genreq}]"
    if [ "${genreq}" == "Y" ] || [ "${genreq}" == "y" ]; then
        echo "Generating Certificate Signing Request..."
        #-------------------------------------------------
        #Previous way, when we were generating the request directly from the keystore via keytool
        #${java_install_dir}/bin/keytool -certreq -alias ${keystore_alias} -keystore ${keystore_file} -file ${HOME}/$(hostname --fqdn)-esg-node.csr
        #[ $? != 0 ] && echo " ERROR: keytool certreq command failed"
        #-------------------------------------------------

        #Now we generate the key and cert externally, but maintaining the DN specified in the, just built, keystore
        local dn=$(extract_keystore_dn ${keystore_file} ${store_password})
        sleep 1
        generate_ssl_key_and_csr ${tomcat_conf_dir}/hostkey.pem ${tomcat_conf_dir}/$(hostname --fqdn)-esg-node.csr ${dn}
        [ $? != 0 ] && echo " ERROR: Unable to generate ssl key and csr! (you will have to run --generate-ssl-key-and-csr after installation)"

        chown -R ${installer_uid}:${installer_gid} $(hostname --fqdn)-esg-node.csr
    fi
    

    #Fetch/Copy truststore to $tomcat_conf_dir
    #(first try getting it from distribution server otherwise copy Java's)
    if [ ! -e ${truststore_file} ]; then
        fetch_file=${truststore_file##*/} # i.e. esg-truststore.ts
        checked_get ${truststore_file} ${esg_dist_url}/certs/${fetch_file} $((force_install))
        if (( $? > 1 )); then
            echo " INFO: Could not download certificates ${fetch_file} for tomcat - will copy local java certificate file"
            echo "(note - the truststore password will probably not match!)"
            cp -v ${java_install_dir}/jre/lib/security/cacerts ${truststore_file}
            [ $? != 0 ] && echo " ERROR: Could not fetch or copy ${fetch_file} for tomcat!!" && popd && checked_done 1
        fi
    fi

    add_my_cert_to_truststore ${store_password}


    #NOTE: The truststore uses the java default password: "changeit"

    #Edit the server.xml file to contain proper location of certificates
    eval "perl -p -i -e 's#\\@\\@tomcat_users_file\\@\\@#${tomcat_users_file}#g' server.xml"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@truststore_file\\@\\@#${truststore_file}#g' server.xml"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@truststore_password\\@\\@#changeit#g' server.xml"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@keystore_file\\@\\@#${keystore_file}#g' server.xml"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@keystore_password\\@\\@#${store_password}#g' server.xml"
    echo "*"

    #clean up the password immediately after it is done being used
    keystore_password=${store_password} #don't want to do this but it is used by the esg-security script that installs the ORP
    unset store_password

    chown -R $tomcat_user $(readlink -f ${tomcat_install_dir})
    [ $? != 0 ] && " ERROR: Could not change ownership of tomcat to \"$tomcat_user\" user" && popd && checked_done 1
    chgrp -R $tomcat_group $(readlink -f ${tomcat_install_dir})
    [ $? != 0 ] && " ERROR: Could not change group of tomcat to \"$tomcat_user\" user" && popd && checked_done 1

    chown -R $tomcat_user $(readlink -f ${tomcat_conf_dir})
    [ $? != 0 ] && " ERROR: Could not change ownership of esg's tomcat config dir to \"$tomcat_user\" user" && popd && checked_done 1
    chgrp -R $tomcat_group $(readlink -f ${tomcat_conf_dir})
    [ $? != 0 ] && " ERROR: Could not change group of esg's tomcat config dir to \"$tomcat_user\" user" && popd && checked_done 1

    popd #>& /dev/null
}


start_tomcat() {
    check_tomcat_process
    local ret=$? 
    ((ret == 0)) && return 1
    ((ret == 3)) && echo "Please resolve this issue before starting tomcat!" && checked_done $ret

    echo "Starting Tomcat (jsvc)..."
    pushd $tomcat_install_dir >& /dev/null
    [ $((sel & ALL_BIT)) != 0 ]  && java_opts+=' -Xmx2048m -Xms1024m -XX:MaxPermSize=128m'
    jsvc_launch_command="JAVA_HOME=$java_install_dir ${tomcat_install_dir}/bin/jsvc -Djava.awt.headless=true -Dcatalina.home=${tomcat_install_dir} -pidfile $tomcat_pid_file -cp $(find $(readlink -f `pwd`/bin/) | grep jar | xargs | perl -pe 's/ /:/g') -outfile ${tomcat_install_dir}/logs/catalina.out -errfile ${tomcat_install_dir}/logs/catalina.err -user $tomcat_user $tomcat_opts $java_opts -Dsun.security.ssl.allowUnsafeRenegotiation=false org.apache.catalina.startup.Bootstrap"
    echo "$jsvc_launch_command"
    JAVA_HOME=${java_install_dir} ./bin/jsvc \
        -Djava.awt.headless=true \
        -Dcatalina.home=${tomcat_install_dir} \
        -pidfile ${tomcat_pid_file} \
        -cp $(find $(readlink -f `pwd`/bin/) | grep .jar | xargs | perl -pe 's/ /:/g') \
        -outfile ${tomcat_install_dir}/logs/catalina.out \
        -errfile ${tomcat_install_dir}/logs/catalina.err \
        -user $tomcat_user \
        ${tomcat_opts} \
        $java_opts -Dsun.security.ssl.allowUnsafeRenegotiation=false \
        org.apache.catalina.startup.Bootstrap
    if [ $? != 0 ]; then 
        echo " ERROR: Could not start up tomcat"
        tail ./logs/catalina.err
        popd >& /dev/null
        checked_done 1
    fi
    
    #Don't wait forever, but give tomcat some time before it starts
    pcheck 10 2 1 -- check_tomcat_process
    [ $? != 0 ] && echo "Tomcat couldn't be started."

}

stop_tomcat() {
    #
    #Stop Tomcat
    #% sudo /usr/local/tomcat/bin/jsvc -pidfile /var/run/tomcat-jsvc.pid -stop org.apache.catalina.startup.Boostrap
    #

    check_tomcat_process 
    [ $? != 0 ] && return 1

    pushd $tomcat_install_dir >& /dev/null
    echo 
    echo "stop tomcat: ${tomcat_install_dir}/bin/jsvc -pidfile $tomcat_pid_file -stop org.apache.catalina.startup.Bootstrap"
    echo "(please wait)"
    sleep 1
    ${tomcat_install_dir}/bin/jsvc -pidfile $tomcat_pid_file -stop org.apache.catalina.startup.Bootstrap
    if [ $? != 0 ]; then
        local ret=0
        echo " WARNING: Unable to stop tomcat, (nicely)" 
        echo -n " Hmmm...  okay no more mr nice guy... issuing "
        #echo -n "\"killall jsvc\" and " && killall jsvc
        #((ret+=$?))
        echo -n "\"pkill -9 $(cat ${tomcat_pid_file})\"" && kill -9 $(cat ${tomcat_pid_file}) >& /dev/null
        ((ret+=$?))
        echo ""
        [ "$ret" != 0 ] && echo "Hmmm... still could not shutdown... process may have already been stopped"
    fi
    /bin/ps -elf | grep jsvc | grep -v grep
    popd >& /dev/null
    return 0
}

test_tomcat() {

    echo
    echo "----------------------------"
    echo "Tomcat Test...  "
    echo "----------------------------"
    echo
    start_tomcat
    
    echo "giving tomcat some time to wake up"
    sleep 5

    #check_tomcat_process 
    #[ $? != 0 ] && echo "[FAILED] process not running..." && return 0
    ports=$(sed -n 's/.*Connector.*port="\([0-9]*\)".*/\1/p' $tomcat_install_dir/conf/server.xml)
    echo "checking connection at ports "$ports
    local running_port="$(
            echo "$ports" | while read check_port; do
                echo "checking $check_port" >&2
                wget http://localhost:$check_port -O - -q >/dev/null
                if [[ $? == "0" ]]; then
                    echo $check_port
                    break
                fi
            done
            )"
    
    if [[ -n "$running_port" ]]; then
        echo "Tomcat is running on port $running_port"
        checked_done 0
    else
        echo "Tomcat is not listening to any listed port."
        checked_done 1
    fi

}


#####
# THREDDS Data Server
#####
setup_tds() {
    echo -n "Checking for thredds (tds) >= ${tds_min_version}"
    check_webapp_version "thredds" ${tds_min_version} "Implementation-Version"
    local ret=$?
    ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up Thredds Data Server... v${tds_version}"
    echo "*******************************"
    echo

    local upgrade=${1:-0}

    local dosetup
    if [ -d ${tomcat_install_dir}/webapps/thredds ]; then 
        echo "Detected an existing thredds installation..."
        read -p "Do you want to continue with thredds installation and setup? [y/N] " dosetup
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping thredds installation and setup - will assume thredds is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && return 1
    pushd ${workdir} >& /dev/null
    local fetch_file

    ############################
    #Download the thredds.war file home site (or use value of thredds_dist_file if already set)
    ############################

    thredds_dist_file=${thredds_dist_file:-${thredds_dist_url##*/}}
    
    #There is this pesky case of having a zero sized dist file... WTF!?                                                                            
    if [ -e ${thredds_dist_file} ]; then
        ls -l ${thredds_dist_file}
        local size=$(stat -c%s ${thredds_dist_file} >& /dev/null)
        (( size == 0 )) && rm -v ${thredds_dist_file}
    fi

    #Check to see if we have this war file already in the workbench...
    #if [ ! -e ${thredds_dist_file} ]; then
    #   wget -O ${thredds_dist_file} ${thredds_dist_url}
    #   if [ $? != 0 ]; then
    #       echo " ERROR: Could not download ${thredds_dist_url},... fetching the copy at PCMDI (LLNL)..."
    checked_get ${thredds_dist_file} ${thredds_esg_dist_url} $((force_install))
    (( $? > 1 )) && echo " ERROR: Could not download ${thredds_esg_dist_url} either" && popd && checked_done 1
    #   fi
    #fi
    
    stop_tomcat
    
    #-------------------------------------------
    #installing the thredds web app ("manually") //zoiks
    echo "Installing thredds app..."
    mkdir -p ${tomcat_install_dir}/webapps
    pwd
    cp -v $(readlink -f ${thredds_dist_file}) ${tomcat_install_dir}/webapps/
    pushd ${tomcat_install_dir}/webapps
    [ $? != 0 ] && echo " Error: could not go to ${tomcat_install_dir}/webapps directory be sure tomcat is installed!" && checked_done 1

    mkdir -p thredds
    cd thredds

    #move the current web.xml file out of the way
    local webapp_config_file=${tomcat_install_dir}/webapps/thredds/WEB-INF/web.xml
    if ((upgrade)) && [ -e ${webapp_config_file} ]; then
        cp -v ${webapp_config_file} ${webapp_config_file}.saved
    fi
    
    jar xf ../${thredds_dist_file}
    cd ..
    chown -R ${tomcat_user}  thredds*
    chgrp -R ${tomcat_group} thredds*
    rm ${thredds_dist_file}
    
    if ((upgrade)) ; then 
        local version_property="Implementation-Version"
        local current_version=$(sed -n '/^'${version_property}':[ ]*\(.*\)/p' ${tomcat_install_dir}/webapps/thredds/META-INF/MANIFEST.MF | awk '{print $2}' | xargs 2> /dev/null)
        cp -v ${webapp_config_file}.saved ${webapp_config_file} && echo "Thredds upgraded to ${current_version} [OK]" && popd >& /dev/null && return 0
    fi
    popd >& /dev/null
    #-------------------------------------------


    ############################
    #Setup Digest authentication
    ############################

    pushd ${tomcat_conf_dir} >& /dev/null

    fetch_file=tomcat-users.xml
    checked_get $tomcat_conf_dir/${fetch_file} ${esg_dist_url}/externals/bootstrap/${fetch_file} $((force_install))
    (( $? > 1 )) && popd && checked_done 1
    chown ${tomcat_user}  $tomcat_conf_dir/${fetch_file}
    chgrp ${tomcat_group} $tomcat_conf_dir/${fetch_file}
    

    #1: Generate password hash
    printf "Create user credentials\n"
    local input

    while [ 1 ]; do 
        #default credential values...
        local username="dnode_user"
        local password=${security_admin_password:-"changeme"}
        unset input
        unset addanother
        read -p "Please enter username for tomcat [${username}]:  " input
        [ ! -z "${input}" ] && username=${input}    
        echo ${username}
        unset input
        read -s -t60 -p "Please enter password for user, \"${username}\" [********]:   " input
        [ ! -z "${input}" ] && password=${input}    
        password_hash=$($tomcat_install_dir/bin/digest.sh -a SHA ${password} | cut -d ":" -f 2)
        echo ${password_hash}
        
        #Create user entry in tomcat-users.xml for thredds user
        user_entry="<user username=\"${username}\" password=\"${password_hash}\" roles=\"tdrAdmin,tdsConfig\"\/>"
        #Note: Have to escape the last "/" in "/>"
        
        #Insert the entry in the right place in tomcat-users.xml
        #Replace <!--@@user_entry@@--> with ${user_entry}\n<!--@@user_entry@@-->
        #Command Line:% perl -p -i -e 's/<!--\@\@user_entry\@\@-->/<test>\n  <!--\@\@user_entry\@\@-->/g' tomcat-users.xml
        eval "perl -p -i -e 's/<!--\\@\\@user_entry\\@\\@-->/${user_entry}\n  <!--\\@\\@user_entry\\@\\@-->/g' tomcat-users.xml"
        
        read -p "Would you like to add another user? [y/N]: " addanother
        if [ "${addanother}" = "y" ] || [ "${addanother}" = "Y" ]; then
            echo 
            continue
        fi
        echo
        break
    done
    unset input

    popd >& /dev/null

    ############################
    #Enable SSL encryption
    ############################

    mkdir -p ${tomcat_conf_dir}/Catalina/localhost
    fetch_file=thredds.xml
    checked_get $tomcat_conf_dir/Catalina/localhost/${fetch_file} ${esg_dist_url}/externals/bootstrap/tomcat-${fetch_file} $((force_install))
    (( $? > 1 )) && echo " ERROR: Problem pulling down ${fetch_file} from esg distribution" && popd && checked_done 1

    
    #Get the templated web.xml file... (with tokens for subsequent filter entries: see [esg-]security-[token|tokenless]-filters[.xml] files)
    fetch_file=web.xml 
    checked_get ${tomcat_install_dir}/webapps/thredds/WEB-INF/${fetch_file} ${esg_dist_url}/thredds/thredds.${fetch_file} $((force_install))
    (( $? > 1 )) && popd && checked_done 1
    chown -R ${tomcat_user}  ${tomcat_install_dir}/webapps/thredds/WEB-INF/${fetch_file} 
    chgrp -R ${tomcat_group} ${tomcat_install_dir}/webapps/thredds/WEB-INF/${fetch_file} 

    #DEBUGGING
    ((DEBUG)) && cat ${tomcat_install_dir}/webapps/thredds/WEB-INF/${fetch_file}


    #(Making this assignment for the sake of readability for the code below)
    #@@node_host_ip_address@@ #Token in file
    node_host_ip_address=${my_ip_address}    

    #just to be sure it's clear (though it should be)
    unset input 
    read -p "Please Enter the IP address of this host [${node_host_ip_address}]:> " input
    [ ! -z "${input}" ] && node_host_ip_address=${input}
    printf "\nUsing IP: ${node_host_ip_address}\n"
    unset input

    #@@gateway_name@@ -> @@gateway_service_root@@  #Tokens in file
    #ESG-PCMDI -> pcmdi3.llnl.gov/esgcet
    #ESC-NCAR  -> esg.prototype.ucar.edu
    
    local choice
    while [ 1 ]; do
        unset choice
        printf "Please select the gateway for this node: \n"
        printf "\t-------------------------------------------\n"
        printf "\t*[1] : ESG-PCMDI -> pcmdi3.llnl.gov/esgcet\n"
        printf "\t [2] : ESG-NCAR  -> esg.ucar.edu\n"
        printf "\t-------------------------------------------\n"
        printf "\t [C] : (Manual Entry)\n"
        printf "\t-------------------------------------------\n"
        read -p "select [1] > " choice
        
        [ -z "${choice}" ] && choice=1 #default
        case ${choice} in
            2)  gateway_name="ESG-NCAR"
                gateway_service_root="esg.ucar.edu"
                ;;
            1)  gateway_name="ESG-PCMDI"
                gateway_service_root="pcmdi3.llnl.gov/esgcet"
                myproxy_port=2119 #hack till we open the right port
                ;;
            c | C)
                local input
                gateway_name=${ESG_GATEWAY_NAME:-"ESG-PCMDI"}
                gateway_service_root=${ESG_GATEWAY_SVC_ROOT:-"pcmdi3.llnl.gov/esgcet"}
                read -p "Please enter the Gateway name [${ESG_GATEWAY_NAME}] " input
                [ -n "${input}" ] && gateway_name=$(echo ${input} | tr 'a-z' 'A-Z')
                unset input
                read -p "Please enter the Gateway Service Root [${ESG_GATEWAY_SVC_ROOT}] " input
                [ -n "${input}" ] && gateway_service_root=$(echo ${input} | tr 'A-Z' 'a-z' | sed -n 's{\(.*://\)*\(.*\){\2{p')
                unset input
                choice="(Manual Entry)"
                ;;
            *)  echo "Invalid selection [${choice}]"
        esac
        echo
        echo "You have selected: ${choice}"
        echo "${gateway_name} -> ${gateway_service_root}"
        echo 
        local is_correct
        read -p "Is this correct? [Y/n] " is_correct
        is_correct=$(echo ${is_correct} | tr 'A-Z' 'a-z')
        if [ "${is_correct}" = "n" ]; then
            continue
        else
            break
        fi
    done
    
    myproxy_endpoint=$(echo ${gateway_service_root} | sed -n 's{\(.*://\)*\([^/]*\)/.*{\2{p')

    echo
    echo "Selection: [${choice}] source: ${node_host_ip_address}   dest: ${gateway_name}:${gateway_service_root}"

    #----------------------
    #Fetch and Insert the Certificate for parent gateway
    register ${myproxy_endpoint}
    [ $? != 0 ] && echo " Error: could not import gateway certificate!" && checked_done 1
    #----------------------

    #See thredds_content_dir set in init() - default value is ${esg_root_dir}/content

    #--------
    #hack - prerequiset for esgsetup... should be done in esgsetup code :-\
    mkdir -p ${thredds_content_dir}
    chown -R ${tomcat_user}:${tomcat_group} ${thredds_content_dir}
    chmod -R 755 ${thredds_content_dir}
    #--------

    #--------
    #EDIT the thredds property file: ${tomcat_install_dir}/webapps/thredds/WEB-INF/classes/thredds/server/tds.properties
    #replace the value for token "tds..content.root.path" with ${thredds_content_dir}
    local thredds_property_file=${tomcat_install_dir}/webapps/thredds/WEB-INF/classes/thredds/server/tds.properties
    if [ -e ${thredds_property_file} ]; then
        echo "$(sed -e 's#tds.content.root.path=.*#tds.content.root.path='${thredds_content_dir}'#' ${thredds_property_file} )" > ${thredds_property_file}
        chown -R ${tomcat_user}:${tomcat_group} ${thredds_property_file}
        chmod 644 ${thredds_property_file}
        echo "configured thredds content root -> $(egrep -e 'tds.content.root.path=.*' ${thredds_property_file})"
    else
        echo "WARNING: Could not file thredds' property file: ${thredds_property_file}"
    fi
    
    echo "Please set the thredds content directory to: ${thredds_content_dir} in the following setup"
    #--------

    #restart tomcat to put modifications in effect.
    stop_tomcat 
    start_tomcat
    start_postgress

    #set in cdms setup (prerequisite)
    echo "$cdat_home/bin/esgsetup --thredds --publish --gateway ${myproxy_endpoint}"
    $cdat_home/bin/esgsetup --thredds --publish --gateway ${myproxy_endpoint}

    chown -R ${tomcat_user}:${tomcat_group} ${thredds_content_dir}

    popd >& /dev/null
    echo
    mkdir -p ${thredds_root_dir}
    [ $? != 0 ] && echo " Error: could not create ${thredds_root_dir}" && checked_done 1
    mkdir -p ${thredds_replica_dir}
    [ $? != 0 ] && echo " Error: could not create ${thredds_replica_dir}" && checked_done 1
    echo

    #Set ownership of esgcet "thredds content" directory to installation owner
    mkdir -p ${thredds_content_dir}/thredds/esgcet
    echo "chown -R ${installer_uid}:${installer_gid} ${thredds_content_dir}/thredds/esgcet"
    chown -R ${installer_uid}:${installer_gid} ${thredds_content_dir}/thredds/esgcet 
    [ $? != 0 ] && echo "WARNING: Could not change owner successfully - this will lead to unability to create new catalogs via the publisher!"

    echo "curl http://${node_host_ip_address}/thredds"
    local wait_time=5
    local ret=1
    while [[ $wait_time > 0 ]]; do
        curl http://${node_host_ip_address}/thredds >& /dev/null
        ret=$?
        [ $ret == 0 ] && break
        sleep 1
        : $((wait_time--))
    done

    [ $? != 0 ] && echo "[FAILED]" && echo " ERROR: Not able to contact thredds page on this server" && checked_done 1
    echo "[OK]"
    write_tds_env
    write_tds_install_log
    checked_done 0
}

write_tds_env() {
    ((show_summary_latch++))
    echo "export ESG_GATEWAY_NAME=${gateway_name}" >> ${envfile}
    echo "export ESG_GATEWAY_SVC_ROOT=${gateway_service_root}" >> ${envfile}
    echo "export myproxy_port=${myproxy_port}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_tds_install_log() {
    echo "$(date ${date_format}) webapp:thredds=${tds_version} ${tomcat_install_dir}/webapps/${thredds_dist_file%.*}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

test_tds() {
    echo
    echo "----------------------------"
    echo "Thredds Data Server Test... (publisher catalog gen)"
    echo "----------------------------"
    echo
    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null

    start_tomcat
    start_postgress

    echo "$cdat_home/bin/esgpublish --use-existing pcmdi.${esg_root_id}.test.mytest --noscan --thredds"
    $cdat_home/bin/esgpublish --use-existing pcmdi.${esg_root_id}.test.mytest --noscan --thredds
    [ $? != 0 ] && echo "[FAILED]" && echo " ERROR: Not able to run esgpublish command" && popd && checked_done 1
    sleep 2
    echo "curl http://${node_host_ip_address}/thredds"
    curl http://${node_host_ip_address}/thredds
    [ $? != 0 ] && echo "[FAILED]" && echo " ERROR: Not able to contact thredds page on this server" && popd && checked_done 1
    
    echo "[OK]"
    popd >& /dev/null
    echo
    echo
    checked_done 0
}


#####
# Globus Toolkit ->  MyProxy (client) & GridFTP (server)
#####
# Takes arg <selection bit vector> 
# The rest of the args are the following...
# for data-node configuration (GridFTP stuff): ["with-bdm-config"|"bdm-config-only"] see esg-globus script
# for idp configuration (MyProxy stuff): [gen-self-cert] <dir> | [regen-simpleca] [fetch-certs|gen-self-cert] | ["install"|"update"])
my_setup_globus() {
    local sel=${1:-${sel:-0}}
    echo "my_setup_globus for sel type ${sel}"
    ((sel == 0)) && echo "my_setup_globus: no selection set, returning (1)" && return 1
    shift
    
    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null
    
    pushd ${scripts_dir} >& /dev/null
    local fetch_file=esg-globus
    checked_get ./${fetch_file} ${esg_dist_url}/externals/bootstrap/${fetch_file} $((force_install))
    (( $? > 1 )) && popd && return 1
    chmod 755 ${fetch_file}
    popd >& /dev/null
    
    local directive="notype"
    local ret=1
    
    if [ $((sel & DATA_BIT))  != 0 ]; then
        echo -n "Globus Setup for Data-Node... (GridFTP server) "
        directive="datanode"
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/${fetch_file} && setup_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
        [ ${ret} = 0 ] && write_globus_env || checked_done 1
        touch ${globus_location}/esg_${progname}_installed
    fi

    ret=1

    if [ $((sel & IDP_BIT)) != 0 ]; then
        echo -n "Globus Setup for Index-Node... (MyProxy server) "
        directive="gateway"
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/${fetch_file} && setup_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
        [ ${ret} = 0 ] && write_globus_env || checked_done 1
        touch ${globus_location}/esg_${progname}_installed
    fi
    return 0
}

write_globus_env() {
    ((show_summary_latch++))
    echo "export GLOBUS_LOCATION=$GLOBUS_LOCATION" >> ${envfile}
    echo "export X509_CERT_DIR=$X509_CERT_DIR" >>  ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

test_globus() {
    local sel=${1:-${sel:-0}}
    ((sel ==0)) && echo "test_globus: no selection set, returning (1)" && return 1
    shift

    local ret=1

    local directive="notype"
    if [ $((sel & DATA_BIT))  != 0 ]; then
        echo "Testing Globus Services for Data-Node... (GridFTP server(s)) : [$@]"
        directive="datanode"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && test_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
    fi

    ret=1

    if [ $((sel & IDP_BIT)) != 0 ]; then
        echo "Testing Globus Services for Index-Node... (MyProxy server)"
        directive="gateway"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && test_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
    fi
    return 0
}

# Starts the globus services by delegating out to esg-globus script
# arg1 selection bit vector ($sel)
# args* (in the context of "data" node ->  ["with-bdm-config"|"bdm-config-only"])
start_globus() {
    local sel=${1:-${sel:-0}}
    ((sel == 0)) && echo "start_globus: no selection set, returning (1)" && return 1
    shift

    local data_node_ret=1
    local directive="notype"
    if [ $((sel & DATA_BIT))  != 0 ]; then
        echo "Starting Globus Services for Data-Node... (GridFTP server(s)) : [$@]"
        directive="datanode"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && start_globus_services "${directive}" $@
        data_node_ret=$?
        [ ${data_node_ret} != 0 ] && echo "Could Not Start Globus ESGF Node related services (GridFTP)"
        popd >& /dev/null
    fi


    local idp_node_ret=1
    if [ $((sel & IDP_BIT)) != 0 ]; then
        echo "Starting Globus Services for Index-Node... (MyProxy server)"
        directive="gateway"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && start_globus_services "${directive}" $@
        idp_node_ret=$?
        [ ${idp_node_ret} != 0 ] && echo "Could Not Start Globus IDP Node related services (MyProxy)"
        popd >& /dev/null
    fi

}

# Stops the globus services by delegating out to esg-globus script
# arg1 selection bit vector ($sel)
stop_globus() {
   local sel=${1:-0}
    ((sel ==0)) && echo "stop_globus: no selection set, returning (1)" && return 1
    shift

    local ret=1

    local directive="notype"
    if [ $((sel & DATA_BIT))  != 0 ]; then
        echo -n "Stopping Globus Services for Data-Node... (GridFTP) "
        directive="datanode"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && stop_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
    fi

    if [ $((sel & IDP_BIT)) != 0 ]; then
        echo -n "Stopping Globus Services for Index-Node... (MyProxy server) "
        directive="gateway"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && stop_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
    fi

}

#####
# Test Publication
#####

test_publication() {
    echo
    echo "----------------------------"
    echo "Publication test... $@"
    echo "----------------------------"
    echo
    [ -z "${myproxy_user}" ] && read -p "Enter your myproxy username: " myproxy_user

    local personal_credential_repo="$HOME/.globus"

    mkdir -p ${personal_credential_repo}
    chown -R ${installer_uid}:${installer_gid} ${personal_credential_repo}

    [ "$(ls -A ${X509_CERT_DIR})" ] && echo "Detected existing content in \$X509_CERT_DIR" || rmdir ${X509_CERT_DIR}
    
    echo "X509_CERT_DIR = ${X509_CERT_DIR}"
    echo "$globus_location/bin/myproxy-logon -s $myproxy_endpoint -l $myproxy_user -p $myproxy_port -o ${personal_credential_repo}/certificate-file -T"
    $globus_location/bin/myproxy-logon -s $myproxy_endpoint -l $myproxy_user -p $myproxy_port -o ${personal_credential_repo}/certificate-file -T
    [ $? != 0 ] && echo " ERROR: MyProxy not setup properly.  Unable to execute command." && return 1

    chown -R ${installer_uid}:${installer_gid} ${personal_credential_repo}

    #Publish the dataset from the THREDDS catalog created above...
    echo "$cdat_home/bin/esgpublish --use-existing pcmdi.${esg_root_id}.test.mytest --noscan --publish"
    $cdat_home/bin/esgpublish --use-existing pcmdi.${esg_root_id}.test.mytest --noscan --publish
    [ $? != 0 ] && echo " ERROR: unable to successfully execute esgpublish" && return 1
    sleep 3

    [ "$1" = "no-unpublish" ] && echo "Leaving test publication file published" && return 1
    echo "$cdat_home/bin/esgunpublish --skip-thredds pcmdi.${esg_root_id}.test.mytest"
    $cdat_home/bin/esgunpublish --skip-thredds pcmdi.${esg_root_id}.test.mytest
    [ $? != 0 ] && echo " ERROR: unable to successfully execute esgunpublish" && return 1

    return 0
}

#NOTE: Here we are enforcing a bit of a convention... The name of
#subsystem files must be in the form of esg-xxx-xxx where the script
#contains its "main" function named setup_xxx_xxx(). The string passed
#to this function is "xxx-xxx"
#
#arg (1) - name of installation script root name. Ex:security which resolves to script file esg-security
#arg (2) - directory on the distribution site where script is fetched from Ex: orp
#usage: setup_subsystem security orp - looks for the script esg-security in the distriubtion dir orp
setup_subsystem() {
    local subsystem=$1
    [ -z "${subsystem}" ] && echo "setup_subsystem [${subsystem}] requires argument!!" && checked_done 1
    local server_dir=${2:?"Must provide the name of the distribution directory where subsystem script lives - perhaps ${subsystem}?"}
    local subsystem_install_script=${scripts_dir}/esg-${subsystem}
    
    #---
    #check that you have at one point in time fetched the subsystem's installation script
    #if indeed you have we will assume you would like to proceed with setting up the latest...
    #Otherwise we just ask you first before you pull down new code to your machine...
    #---
    #local default="Y"
    #((force_install)) && default="Y"
    #local dosetup
    #if [ ! -e ${subsystem_install_script} ] || ((force_install)) ; then
    #    echo
    #    read -p "Would you like to set up ${subsystem} services? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]")  " dosetup
    #    [ -z "${dosetup}" ] && dosetup=${default}
    #    if [ "${dosetup}" = "N" ] || [ "${dosetup}" = "n" ] || [ "${dosetup}" = "no" ]; then
    #        return 0
    #    fi
    #fi

    echo
    echo "-------------------------------"
    echo "LOADING installer for ${subsystem}... "
    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null

    pushd ${scripts_dir} >& /dev/null
    local fetch_file=esg-${subsystem}
    checked_get ./${fetch_file} ${esg_dist_url}/${server_dir}/${fetch_file} $((force_install))
    local ret=$?
    (( $ret > 1 )) && popd && return 1
    chmod 755 ${fetch_file}
    popd >& /dev/null

    #source subsystem file and go!
    shift && debug_print "-->>> "
    [ -n "${server_dir}" ] && shift && debug_print "-->>> "
    source ${scripts_dir}/${fetch_file} && verbose_print ":-) " && setup_${subsystem//'-'/_} $@
    checked_done $?
    echo "-------------------------------"
    echo 
    echo
}

#####
# Show user summary and environment variables that have been set
#####
show_summary() {
    if [ $((show_summary_latch == 0)) = 1 ]; then return 0; fi
    echo 
    echo "-------------------"
    echo "  esgf node run summary: "
    echo "-------------------"
    echo "The following environment variables were used during last full install"
    echo "They are written to the file ${envfile}"
    echo "Please source this file when using these tools"
    echo 
    cat ${envfile}
    echo "-------------------"
    echo "Installation Log:"
    echo 
    cat ${install_logfile}
    echo "-------------------"
    echo 
    return 0
}

write_env() {
    echo "Generating default ${envfile} file"
    [ -e ${envfile} ] && cp ${envfile} ${envfile}.bak
    cat /dev/null > ${envfile}
    write_paths
    write_git_env
    write_java_env
    write_ant_env
    write_postgress_env
    write_esgcet_env
    write_tomcat_env
    write_tds_env
    write_globus_env
    echo "-------------------"
    cat ${envfile}
    echo "-------------------"
    return 0
}


############################################
# Certificate Management Utility Functions
############################################

#Goes to ESG distribution server and pulls down all certificates for the federation.
#(suitable for crontabbing)
fetch_esg_certificates() {
    echo 
    echo "Fetching Freshest ESG Federation Certificates..."
    #globus_global_certs_dir=/etc/grid-security/certificates
    [ -d ${globus_global_certs_dir} ] && tar czf ${globus_global_certs_dir%/*}/${globus_global_certs_dir##*/}.bak.tgz ${globus_global_certs_dir} >& /dev/null && rm ${globus_global_certs_dir}/*
    mkdir -p ${globus_global_certs_dir}
    local esg_trusted_certs_file=esg_trusted_certificates.tar
    debug_print "curl -s -L --insecure ${esg_dist_url}/certs/${esg_trusted_certs_file} | (cd ${globus_global_certs_dir}; pax -r -s ',.*/,,p')"
    curl -s -L --insecure ${esg_dist_url}/certs/${esg_trusted_certs_file} | (cd ${globus_global_certs_dir}; pax -r -s ',.*/,,p')
    local ret=$?
    rmdir ${globus_global_certs_dir}/$(echo ${esg_trusted_certs_file} | awk 'gsub(/('$compress_extensions')/,"")')
    if [ $ret == 0 ]; then
        [ -e ${globus_global_certs_dir%/*}/${globus_global_certs_dir##*/}.bak.tgz ] && rm ${globus_global_certs_dir%/*}/${globus_global_certs_dir##*/}.bak.tgz
    fi
    chmod 755 ${globus_global_certs_dir}
    chmod 644 ${globus_global_certs_dir}/*
}

#Converts ESG certificates (that can be fetch by above function) into a truststore
#(adapted from original rendition by Philip Kershaw)
rebuild_truststore() {
    echo
    echo "Rebuilding truststore from esg certificates..."
    if [ ! -d ${globus_global_certs_dir} ] || (( force_install )) ; then
        [ ! -d ${globus_global_certs_dir} ] && echo "Sorry, No esg certificates found... in ${globus_global_certs_dir}" || echo "(forcing fresh rebuild)"
        echo "So fetching fresh esg certificates :-)"
        fetch_esg_certificates
    fi

    #If you don't already have a truststore to build on....
    #Start building from a solid foundation i.e. Java's set of ca certs...
    [ ! -e ${truststore_file} ] && cp -v ${java_install_dir}/jre/lib/security/cacerts ${truststore_file}

    local tmp_dir=/tmp/esg_scratch
    mkdir -p ${tmp_dir}

    local simpleCA_cert=$(readlink -f $(grep certificate_issuer_cert /etc/myproxy-server.config 2> /dev/null | awk '{print $2}') 2> /dev/null)
    [ -n "${simpleCA_cert}" ] && echo "Integrating in local simpleCA_cert" && cp -v ${simpleCA_cert} ${globus_global_certs_dir}/simpleCA_${simpleCA_cert##*/}.0 && echo "[OK]"

    local cert_files=$(find ${globus_global_certs_dir} | egrep '^.*.0$')
    for cert_file in $cert_files; do
        echo -n "$cert_file -> "
        local cert_hash=$(echo ${cert_file##*/} | awk -F'.' '{print $1}') ;
        local der_file="${tmp_dir}/${cert_hash}.der" ;

        #--------------
        # Convert from PEM format to DER format - for ingest into keystore
        openssl x509 -inform pem -in ${cert_file} -outform der -out ${der_file}
        #--------------

        if [ -f ${truststore_file} ]; then
            keytool -delete -alias ${cert_hash} -keystore ${truststore_file} \
                -storepass changeit 2>&1 > /dev/null ;
            [ $? == 0 ] && echo -n "- " || echo -n "  "
        fi

        [ $? == 0 ] && echo -n "+ " || echo -n "  "
        keytool -import -alias ${cert_hash} -file ${der_file} -keystore ${truststore_file} \
            -storepass changeit -noprompt ;
        [ $? != 0 ] && echo " [FAILED]"

        rm -f ${der_file} ;
    done
    rmdir ${tmp_dir}

    chown ${tomcat_user}:${tomcat_group} ${truststore_file}
    echo "...done"
    return 0
}

#This takes our certificate from the keystore and adds it to the
#truststore.  This is done for other services that use originating
#from this server talking to another service on this same host.  This
#is the interaction scenario with part of the ORP security mechanism.
#The param here is the password of the *keystore*
add_my_cert_to_truststore() {
    echo 
    debug_print "add_my_cert_to_truststore... "
    local store_password=${1}

    if [ -z "${store_password}" ]; then
        local verify_password
        while [ 1 ]; do
            echo
            read -s -p "Please enter the password for this keystore   : " store_password
            [ "${store_password}" = "changeit" ] && break
            [ -z "${store_password}" ] && echo "Invalid password [${store_password}]" && continue
            echo
            read -s -p "Please re-enter the password for this keystore: " verify_password
            if [ "${store_password}" = "${verify_password}" ] ; then
                echo
                break
            else
                echo "Sorry, values did not match"
                echo
            fi
        done
        unset verify_password
        echo
    else 
        echo "store_password = ******"
    fi

    #only making this call to test password
    keytool -v -list -keystore ${keystore_file} -storepass ${store_password} >& /dev/null
    [ $? != 0 ] && echo "Could not access private keystore ${keystore_file}" && return 1;

    #----------------------------------------------------------------
    #Re-integrate my public key (I mean, my "certificate") from my keystore into the truststore (the place housing all public keys I allow to talk to me)
    #----------------------------------------------------------------
    if [ -e ${truststore_file} ]; then
        echo "Re-Integrating keystore's certificate into truststore.... "
        echo "Extracting keystore's certificate... "
        keytool -export -alias ${keystore_alias} -file ${keystore_file}.cer -keystore ${keystore_file} -storepass ${store_password}
        [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && exit 1)

        echo "keytool -v -list -keystore ${truststore_file} -storepass changeit | egrep -i '^Alias[ ]+name:[ ]+my_esgf_node$'"
        keytool -v -list -keystore ${truststore_file} -storepass changeit | egrep -i '^Alias[ ]+name:[ ]+my_esgf_node$' #TODO howdo I put the var ${keystore_alias} here!!!
        if [ $? == 0 ]; then
            echo "Detected Alias \"${keystore_alias}\" Present... Removing... Making space for certificate... "
            keytool -delete -alias ${keystore_alias} -keystore ${truststore_file}  -storepass changeit 2>&1 > /dev/null #for ORP
            [ $? != 0 ] && echo " ERROR: problem deleting ${keystore_alias} key from keystore!" && return 1
        fi

        echo "Importing keystore's certificate into truststore... "
        keytool -import -v -trustcacerts -alias ${keystore_alias} -keypass ${store_password} -file ${keystore_file}.cer -keystore ${truststore_file} -storepass changeit -noprompt
        [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && exit 1)
        sync_with_java_truststore ${truststore_file}
        echo -n "cleaning up after ourselves... "
        rm -v ${keystore_file}.cer
        [ $? == 0 ] && echo "[OK]" || echo "[FAILED]"
    fi
    chown ${tomcat_user}:${tomcat_group} ${truststore_file}
    #----------------------------------------------------------------
    return 0
}

#---
#Original command instructions can be found here:
#http://www.sial.org/howto/openssl/csr/ 
#arg 1 -> what we want to name the private key
#arg 2 -> what we want to name the public cert
#arg 3 -> what we want the DN to be for public cert
generate_ssl_key_and_csr() {
    echo "Generating private host key... "
    local private_key=${1:-${tomcat_conf_dir}/hostkey.pem}
    openssl genrsa -out ${private_key} 1024
    [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && return 1)
    chmod 400 ${private_key}

    #NOTE: To include DN at the command line
    #openssl req -new -nodes -subj '/O=Grid/OU=GlobusTest/OU=simpleCA-pcmdi3.llnl.gov/CN=esg-test1.llnl.gov' -key hostkey.pem -out esg-test1.llnl.gov-esg-node.csr
    echo "Generating Certificate Signing Request (csr)... "
    local public_cert_req=${2:-${tomcat_conf_dir}/$(hostname --fqdn)-esg-node.csr}
    local public_cert_dn=${3:-$(extract_keystore_dn ${keystore_file})}

    echo "Using DN = [${public_cert_dn}]"

    #At this point public_cert_dn is empty if extract_keystore_dn was unable to perform successfully
    #So then we run the regular request generation that will ask you a series of questions to build the DN
    if [ -z "${public_cert_dn}" ]; then
        echo "openssl req -new -nodes -key ${private_key} -out ${public_cert_req}"
        openssl req -new -nodes -key ${private_key} -out ${public_cert_req}
        [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && return 2)
    else
        #Or, there was indeed an extraction of the DN from the keytool or I manually provided the DN
        #So then generate the request with the DN...
        echo "openssl req -new -nodes -subj ${public_cert_dn} -key ${private_key} -out ${public_cert_req}"
        openssl req -new -nodes -subj "${public_cert_dn}" -key ${private_key} -out ${public_cert_req}
        [ $? == 0 ] && echo "[OK]*" || (echo "[FAILED]*" && return 2)
    fi
    chmod 644 ${public_cert_req} >& /dev/null
    echo
    echo "--------------------------------------------------------"
    echo "In Directory: $(pwd)"
    echo "Generated private key: $(ls ${private_key})"
    echo "Generated certificate: $(ls ${public_cert_req})"
    echo "Please submit the certificate request to your Certificate Authority:"
    echo "Then run %> esg-node --install-keypair <private key> <signed cert> (use --help for details)"
    echo "--------------------------------------------------------"
    echo
    #echo "Generating temporary self-signed certificate... "
    #openssl x509 -req -days 30 -in ${public_cert_req} -signkey ${private_key} -out ${public_cert_req%.*}.pem
    #[ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && return 3)
    #openssl x509 -noout -text -in ${public_cert_req%.*}.pem

}

#------
#HELPER / UTILITY FUNCTION (aka private)
#------
#arg 1 -> the location of the java keystore file
#arg 2 -> the password to the java keystore file
extract_keystore_dn() {
    #TODO: check to see if there is a java keystore present... If so
    #read the store and pull out the "Owner:" DN and use it as the DN
    #for this new cert being generated. (perhaps ask the user if they
    #want to use the 'discovered' DN)
    local dn=""
    local keystore_file=${1:-${keystore_file}}
    if [ -e ${keystore_file} ]; then 
        local storepass=${2}
        local storepass_switch=""
        #If no password is provided then we want to at least make sure the command line is clean such that keytool will ask you for a password
        #this is a bit of defensive coding so we don't run into the problem of not having the password and running a broken arg sequence
        [ -n "${storepass}" ] && storepass_switch="-storepass ${storepass}"
        #Note: I apologize for this horribile hacking of regex (this should be more cleanly accomplished with sed or perl using a capture group or a simple look behind)
        dn=$(keytool -list -v -keystore ${keystore_file} ${storepass_switch} | egrep -e '^Owner:[ ]*?*' | tr -s " " | sed -e 's#^Owner: ##' | sed -e s#", "#" "#g | tac -s " " | xargs | sed -e 's# #/#g')
    fi
    echo "/${dn}"
}

#(Once you have submitted the CSR and have gotten it back *signed*; now install the keypair)
#arg 1 -> private key
#arg 2 -> public cert (the returned signed CSR)
#arg 3 -> keystore name
#arg 4 -> alias
#arg 5 -> password (The value you want *set* for the keystore and internal private key)
install_keypair() {
    local private_key=${1:-${tomcat_conf_dir}/"hostkey.pem"}
    local public_cert=${2:-${tomcat_conf_dir}/"$(hostname --fqdn)-esg-node.pem"}
    local keystore_name=${3:-${keystore_file}}
    local keystore_alias=${4:-${keystore_alias}}
    local store_password=${5}

    echo "private key = ${private_key}"
    echo "public cert = ${public_cert}"
    echo "keystore name  = ${keystore_file}"
    echo "keystore alias = ${keystore_alias}"

    local ks_secret=$(cat ${ks_secret_file} 2> /dev/null)
    local default_passwd=${ks_secret:=changeit}

    if [ -z "${store_password}" ]; then
        local verify_password
        while [ 1 ]; do
            echo
            read -s -p "Please enter the password for this keystore   : " store_password
            [ "${store_password}" = "${default_passwd}" ] && break
            [ -z "${store_password}" ] && echo "Invalid password [${store_password}]" && continue
            echo
            read -s -p "Please re-enter the password for this keystore: " verify_password
            if [ "${store_password}" = "${verify_password}" ] ; then
                echo
                break
            else
                echo "Sorry, values did not match"
                echo
            fi
        done
        unset verify_password
        echo
    else 
        echo "store_password = ******"
    fi

    local certfiles=()
    local certfile_entry
    echo "Please enter your Certificate Athority's certificate chain file(s): "
    echo " [enter each cert file/url press return, press return with blank entry when done]"
    echo
    while [ 1 ]; do
        read -p "certfile> " certfile_entry
        [ -z ${certfile_entry} ] && break
        certfiles=("${certfiles[@]} ${certfile_entry}")
    done
    debug_print "make_fresh_keystore ${keystore_name} ${keystore_alias} ${store_password} ${private_key} -- ${public_cert} ${certfiles[@]}"
    make_fresh_keystore ${keystore_name} ${keystore_alias} ${store_password} ${private_key} -- ${public_cert} ${certfiles[@]}
    [ $? != 0 ] && echo "ERROR: Problem with key generation and/or keystore construction" && mv ${keystore_name}.bak ${keystore_name} && exit 5
    
    ##Transform the keypair into the DER format understood by Java's keystore
    ##And generate a new keystore from that pair.
    #[ -e "${keystore_name}" ] && mv ${keystore_name} ${keystore_name}.bak
    #convert_keys ${private_key} ${public_cert} && \
    #    create_keystore ${private_key%.*}.der ${public_cert%.*}.der ${keystore_name} ${keystore_alias} ${store_password} 
    #[ $? != 0 ] && echo "ERROR: Problem with key generation and/or keystore construction" && mv ${keystore_name}.bak ${keystore_name} && exit 5

    echo "${store_password}" > ${ks_secret_file}
    chmod 600 ${ks_secret_file}
    chown ${installer_uid}:${installer_gid} ${ks_secret_file}
    
    #(In order for ORP or any other local service to trust eachother put your own cert into the truststore)
    [ -e "${truststore_file}" ] && mv ${truststore_file} ${truststore_file}.bak
    rebuild_truststore && add_my_cert_to_truststore ${store_password}
    [ $? != 0 ] && echo "ERROR: Problem with truststore generation" && mv ${truststore_file}.bak ${truststore_file} && exit 6
    register
    
    #--------------------------------------------------
    #Copy the files to where they need to go for GLOBUS 
    #--------------------------------------------------
    local globus_grid_security_dir=${globus_global_certs_dir%/*}
    [ ! -d  ${globus_grid_security_dir} ] && echo "ERROR: Could not locate target globus key location:[${globus_grid_security_dir}]" && exit 6

    [ -e ${globus_grid_security_dir}/hostkey.pem ] && mv ${globus_grid_security_dir}/hostkey.pem ${globus_grid_security_dir}/hostkey.pem.old
    cp -v ${private_key} ${globus_grid_security_dir}/hostkey.pem && \
        chmod 600 ${globus_grid_security_dir}/hostkey.pem

    [ -e ${globus_grid_security_dir}/hostcert.pem ] && mv ${globus_grid_security_dir}/hostcert.pem ${globus_grid_security_dir}/hostcert.pem.old
    cp -v ${public_cert} ${globus_grid_security_dir}/hostcert.pem && \
        chmod 644 ${globus_grid_security_dir}/hostcert.pem && \
        openssl x509 -noout -text -in ${globus_grid_security_dir}/hostcert.pem

    echo "Please restart this node for keys to take effect: \"$0 restart\""
    echo
}

#The following helper function creates a new keystore for your tomcat installation
# arg 1 -> keystore name
# arg 2 -> keystore alias
# arg 3 -> keystore password
# arg 4 -> private key
# arg 5 -> public cert
# arg 6.. -> intermediate certificate(s)
make_fresh_keystore() {
    
    #-------------
    #Set default values such that env vars may be used
    #-------------
    local keystore_name
    local keystore_alias
    local store_password
    local private_key

    local provider="org.bouncycastle.jce.provider.BouncyCastleProvider"
    local install_dir=${esg_tools_dir}/idptools

    #-------------
    #Collect args...
    #-------------
    local certfiles=()
    local arg_length=$#
    for ((i=1; i <= ${arg_length} ; i++)) ; do 
	[ "$1" = "--" ] && shift && certfiles=($@) && break
	((i==1)) && keystore_name=$1 && shift
	((i==2)) && keystore_alias=$1 && shift
	((i==3)) && store_password=$1 && shift
	((i==4)) && private_key=$1 && shift
    done
    local size=${#certfiles[@]}
    debug_print "[certfiles = ${certfiles[@]}]"
    [ ! -e "${private_key}" ] && echo "file [${private_key}] does not exist" && return 1
    (( size == 0 )) && echo "no certificate files listed" && usage


    #-------------
    #Display values
    #-------------
    echo
    echo "Keystore name : ${keystore_name}"
    echo "Keystore alias: ${keystore_alias}"
    echo "Store password: ${store_password}"
    echo "Private key   : ${private_key}"
    echo "Certificates..."

    mkdir -p ${install_dir}
    [ $? != 0 ] && echo "exiting..." && return 1
    PATH=${PATH}:${install_dir}/bin

    local certbundle="${install_dir}/cert.bundle"
    local ca_chain_bundle="${install_dir}/ca_chain.bundle"
    
    local content
    local skip_check=0
    local count=1
    for ((i=0; i<size; i++)) ; do 
	if ((i == 0)) ; then
	    echo "  Signed Cert -------> ${certfiles[i]}"
            echo "${certfiles[i]}" | egrep '^http' 
            if [ $? == 0 ]; then
                curl -s -k ${certfiles[i]} > ${certbundle} && echo "[OK]"
                skip_check=1
            else
                cat ${certfiles[i]} > ${certbundle}
            fi
            cat /dev/null > ${ca_chain_bundle}
	elif ((i == (size-1) )) ; then
	    echo "  Root Cert   -------> ${certfiles[i]}"
            echo "${certfiles[i]}" | egrep '^http' 
            if [ $? == 0 ]; then
                content=$(curl -s -k ${certfiles[i]})
                [ $? != 0 ] && echo "Cannot connect to ${certfiles[i]}" && return 1

                echo "${content}" | grep "Not Found" >& /dev/null
                [ $? == 0 ] && echo "${content}" && return 1
                
                debug_print "** ${content}"

                echo "$content" >> ${certbundle} && \
                    echo "$content" >> ${ca_chain_bundle} && \
                    echo "[OK]"
                skip_check=1
            else
                cat ${certfiles[i]} >> ${certbundle}
                cat ${certfiles[i]} >> ${ca_chain_bundle}
            fi
	else
	    echo "  Intermediate [$((count++))] --> ${certfiles[i]}"
            echo "${certfiles[i]}" | egrep '^http' 
            if [ $? == 0 ]; then
                content=$(curl -s -k ${certfiles[i]})
                [ $? != 0 ] && echo "Cannot connect to ${certfiles[i]}" && return 1
                
                echo "${content}" | grep "Not Found" >& /dev/null
                [ $? == 0 ] && echo "${content}" && return 1
                
                debug_print "* ${content}"
                
                echo "$content" >> ${certbundle} && \
                    echo "$content" >> ${ca_chain_bundle} && \
                    echo "[OK]"
                skip_check=1
            else
                cat ${certfiles[i]} >> ${certbundle}
                cat ${certfiles[i]} >> ${ca_chain_bundle}
            fi
	fi
        ((skip_check==0)) && [ ! -e "${certfiles[i]}" ] && echo "file [${certfiles[i]}] does not exist" && return 1
        if ((skip_check==0)) ; then
            ((DEBUG)) && head ${certfiles[i]}
	    ((DEBUG)) && openssl x509 -text -noout -in ${certfiles[i]}
        fi
        skip_check=0
    done
    unset count
    unset content

    #-------------
    # Structural integrity checks...
    #-------------    
    echo
    echo -n "checking that key pair is congruent... "
    local pair_hash=($((openssl x509 -noout -modulus -in ${certfiles[0]} | openssl md5 ; openssl rsa -noout -modulus -in ${private_key} | openssl md5) | uniq))
    (( 1 == ${#pair_hash[@]} )) && printf "[OK] ${pair_hash}\n\n" || (printf "[FAIL]\n\n" && return 1)


    #-------------
    #Let's be a little interactive with users for a sanity check
    #-------------
    local answer="Y"
    read -p "Is the above information correct? [Y/n] " answer
    [ -n "${answer}" ] && [ "${answer}" != "Y" ]  && [ "${answer}" != "y" ]  && echo "exiting..." && return 1
    
    local derkey="${install_dir}/key.der"

    #-------------
    #Make empty keystore...
    #-------------
    echo -n "creating keystore... "
    #create a keystore with a self-signed cert
    local dname=${dname:-"CN=$(hostname --fqdn), OU=simpleCA-pcmdi3.llnl.gov, OU=GlobusTest, O=Grid"}
    [ -e "${keystore_name}" ] && mv ${keystore_name} ${keystore_name}.bak
    keytool -genkey -keyalg RSA -alias "${keystore_alias}" \
        -keystore "${keystore_name}" \
        -storepass "${store_password}" \
        -keypass "${store_password}" \
        -validity 360 \
        -dname "${dname}" \
        -noprompt
    [ $? != 0 ] && (echo "Problem with generating initial keystore... [FAIL]" && return 1) || echo "[OK] "

    echo -n "clearing keystore... "
    #delete the cert
    keytool -delete -alias "${keystore_alias}" -keystore "${keystore_name}" -storepass "${store_password}"
    [ $? != 0 ] && (echo "Problem with preparing initial keystore... [FAIL]" && return 1) || echo "[OK] "
    
    #-------------
    #Convert your private key into from PEM to DER format that java likes
    #-------------
    echo -n "converting private key... "
    debug_print -n "openssl pkcs8 -topk8 -nocrypt -inform PEM -in ${private_key} -outform DER -out ${derkey} "
    openssl pkcs8 -topk8 -nocrypt -inform PEM -in ${private_key} -outform DER -out ${derkey} 
    [ $? != 0 ] && (echo "Problem with preparing initial keystore... [FAIL]" && return 1) || echo "[OK] "

    #-------------
    #Now we gather up all the other keys in the key chain...
    #-------------
    echo -n "checking that chain is valid... "
    debug_print -n "openssl verify -CAfile ${ca_chain_bundle} ${ca_chain_bundle} "
    local chain_check=$(openssl verify -CAfile ${ca_chain_bundle} ${ca_chain_bundle} | grep -i error)
    if [ -z "${chain_check}" ]; then  printf "[OK]\n\n"; else  printf "[FAIL]\n ${chain_check}\n(hint: did you include the root cert for the chain :-)\n"; return 1 ; fi

    
    #-------------
    #Generating new keystore
    #-------------
    echo -n "Constructing new keystore content... "
    local command="extkeytool -importkey -keystore ${keystore_name} -alias ${keystore_alias} -storepass ${store_password} -keypass ${store_password} -keyfile ${derkey} -certfile ${certbundle} -provider ${provider}"
    debug_print && echo ${command}

    ${command} > /dev/null
    local ret=$?

    #FYI: Code 127 is "command not found"
    if [ ${ret} == 127 ]; then
        echo "Hmmm... Cannot find extkeytool... :-( Let me get it for you! :-)  [one moment please...]"
        curl -s -L --insecure ${extkeytool_download_url} |  (cd ${install_dir}; tar xvzf -)
        ${command}
        local ret=$?
    fi

    [ ${ret} != 0 ] && echo "Problem with running extkeytool :-(" && return 1
    [ ${ret} == 0 ] && echo "[OK]"
    
    echo
    echo "How do things look?"
    keytool -v -list -keystore "${keystore_name}" -storepass ${store_password}
    if [ $? == 0 ]; then
	echo 
	echo "If Everything looks good... then replace your current tomcat keystore with ${keystore_name} if necessary."
	echo "Don't forget to change your tomcat's server.xml entry accordingly :-)"
	echo "Remember: Keep your private key ${private_key} and signed cert ${certfiles[0]} in a safe place!!!"
	echo
        answer="Y"
        read -p "Is the above information correct? [Y/n] " answer
        [ -n "${answer}" ] && [ "${answer}" != "Y" ]  && [ "${answer}" != "y" ]  && echo "Eh... try again... ;-)" && return 1
    else
	echo 
	echo "Hmmm... something didn't quite go so right... double check things..."
        return 1
    fi
    return 0
}

#************
#(DEPRECATED)
#************
#------
#HELPER FUNCTION (aka private)
#------
#converts key pairs from PEM format to DER format
#(DER format is amenable to Java's keystore mechanism)
#Original command instructions can be found here:
#http://www.ci.uchicago.edu/wiki/bin/view/ESGProject/JarSigningNotes
#arg 1 -> private key
#arg 2 -> public cert
convert_keys() {
    echo -n "Converting private key from PEM -> DER format... "
    local private_key=${1:-"hostkey.pem"}
    [ ! -e ${private_key} ] && echo "Sorry, cannot find ${private_key}" && return 2
    openssl pkcs8 -topk8 -nocrypt -in ${private_key} -inform PEM -out ${private_key%.*}.der -outform DER
    [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && return 1)

    echo -n "Converting public cert from PEM -> DER format... "
    local public_cert=${2:-$(hostname --fqdn)-esg-node.pem}
    [ ! -e ${public_cert} ] && echo "Sorry, cannot find ${public_cert}" && return 2
    openssl x509 -in ${public_cert} -inform PEM -out ${public_cert%.*}.der -outform DER
    [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && return 1)

    echo
    pwd
    ls -l ${private_key%.*}.der ${public_cert%.*}.der
    echo
    return 0
}

#************
#(DEPRECATED)
#************
#------
#HELPER FUNCTION (aka private)
#------
#Creates a new keystore based on given keypair
#Original command instructions can be found here:
#http://www.agentbob.info/agentbob/79-AB.html
#arg 1 -> private key
#arg 2 -> public cert
#arg 3 -> keystore name*
#arg 4 -> alias*
#arg 5 -> password* (for keystore and private key)
#[*Have default values - non manditory]
create_keystore() {
    local private_key=${1:-"hostkey.der"}
    local public_cert=${2:-$(hostname --fqdn)-esg-node.der}
    local keystore_name=${3:-${keystore_file}}
    local key_alias=${4:-${keystore_alias}}
    local password=${5:-${keystore_password}}
    
    checked_get ./ImportKey.class ${utils_url}/ImportKey.class $((force_install))
    (( $? > 1 )) && echo "Could not fetch keystore generator" && return 1

    [ ! -e ${private_key} ] && echo "Sorry, cannot find ${private_key}" && return 2
    [ ! -e ${public_cert} ] && echo "Sorry, cannot find ${public_cert}" && return 2

    CLASSPATH=. java -Dkeystore=${keystore_name} ImportKey ${private_key} ${public_cert} ${key_alias} ${password}
    [ $? != 0 ] && echo "[FAILED] Could not execute keystore generator" && return 1
    echo
    keytool -list -v -keystore ${keystore_name} -storepass ${password}
    return 0
}

#---

#************
#(DEPRECATED)
#************
#Once the generated CSR has been submitted to a CA and signed... the returned
#signed certificate needs to be imported into the *existing* keystore. (and to trust store: for ORP)
#arg 1 -> signed certificate file returned to you by your CA
install_signed_certificate() {
    local signed_cert_file=${1:-${HOME}/$(hostname --fqdn)-esg-node.pem}

    echo
    echo "Installing Signed Host Certificate: ${signed_cert_file} "
    
    [ ! -e ${signed_cert_file} ] && echo "ERROR: Could not find signed cert file: ${signed_cert_file}" && return 1
    
    local store_password=${keystore_password}
    local verify_password
    while [ 1 ]; do
        echo
        read -s -p "Please enter the password for this keystore   : " store_password
        [ "${store_password}" = "changeit" ] && break
        [ -z "${store_password}" ] && echo "Invalid password [${store_password}]" && continue
        echo
        read -s -p "Please re-enter the password for this keystore: " verify_password
        if [ "${store_password}" = "${verify_password}" ] ; then
            echo
            break
        else
            echo "Sorry, values did not match"
            echo
        fi
    done
    unset verify_password
    echo

    
    if [ -z "$(echo ${signed_cert_file##*.} | egrep "($certificate_extensions)")" ]; then
        #--------------
        #convert from PEM format to a DER format  - for ingeest into the keystores :-)
        echo "converting certificate from PEM format to DER format..."
        echo "openssl x509 -in ${signed_cert_file} -inform PEM -out ${signed_cert_file%.*}.der -outform DER"
        openssl x509 -inform PEM -in ${signed_cert_file} -outform DER -out ${signed_cert_file%.*}.der 
        [ $? == 0 ] && signed_cert_file=${signed_cert_file%.*}.der
        #--------------
    else
        echo "Apparently (based on file extension) this file is already in DER format"
    fi

    [ -e ${keystore_file} ] && echo "(making backup copy of keystore)" && cp -v ${keystore_file} ${keystore_file}.bak

    #--------------
    keytool -v -list -keystore ${tomcat_conf_dir}/keystore-tomcat -storepass changeit | egrep -i '^Alias[ ]+name:[ ]+root$'
    if [ $? == 0 ]; then
        keytool -delete -alias root -keystore ${keystore_file} -storepass ${store_password}
        [ $? != 0 ] && echo " ERROR: problem deleting root key from keystore!" && return 1
    fi
    
    echo "keytool -import -trustcacerts -alias root -file ${signed_cert_file} -keystore ${keystore_file} -storepass *****"
    keytool -import -trustcacerts -alias root -file ${signed_cert_file} -keystore ${keystore_file} -storepass ${store_password}
    local ret=$?
    if [ $ret == 0 ]; then 
        echo "[OK]" 
    else
        echo "[FAILED]"
        echo "(Restoring original keystore)"
        cp -v ${keystore_file}.bak ${keystore_file}
        return $ret
    fi
    
    chown ${tomcat_user}:${tomcat_group} ${keystore_file}
    #--------------

    add_my_cert_to_truststore ${store_password}
    
    unset store_password
    
}

#************
#(DEPRECATED)
#************
#This should only be run AFTER your signed certificate has been already installed into the keystore!
export_keystore_as_globus_hostkeys() {
    mkdir -p ${workdir}
    pushd ${workdir} >& /dev/null
    checked_get ./ExportPriv.class ${utils_url}/ExportPriv.class $((force_install))
    (( $? > 1 )) && echo " ERROR: Could not download utility class(1) for exporting certificates" && popd && return 1
    checked_get ./Base64Coder.class ${utils_url}/Base64Coder.class $((force_install))
    (( $? > 1 )) && echo " ERROR: Could not download utility class(2) for exporting certificates" && popd && return 1
    popd >& /dev/null

    local CP=".:${workdir}"
    
    [ ! -e ${keystore_file} ] && echo "Cannot locate keystore \"${keystore_file}\"" && return 2
    
    local store_password=${keystore_password}
    local verify_password
    while [ 1 ]; do
        echo
        read -s -p "Please enter the password for this keystore   : " store_password
        [ "${store_password}" = "changeit" ] && break
        [ -z "${store_password}" ] && echo "Invalid password [${store_password}]" && continue
        echo
        read -s -p "Please re-enter the password for this keystore: " verify_password
        if [ "${store_password}" = "${verify_password}" ] ; then
            echo
            break
        else
            echo "Sorry, values did not match"
            echo
        fi
    done
    unset verify_password
    echo
    
    #--------------
    #NOTE: To extract the (private) key from the keystore we use a
    #Java program called ExportPriv.  The result is a PEM formatted
    #private key file that we can directly use.
    #see: http://www.conshell.net/wiki/index.php/Keytool_to_OpenSSL_Conversion_tips

    echo -n "Extracting keystore's key... (private) "
    [ -e ${globus_global_certs_dir%/*}/hostkey.pem ] && cp ${globus_global_certs_dir%/*}/hostkey.pem ${globus_global_certs_dir%/*}/hostkey.pem.last
    [ -e ${globus_global_certs_dir%/*} ] && mkdir -p ${globus_global_certs_dir%/*}
    ((DEBUG)) && \
        printf "\n${JAVA_HOME}/bin/java -classpath ${CP} ExportPriv ${keystore_file} ${keystore_alias} ************* > ${globus_global_certs_dir%/*}/hostkey.pem\n"
    ${JAVA_HOME}/bin/java -classpath ${CP} ExportPriv ${keystore_file} ${keystore_alias} ${store_password} > ${globus_global_certs_dir%/*}/hostkey.pem
    local ret=$?
    [ $ret == 0 ] && echo "[OK]" || echo "[FAILED]"
    chmod 600 ${globus_global_certs_dir%/*}/hostkey.pem
    #--------------

    
    #--------------
    #NOTE: To extract the (public) certificate we use the keytool.
    #Keytool extracts everything (except cert requests) in DER format
    #so, the exporting of this public certificate is no different - it
    #is in DER format, so we must convert.  Hence the openssl calls
    #subsequent to the export.  Also notice that the alias being used
    #is *"root"* this is a special alias that was used when importing
    #the signed certificate (once it was converted from PEM to DER for
    #import)
    
    echo -n "Extracting keystore's certificate... (public) "
    [ -e ${globus_global_certs_dir%/*}/hostcert.pem ] && cp ${globus_global_certs_dir%/*}/hostcert.pem ${globus_global_certs_dir%/*}/hostcert.pem.last
    ((DEBUG)) && \
        printf "\nkeytool -export -alias ${keystore_alias} -file ${globus_global_certs_dir%/*}/hostcert.der -keystore ${keystore_file} -storepass *************\n"
    keytool -export -alias root -file ${globus_global_certs_dir%/*}/hostcert.der -keystore ${keystore_file} -storepass ${store_password}
    ret=$?
    [ $ret == 0 ] && echo "[OK]" || echo "[FAILED]"

    echo -n "Converting DER cert ${globus_global_certs_dir%/*}/hostcert.der to PEM format "
    openssl x509 -in ${globus_global_certs_dir%/*}/hostcert.der -inform DER -out ${globus_global_certs_dir%/*}/hostcert.pem -outform PEM 
    ret=$?
    [ $ret == 0 ] && echo "[OK]" || echo "[FAILED]"
    
    openssl x509 -noout -text -in ${globus_global_certs_dir%/*}/hostcert.pem

    chmod 644 ${globus_global_certs_dir%/*}/hostcert.pem
    #--------------
    
    unset store_password

    #for safe keeping post the truststore and keystore in /etc/grid-security/saved
    if [ -d ${globus_global_certs_dir%/*} ]; then
        mkdir -p ${globus_global_certs_dir%/*}/saved
        chmod 700 ${globus_global_certs_dir%/*}/saved 
        rm ${globus_global_certs_dir%/*}/saved/* >& /dev/null
        cp ${truststore_file} ${globus_global_certs_dir%/*}/saved/${truststore_file##*/}.$(date ${date_format}).bak
        cp ${keystore_file} ${globus_global_certs_dir%/*}/saved/${keystore_file##*/}.$(date ${date_format}).bak
    fi

    echo "(cleanup)"
    rm -v ${globus_global_certs_dir%/*}/hostcert.der

}


#####
# This function is for pulling in keys from hosts we wish to
# communicate with over an encrypted ssl connection.  This function
# must be run after tomcat is set up since it references server.xml.
#####
#(called by setup_tds)
#arg1 - hostname of the machine with the cert you want to get
#(arg2 - password to truststore where cert will be inserted)
register() {
    echo "Installing Public Certificate of Target Gateway Node...( -> MyProxy endpoint: $1)"
    
    mkdir -p ${workdir} # >& /dev/null
    pushd ${workdir} # >& /dev/null
    #Download the Java code used for certificate installation (into $workdir)
    checked_get './InstallCert.class' ${utils_url}/InstallCert.class $((force_install))
    (( $? > 1 )) && echo " ERROR: Could not download utility class(1) for installing certificates" && popd && return 1
    checked_get './InstallCert$SavingTrustManager.class' ${utils_url}/'InstallCert$SavingTrustManager.class' $((force_install))
    (( $? > 1 )) && echo " ERROR: Could not download utility class(2) for installing certificates" && popd && return 1
    popd # >& /dev/null

    pushd ${tomcat_conf_dir} >& /dev/null
    
    local input=${1:-${ESG_GATEWAY_SVC_ROOT%%/*}}
    [ -z "${input}" ] && popd && echo "Could not register: No endpoint specified" && return 1

    local ssl_endpoint=${input%%/*} #just need the hostname
    local ssl_port=${ssl_port:-443}
    local ssl_endpoint_passwd=${2:-changeit}
    
    local CP=".:${workdir}"

    echo "${JAVA_HOME}/bin/java -classpath ${CP} InstallCert ${ssl_endpoint}:${ssl_port} ${ssl_endpoint_passwd} ${truststore_file}"
    ${JAVA_HOME}/bin/java -classpath ${CP} InstallCert ${ssl_endpoint}:${ssl_port} ${ssl_endpoint_passwd} ${truststore_file}
    local ret=$?

    #NOTE: The InstallCert code fetches Java's jssecacerts file (if
    #not there then uses the cacerts file) from java's jre and then adds the target's cert to it.
    #The output of the program is a new file named jssecacerts!  So here we get the output and rename it.
    
    chmod 644 ${truststore_file}
    chown ${tomcat_user}:${tomcat_group} ${truststore_file}
    
    sync_with_java_truststore ${truststore_file}

    popd >& /dev/null
    return $ret
}

#arg 1 - The truststore file to sync with Java's
sync_with_java_truststore() {
    if [ ! -e ${JAVA_HOME}/jre/lib/security/jssecacerts ] && [ -e ${JAVA_HOME}/jre/lib/security/cacerts ]; then
        cp ${JAVA_HOME}/jre/lib/security/cacerts ${JAVA_HOME}/jre/lib/security/jssecacerts
    fi
    local java_truststore=${JAVA_HOME}/jre/lib/security/jssecacerts
    local external_truststore=${1:-$(readlink -f ${truststore_file})}
    echo -n "Sync'ing ${external_truststore} with ${java_truststore} ... "
    [ ! -e "${external_truststore}" ] && echo "[FAIL]: Cannot locate ${external_truststore}" && return 1
    [ -e "${java_truststore}" ] && cp ${java_truststore} ${java_truststore}.bak
    cp ${external_truststore} ${java_truststore}
    chmod 644 ${java_truststore}
    chown -R ${installer_uid}:${installer_gid} ${java_truststore}*
    echo "[OK]"
}

############################################
# General - Utility Functions
############################################

#Needed to reduce the number of commands when wanting to make a verbose conditional print
verbose_print() { ((VERBOSE)) && echo $@; return 0; }
debug_print() { ((DEBUG)) && echo $@; return 0; }

#NOTE: This is another **RedHat/CentOS** specialty thing (sort of)
#arg1 - min value of shmmax in MB (see: /etc/sysctl.conf)
check_shmmax() {
    set_value_mb=${1:-40} #default is 32MB + headroom = 40MB
    let set_value_bytes=$((set_value_mb*1024*1024))
    cur_value_bytes=$(sysctl -q kernel.shmmax | tr -s "=" | cut -d= -f2)
    let cur_value_bytes=${cur_value_bytes## }
    
    if ((cur_value_bytes < set_value_bytes)); then
        echo "Current system shared mem value too low [$cur_value_bytes bytes] changing to [$set_value_bytes bytes]"
        sysctl -w kernel.shmmax=${set_value_bytes}
        echo "kernel.shmmax = ${set_value_bytes}" >> /etc/sysctl.conf
    fi
}

#This function is for repeatedly running a function until it returns
#true and/or the number of iterations have been reached.  The format of
#the args for this call are as follows:
#
# pcheck <num_of_iterations> <wait_time_in_seconds> <return_on_true> -- [function name] <args...>
# The default operation is the run the function once a scecond for 5 seconds or until it returns true
# The default value of iterations is 5
# The default value of wait time is  1 (second)
# The default value of return on true is 1 (no more iterations after function/command succeeds)
# the "--" is a literal argument that MUST precede the function or command you wish to call
#
# Ex:
# Run a function or command foo 3x waiting 2 seconds between and returning after function/command success
# pcheck 3 2 1 -- foo arg1 arg2
# Run a function or command foo using defaults
# pcheck -- foo arg1 arg2
#
# Returns the value from the final execution of the function or command.
pcheck() {
    debug_print "pcheck $@"
    #initial default values
    local iterations=5
    local wait_time=1
    local return_on_true=1
    local task_function=""

    local_vars=(iterations wait_time return_on_true)
    local i=0
    while [[ -n "$1" ]]; do
        if [ "$1" == "--" ] ; then
            shift
            task_function=$1
            shift
            break
        fi
        eval local ${local_vars[((i++))]}=$1
        shift
    done
    debug_print "iterations = ${iterations}"
    debug_print "wait_time = ${wait_time}"
    debug_print "return_on_true = ${return_on_true}"
    debug_print "task_function = ${task_function}"
    debug_print "args = [$@]"

    local ret=1
    while [[ $iterations > 0 ]]; do
        echo -n "."
        eval ${task_function} $@
        ret=$?
        ((return_on_true)) && [ $ret == 0 ] && break
        ((iterations != 1)) && sleep ${wait_time}
        : $((iterations--))
    done
    [ $ret == 0 ] && printf "\n${task_function} [OK]\n" || printf "\n${task_function} [FAIL]\n"
    return $ret
}

uninstall() {
    local doit="N"
    read -p "Are you sure you want to uninstall? [y/N]: " doit
    if [ "$doit" = "y" ] || [ "$doit" = "Y" ]; then

        doit="N"
        if [ -e $postgress_install_dir ]; then 
            read -p "remove postgress? ($postgress_install_dir) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing $postgress_install_dir"
                rm -rf ${postgress_install_dir}
                [ $? != 0 ] && echo "ERROR: Unable to remove ${postgress_install_dir}"
            fi
        fi
        
        doit="N"
        if [ -e $cdat_home ]; then
            read -p "remove cdat? ($cdat_home) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing $cdat_home"
                rm -rf ${cdat_home}
                [ $? != 0 ] && echo "ERROR: Unable to remove ${cdat_home}"
            fi
        fi

        doit="N"
        if [ -e ${HOME}/.esgcet ]; then
            read -p "remove .esgcet files? (${HOME}/.esgcet) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing ${HOME}/.esgcet"
                rm -rf ${HOME}/.esgcet
                [ $? != 0 ] && echo "ERROR: Unable to remove ${HOME}/.esgcet}"
            fi
        fi

        source ${scripts_dir}/esg-node-manager >& /dev/null && clean_node_manager_webapp_subsystem && clean_node_manager_database_subsystem_installation
        source ${scripts_dir}/esg-security >& /dev/null && clean_security_webapp_subsystem && clean_security_database_subsystem_installation
        source ${scripts_dir}/esg-idp >& /dev/null && clean_idp_webapp_subsystem
        source ${scripts_dir}/esg-orp >& /dev/null && clean_orp_webapp_subsystem

        doit="N"
        if [ -e ${tomcat_install_dir}/webapps/thredds ]; then
            read -p "remove Thredds web service? (${tomcat_install_dir}/webapps/thredds) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing ${tomcat_install_dir}/webapps/thredds"
                rm -rf ${tomcat_install_dir}/webapps/thredds
                [ $? != 0 ] && echo "ERROR: Unable to remove ${tomcat_install_dir}/webapps/thredds"
            fi
        fi 

        doit="N"
        if [ -e $tomcat_install_dir ]; then
            read -p "remove apache tomcat? ($tomcat_install_dir) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing $tomcat_install_dir"
                rm -ri $tomcat_install_dir
                [ $? != 0 ] && echo "ERROR: Unable to remove ${tomcat_install_dir}"
            fi
        fi
        
        doit="N"
        if [ -e ${globus_location}/esg_${progname}_installed ] && (( ! no_globus )); then
            read -p "remove globus certs? ($globus_location) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing $globus_location"
                [ -n ${globus_location} ] && [ -e ${globus_location} ] && rm -rf ${globus_location}
                [ $? != 0 ] && echo "ERROR: Unable to remove ${globus_location}"
            fi
        fi
    fi
    exit 0
}

set_classpath() {
    local CP="."
    CP=${CP}:${node_manager_app_home}/WEB-INF/classes
    
    for i in $( ls ${node_manager_app_home}/WEB-INF/lib ); do
        CP=${CP}:${node_manager_app_home}/WEB-INF/lib/"$i"
    done
    
    CP=${CP}:${CATALINA_HOME}/lib/servlet-api.jar
    CLASSPATH=${CP}
    export CLASSPATH
    return 0;
}

#-------------------------------
# Process checking utility functions
#-------------------------------

#This function "succeeds" (is true; returns 0)  if there *are* running processes found running
check_postgress_process() {
    local val=$(ps -elf | grep postgres | grep -v grep | awk ' END { print NR }')
    [ $(($val > 0 )) == 1 ] && echo "Postgres process is running..." && return 0
    return 1
}

#This function "succeeds" (is true; returns 0)  if there *are* running processes found running
check_tomcat_process() {
    if [ -f ${tomcat_install_dir}/conf/server.xml ]; then
        local ports=$(sed -n 's/.*Connector.*port="\([0-9]*\)".*/\1/p' ${tomcat_install_dir}/conf/server.xml | tr '\n' ',' | sed 's/,$//')
        local procs="$(lsof -Pni TCP:$ports | tail -n +2 | grep LISTEN | awk '{print $1}' | sort -u | xargs)"
        [ -z "${procs}" ] && return 1 #No process running on ports
        if (( $(expr "$procs" : '.*jsvc.*') > 0)); then
            echo "Tomcat (jsvc) process is running... " && return 0
        else
            echo " WARNING: There is another process running on expected Tomcat (jsvc) ports!!!! [${procs}] ?? "
            return 3
        fi
    else
        echo " Warning Cannot find ${tomcat_install_dir}/conf/server.xml file!"
        echo " Using alternative method for checking on tomcat process..."
        local val=$(ps -elf | grep jsvc | grep -v grep | awk ' END { print NR }')
        [ $(($val > 0 )) == 1 ] && echo "Tomcat (jsvc) process is running..." && return 0
        echo " No Tomcat (jsvc) processes detected"
        return 2
    fi
}

#-------------------------------
# Version Checking Utility Functions
#-------------------------------

#--------------------------------------------------------------------------
# Donated function from Estanislao (thanks!)
# To do a bit more robust version checking... See the "check_version" function 
#-----
compare_versions_() {
    debug_print "Comparing versions: $@"
    OLDIFS=$IFS
    IFS=".-_/@+#"
    debug_print $@
    count1=0
    for v1 in $1; do
        (($DEBUG2)) && echo v1=$v1
        count2=0
        for v2 in $3; do
            (($DEBUG2)) && echo "v2=$v2" && echo "[[ \$count2=$count2 == \$count1=$count1 ]]"
            if [[ $count2 == $count1 && $v1 != $v2 ]]; then
                #if same so keep going... so break inner for loop
                (($DEBUG2)) && echo "[[ \$v1=$v1 == \$v2=$v2 ]]"
                [[ $v1 == $v2 ]] && break

                #ok, no match here we resolve it: compare v1 and v2
                (($DEBUG2)) && echo "[[ $v1 $2 $v2 ]]"
                #don't forget to set it back!
                IFS=$OLDIFS
                
                eval "[[ $v1 $2 $v2 ]]"
                return $?
            fi
            : $((++count2)) 
        done
        #remove last count (which doesn't count :-)
        : $((--count2))
        : $((++count1))
    done
    #remove last count (which doesn't count :-)
    : $((--count1))
    
    #don't mess with this...
    IFS=$OLDIFS
    
    debug_print "compare last one again in case we have two equal versions"
    eval "[[ $v1 $2 $v2 ]]"
    ret=$?
    
    debug_print "equality was allowed, check passed"
    [[ $ret == 0 ]] && return 0
    
    
    #if here the strings were equal or $1 is longer than $2 (and therefore "greater")
    debug_print "[[ count1=$count1 > count2=$count2 ]]"
    if [[ $count1 = $count2 ]]; then
        debug_print "they were equal, but equality wasn't expected (ret 1)"
        return 1
    else
        debug_print "the longest is the gretest. Compare length.i"
        eval "[[ $count1 $2 $count2 ]]"
        return $?
    fi
}

#------
# "Private Utility/Helper method for the check_version[^_] function to follow.
# Does some arge scrubbing etc.
#------
# the first non numeric field breaks comparison and is treated as a special field
# which is equal to any other non numneric one.
# only numeric fields before non numeric ones are considered
# so 1.1.a == 1.1.b and 1.1_B203 == 1.1_B204 and 1.b.1 == 1.c.4 (!!)
# but and 1.2.a > 1.1.y and 1.1.a > 1.1 (!!)
check_version_helper() {
    debug_print "in check_version_helper $@"
    #only one parameter, probably a string, expand it
    [[ $# == 1 ]] && set -- $1
    debug_print "\$1=$1, \$2=$2, \$3=$3"
    
    #check we have what we need
    if [[  -z $1 || -z $2  || -z $3 ]]; then 
        [[ $verbose ]] && usage
        return 255 
    fi

    #transform operators in arithmetic ones (if not already)
    case $2 in
        '>') op="-gt" ;;
        '>=') op="-ge" ;;
        '<') op="-lt" ;;
        '<=') op="-le" ;;
        =|==) op="-eq" ;;
!=|'<>') op="-ne" ;;
*) op=$2
esac

    #we only need three params for this function
compare_versions_ "${1}" "$op" "${3}"
local ret=$?
debug_print "compare_versions from check_version_ returns $ret"
return $ret
}

#The "Public" function that should be called.  Delegates to the helper functions (the two above)
#Makes the calls to fetch the version information about the passed in executable
# Returns 0 if everything is up to date (version-wise)
# Returns 1 if the current version is older than the required version
# Returns 2 if could not find executible at all on the system
check_version() {
    debug_print "check_version $@"
    [ -z $2 ] && return 0
    debug_print $2
    local target_version=$(echo $2 | perl -ne '/(\d+\.+\d*\.*\d*[.-_@+#]*\d*).*/, print "$1 "' | tr -d "\"" | cut -d " " -f1,1)
    debug_print "target_version = [$target_version]"

    $1 --version >& /tmp/f || $1 -version >& /tmp/f
    [ $? != 0 ] && echo && echo "Oops, $1 command not found" && return 2
    current_version=$(cat /tmp/f 2>&1 | perl -ne '/(\d+\.+\d*\.*\d*[.-_@+#]*\d*).*/, print "$1 "' | tr -d "\""  | cut -d " " -f1,1)
    debug_print "current_version = [$current_version]"
    
    debug_print "Calling helper, check_version_helper ${current_version} >= ${target_version}"
    check_version_helper "${current_version}" ">=" "${target_version}" # note: bug found (needed to quote the operation ">=")
    local ret=$?
    debug_print "The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of $1 [${current_version}] is older than required minimum version [$2] \n"
    cat /tmp/f
    rm /tmp/f >& /dev/null
    return 1
}

#For python module version checking
#Looking for __version__ var
check_module_version() {
    local module_name=$1
    local target_version=$2
    
    local current_version=$(${cdat_home}/bin/python -c "import ${module_name}; print ${module_name}.__version__" 2> /dev/null)
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${module_name}" && return 2
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${module_name}" && return 3

    debug_print " calling helper, check_version_helper ${current_version} >= ${target_version}"
    check_version_helper "${current_version}" ">=" "${target_version}" # note: bug found (needed to quote the operation ">=")
    local ret=$?
    debug_print " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of $1 [${current_version}] is older than required minimum version [${target_version}] \n"
    return 1
}

check_webapp_version() {
    local webapp_name=$1
    local target_version=$2
    local version_property=${3:-"Version"}

    [ ! -d "${tomcat_install_dir}/webapps/${webapp_name}" ] && echo " Web Application \"${webapp_name}\" is not present or cannot be detected!" && return 2

    local current_version=$(sed -n '/^'${version_property}':[ ]*\(.*\)/p' ${tomcat_install_dir}/webapps/${webapp_name}/META-INF/MANIFEST.MF | awk '{print $2}' | xargs 2> /dev/null)
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${webapp_name}" && return 3
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${webapp_name}" && return 4

    debug_print " calling helper, check_version_helper ${current_version} >= ${target_version}"
    check_version_helper "${current_version}" ">=" "${target_version}" # note: bug found (needed to quote the operation ">=")
    local ret=$?
    debug_print " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of $1 [${current_version}] is older than required minimum version [${target_version}] \n"
    return 1
}

#0ne-off version checking mechanism for applications where version number is in the name of the directory
#of the form "app_dir-<version_num>"
check_app_version() {
    local app_dir=$1
    local target_version=$2

    local current_version=$(readlink -f ${tomcat_install_dir} | sed -ne 's/.*-\(.*\)$/\1/p')
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${app_dir##*/}" && return 2
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${app_dir##*/}" && return 3

    debug_print " calling helper, check_version_helper ${current_version} >= ${target_version}"
    check_version_helper "${current_version}" ">=" "${target_version}" # note: bug found (needed to quote the operation ">=")
    local ret=$?
    debug_print " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of ${app_dir##*/} [${current_version}] is older than required minimum version [${target_version}] \n"
    return 1
}

#Provide your own command for fetching current version
check_version_with() {
    local app_name=$1
    local target_version=$2
    local version_command=${3:-"${app_name} --version"}

    local current_version=$(eval ${version_command})
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${app_name##*/}" && return 3

    debug_print " calling helper, check_version_helper ${current_version} >= ${target_version}"
    check_version_helper "${current_version}" ">=" "${target_version}" # note: bug found (needed to quote the operation ">=")
    local ret=$?
    debug_print " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of ${app_name##*/} [${current_version}] is older than required minimum version [${target_version}] \n"
    return 1
}

# arg 1 filter name
# arg 2 webapp name
#check_for_filter() {
#
#}

#--------------------------------------------------------------------------


checked_done() {
    if (($1)); then
        echo ""
        echo "Sorry..."
        echo "This action did not complete successfully"
        echo "Please re-run this task until successful before continuing further"
        echo ""
        echo "Also please review the installation FAQ it may assist you"
        echo "http://esgf.org/wiki/Cmip5DataNode/FAQ"
        echo ""
        exit 1
    fi
    return 0
}

# Does an md5 check between local and remote resource
# returns 0 (success) iff there is no match and thus indicating that
# an update is available.
# USAGE: checked_for_update [file] http://www.foo.com/file
#
check_for_update() {
    local local_file
    local remote_file
    if (( $# == 1 )); then
        remote_file=${1}
        local_file=$(readlink -f ${1##*/})
    elif (( $# >= 2 )); then
        local_file=${1}
        remote_file=${2}
    else
        echo "function \"checked_for_update\":  Called with incorrect number of args! (fatal)"
        exit 1
    fi                      
    
    [ ! -e ${local_file} ] && echo " Hmmm... Could not find local file ${local_file}" && return 0
   #[ ! -x ${local_file} ] && echo " Hmmm... local file ${local_file} not executible" && chmod 755 ${local_file}
    diff <(md5sum ${local_file} | tr -s " " | cut -d " " -f 1) <(curl -s -L --insecure ${remote_file}.md5 | tr -s " " | cut -d " " -f 1) >& /dev/null
    [ $? != 0 ] && echo " Update Available @ ${remote_file}" && return 0
    echo " ==> ${local_file} is up to date"
    return 1
}

# If an update is available then pull it down... then check the md5 sums again!
#
#  Yes, this results in 3 network calls to pull down a file, but it
#  saves total bandwidth and it also allows the updating from the
#  network process to be cronttab-able while parsimonious with
#  resources.  It is also very good practice to make sure that code
#  being executed is the RIGHT code! 
#
#  The 3rd token is the "force" flag value 1|0.
#  1 = do not check for update, directly go and fetch the file regardless
#  0 = first check for update availability. (default)
#
#  (When using the force flag you MUST specify the first two args!!)
#
# NOTE: Has multiple return values test for (( $? > 1 )) when looking or errors
#       A return value of 1 only means that the file is up-to-date and there
#       Is no reason to fetch it.
#
# USAGE: checked_get [file] http://www.foo.com/file [<1|0>]
#
checked_get() {
    local force_get=${3:-0}
    
    if ((force_get == 0)); then
        check_for_update $@
        [ $? != 0 ] && return 1
    fi

    local local_file
    local remote_file
    if (( $# == 1 )); then
        remote_file=${1}
        local_file=${1##*/}
    elif (( $# >= 2 )); then
        local_file=${1}
        remote_file=${2}
    else
        echo "function \"checked_get\":  Called with incorrect number of args! (fatal) args[$@]"
        echo " usage: checked_get [<local dest>] <remote source> [force_get (0|1)]"
        exit 1
    fi                      
    
    if [ -e ${local_file} ]; then
        cp -v ${local_file} ${local_file}.bak
        chmod 600 ${local_file}.bak
    fi
    echo "Fetching file from ${remote_file} -to-> ${local_file}"
    wget --no-check-certificate -O ${local_file} ${remote_file}
    [ $? != 0 ] && echo " ERROR: Problem pulling down [${remote_file##*/}] from esg distribution site" && return 2
    diff <(md5sum ${local_file} | tr -s " " | cut -d " " -f 1) <(curl -s -L --insecure ${remote_file}.md5 | tr -s " " | cut -d " " -f 1) >& /dev/null
    [ $? != 0 ] && echo " WARNING: Could not verify file! ${local_file}" && return 3
    echo "[VERIFIED]"
    return 0
}

#arg1 - a filesystem path
backup() {
    [ -z "$1" ] && echo "backup - source must be provided as arg1" && return 1
    [ ! -d "$1" ] && echo "backup - must take a directory! $1 not a directory" && return 1
    local source="$(readlink -f $1)"
    echo "Backup - Creating a backup archive of ${source}"
    pushd ${source%/*} >& /dev/null
    mkdir -p ${esg_backup_dir} >& /dev/null
    local backup_filename=$(readlink -f ${esg_backup_dir})/${source##*/}.$(date ${date_format}).tgz
    tar czf ${backup_filename} ${source##*/}
    [ $? != 0 ] && echo " ERROR: Problem with creating backup archive: ${backup_filename}" && popd >& /dev/null && return 1
    if [ -e ${backup_filename} ]; then 
        echo "Created backup: ${backup_filename}" 
    else
        echo "Could not locate backup file ${backup_filename}"
        popd >& /dev/null
        return 1
    fi
    

    #-------------
    #keep only the last num_backups_to_keep files
    num_backups_to_keep=${num_backups_to_keep:-7}
    pushd ${esg_backup_dir} >& /dev/null
    files=(`ls -t | grep ${source##*/}.\*.tgz | tail -n +$((${num_backups_to_keep}+1)) | xargs`)
    if (( ${#files[@]} > 0 )); then
        echo "Tidying up a bit..."
        echo "${#files[@]} old backup files to remove: ${files[@]}"
        rm -v ${files[@]}
    fi
    popd >& /dev/null
    #-------------

    popd >& /dev/null
    return 0

    
}

backup_db() {
    local my_node_db_name=${1:-${node_db_name}}
    local my_schema_name=${2}
    mkdir -p ${esg_backup_dir}
    pushd ${esg_backup_dir} >& /dev/null
    
    echo -n "Backing up database: ${my_node_db_name} -to->  ${my_node_db_name}_backup_$(date ${date_format}).sql"
    pg_dump -U ${postgress_user} ${my_node_db_name} > ${my_node_db_name}_backup_$(date ${date_format}).sql
    [ $? == 0 ] && echo " [OK] " || echo " [FAIL] "

    #back up the schema specifically, if one is provided
    if [ -n "${my_schema_name}" ]; then 
        my_schema_name=_${my_schema_name}
        echo -n "Backing up esgf schema esgf${my_schema_name} of ${my_node_db_name} -to-> ${my_node_db_name}_esgf${my_schema_name}_backup_$(date ${date_format}).sql"
        pg_dump -U ${postgress_user} --schema esgf${my_schema_name} ${my_node_db_name} > ${my_node_db_name}_esgf_backup_$(date ${date_format}).sql
        [ $? == 0 ] && echo " [OK] " || echo " [FAIL] "
    fi
    
    #-------------
    #keep only the last num_backups_to_keep files
    num_backups_to_keep=${num_backups_to_keep:-7}
    pushd ${esg_backup_dir} >& /dev/null
    files=(`ls -t | grep ${my_node_db_name##*/}.\*.sql | tail -n +$((${num_backups_to_keep}+1)) | xargs`)
    if (( ${#files[@]} > 0 )); then
        echo "Tidying up a bit..."
        echo "${#files[@]} old backup files to remove: ${files[@]}"
        rm -v ${files[@]}
    fi
    popd >& /dev/null
    #-------------

    popd >& /dev/null
    return 0
}

#configures the database i.e. sets up table schema
#based on the the node type.
config_db() {
    init
    local let mysel=${1:-${sel:-4}}
        
    ((DEBUG)) && echo "Database configuration... (selection = ${mysel})"
    
    #-------
    #IMPORTANT! The SUM of all the handled types is the real max value
    #here! (else can't decrement down to 0 and get into an infinite loop)
    local myMAX_BIT=$((DATA_BIT+IDP_BIT)) 
    ((mysel > myMAX_BIT)) && echo -n "Adjusting selection to bounds... " && ((mysel=myMAX_BIT)) && echo "(selection = ${mysel})"
    #-------

    echo
    echo "*******************************"
    echo -n "Configuring Postgres... " && show_type
    echo "*******************************"
    echo
    
    start_postgress

    #------------------------------------------------------------------------
    #Based on the node type selection we build the appropriate database tables
    #------------------------------------------------------------------------
    
    while (( (mysel >= MIN_BIT) && (mysel <= myMAX_BIT) )); do
        
        ((DEBUG)) && echo " mysel = ${mysel} : "

        if (( (mysel & DATA_BIT) != 0 )); then
            echo "Setting up database for DATA node type"
            source ${scripts_dir}/esg-node-manager >& /dev/null && configure_postgress ${sel}
            ((mysel-=DATA_BIT))
        elif (( (mysel & IDP_BIT) != 0 )); then
            echo "Setting up database for IDP node type"
            source ${scripts_dir}/esg-security >& /dev/null && configure_postgress ${sel}
            ((mysel-=IDP_BIT))
        fi
        echo
    done
    
    ((DEBUG)) && echo "*mysel = ${mysel}"
    
    popd >& /dev/null
    echo
    echo
    checked_done 0
    
}

#Replace a pattern inside the target file with the contents of the input file
insert_file_at_pattern() {
    local target_file=$1
    local input_file=$2
    local pattern=$3

    echo "Inserting into ${target_file} <- ${input_file} at pattern ${pattern}"

    python -c "infile = '${target_file}';filterfile = '${input_file}';pattern='${pattern}';f=open(infile);s=f.read();f.close();f=open(filterfile);filter = f.read();f.close();s=s.replace(pattern,filter);f=open(infile,'w');f.write(s);f.close()"
    ret=$?
    [ $ret != 0 ] && echo "Problem in function insert_file_at_pattern in $0"
    return ${ret}
}

# Environment variable files of the form
# Ex: export FOOBAR=some_value
# Will have duplcate keys removed such that the
# last entry of that variable is the only one present
# in the final output.
# arg 1 - The environment file to dedup.
dedup() {
    local infile=${1:-${envfile}}
    [ ! -w "${infile}" ] && echo "WARNING: dedup() - unable to write to ${infile}" && return 1
    local tmp=$(tac ${infile} | awk 'BEGIN {FS="[ =]"} !($2 in a) {a[$2];print $0}' | sort -k2,2)
    echo "$tmp" > ${infile}
}

dedup_properties() {
    local infile=${1:-${config_file}}
    [ ! -w "${infile}" ] && echo "WARNING: dedup_properties() - unable to write to ${infile}" && return 1
    local tmp=$(tac ${infile} | awk 'BEGIN {FS="[ =]"} !($1 in a) {a[$1];print $0}' | sort -k1,1)
    echo "$tmp" > ${infile}
}

DEBUG=${DEBUG:=1}
config_file="esgf.properties"

#Load properties from a java-style property file
#providing them as script variables in this context
#arg 1 - optional property file (default is ${config_file})
load_properties() {
    ((DEBUG)) && echo "load properties(): "
    local property_file=${1:-${config_file}}
    [ ! -r "${property_file}" ] && return 1
    IFS="="
    local count=0
    while read key value; do
        local key=$(echo $key |sed -n 's/\./_/pg')
        [ -z "${key}" ] && continue
        ((DEBUG)) && echo -n "loading... "
        ((DEBUG)) && echo -n "[${key}] -> "
        ((DEBUG)) && echo "[${value}]"
        eval "${key}=${value}"
        ((count++))
    done < ${property_file}
    echo "Loaded (imported) ${count} properties from ${property_file}"
    unset IFS
    return 0
}

#Gets a single property from a string arg and turns it into a shell var
#arg 1 - the string that you wish to get the property of (and make a variable)
#arg 2 - optional default value to set
get_property() {
    ((DEBUG)) && echo -n "get_property(): "
    local in_key=$1
    ((DEBUG)) && echo -n "[${in_key}] -> "
    local default=$2
    local prop_key=$(echo ${in_key} |sed -n 's/_/\./pg')
    local value=$(cat ${config_file} | sed -n 's/^\('${prop_key}'\)=\(.*$\)/\2/p' | xargs)
    [ -z "${value}" ] && [ -n "${default}" ] && value=${default}
    ((DEBUG)) && echo "[${value##* }]"
    eval "${in_key}=${value##* }"
    return 0
}

#Writes variable out to property file as java-stye property
#I am replacing all bash-style "_"s with java-style "."s
#arg 1 - The string of the variable you wish to write as property to property file
#arg 2 - The value to set the variable to (default: the value of arg1)
set_property() {
    ((DEBUG)) && echo -n "set_property(): "
    local key=$(echo $1 |sed -n 's/_/\./pg')
    local value=${2:-${!1}}
    ((DEBUG)) && echo -n "[${key}] -> "
    ((DEBUG)) && echo "[${value}]"
    [ -z "${value}" ] && return 1
    cat >> ${config_file} <<EOF
${key}=${value}
EOF
    dedup_properties
    return 0
}

#"private" function
_verify() {
    echo "diff <(md5sum ${0} | tr -s " " | cut -d " " -f 1) <(curl ${1}/esgf-installer/${0##*/}.md5 | tr -s " " | cut -d " " -f 1) >& /dev/null "
    diff <(md5sum ${0} | tr -s " " | cut -d " " -f 1) <(curl -s -L --insecure ${1}/esgf-installer/${0##*/}.md5 | tr -s " " | cut -d " " -f 1) >& /dev/null
    [ $? != 0 ] && return 3
    echo "[VERIFIED]"
    return 0
}

self_verify() {
    _verify 'http://198.128.245.140/dist' >& /dev/null 
    local ret=$?
    if (( ${ret} == 3 )); then 
        printf "WARNING: $0 could not be verified!! \n(This file, ${0}, may have been tampered with or there is a newer version posted at the distribution server.\nPlease update this script.)\n\n"
        
        local choice="x"
        if [ "$#" == 1 ]; then
            debug_print "Operation $1 was chosen"
            choice=$1
        else
            local input=""
            read -t $((1*60)) -p "Do you wish to Update and exit [u], continue anyway [c] or simply exit [x]? [u/c/X]: " input
            [ -n "${input}" ] && choice=${input}
            unset input
        fi
        
        if [ "$choice" = "C" ] || [ "$choice" = "c" ] || [ -z "$choice" ]; then
            echo "Continuing..."
            echo 
            return $ret
        elif [ "$choice" = "U" ] || [ "$choice" = "u" ]; then
            echo "Updating local script with script from distribution server..."
            /usr/local/bin/esg-bootstrap
            local update_ret=$?
            echo "Please re-run this updated script $0"
            echo
            exit $update_ret
        else
            echo "Exiting..."
            echo
            exit 1
        fi
    else
        return 0
    fi
    return 0
}

#Helper method for reading the last state of node type config from config dir file "config_type"
#Every successful, explicit call to --type|-t gets recorded in the "config_type" file
#If the configuration type is not explicity set the value is read from this file.
read_sel() {
    debug_print "read_sel ${sel}"
    local let mysel=${sel}
    debug_print "mysel = ${mysel}"

    #If mysel (our private copy of sel) has not bits in the type bits range then read the config_type file
    #and set us to whatever value we currently add plus that one.  In the case of installation or testing
    #those values are below the range so they shoudl not be looked at for type selection though they may be
    #set.  However whatever we have for the type selection should be added to them for compound selection.
    if (( (mysel < MIN_BIT) || (mysel > MAX_BIT) )); then
        debug_print "Out of Range ${mysel} < ${MIN_BIT} || ${mysel} > ${MAX_BIT}"
        local last_config_type=$(cat ${esg_config_type_file} 2> /dev/null)
        ((mysel+= ${last_config_type:-0}))
        debug_print "mysel is now: ${mysel}"
    fi
    ((mysel == 0)) && \
        printf "ERROR: No node type selected nor available! \n Consult usage with --help flag... look for the \"--type\" flag \n(must come BEFORE \"[start|stop|restart|update]\" args)\n\n"
    
    debug_print "Setting sel [${sel}] to mysel [${mysel}]"
    sel=${mysel}
}

#Write the node type numeric value to file
#(Yes... gratuitous error and bounds checking)
set_sel() {
    local new_sel=${1}
    debug_print "new_sel = $new_sel"
    local type_bits=0
    local hit_bits=0
    
    #valididty check for type... in range power of 2
    #MIN and MAX BIT range... if so then valid and an be written down.
    if ((new_sel > $MAX_BIT || new_sel < $MIN_BIT)); then
        debug_print "WARNING: Selection [$1] is out of range $MIN_BIT - $MAX_BIT"
    fi

    #Check if the new sel has any bits turned on in the range of our type bits
    for ((type_bit=$MIN_BIT;type_bit<=$MAX_BIT;type_bit*=2)) ; do
        (( (new_sel & type_bit) != 0 )) && ((hit_bits+=type_bit))
    done


    debug_print "[hit_bits = $hit_bits] =? [new_sel = $new_sel]"

    if((hit_bits)); then
        echo "${hit_bits}" > ${esg_config_type_file}
        ((DEBUG)) && cat ${esg_config_type_file}
    fi
}

show_svc_list() {
    id | grep root >& /dev/null
    [ $? != 0 ] && echo "(display of node process list limited to root)" && return 0
    echo
    echo "---------------------------"
    echo "Running Node Services... "; ((sel != 0)) && show_type || echo ""
    echo "---------------------------"
    lsof -Pni |egrep  'postgres|jsvc|globus-gr|java|myproxy'
    echo "---------------------------"
    echo
    return 0
}

#-------------------------------
# ESG Node Life Cycle Functions (start/stop/status)
#-------------------------------

#Starts the esg node
start() {
    local let sel=${1:-${sel:-0}}
    debug_print "starting services... ($1)"
    read_sel
    
    [ $((sel & ALL_BIT)) == 0 ] && echo "Cannot Start: No Node Type Specified! (See --help for info on the --type|-t option)  :-|" && exit 1
    
    echo "starting services... ($sel)"
    /etc/init.d/ntpd status
    if [ $? != 0 ]; then 
        /etc/init.d/ntpd start        
    fi
    
    [ $((sel & ALL_BIT)) != 0 ] && start_postgress
    [ $((sel & ALL_BIT)) != 0 ] && start_tomcat

    (( ! no_globus )) && [ $((sel & DATA_BIT+IDP_BIT)) != 0 ] && start_globus ${sel} ${gridftp_config_args}
    [ $((sel & INDEX_BIT)) != 0 ] && source ${scripts_dir}/esg-search >& /dev/null && start_search_services

    sleep 3
    show_svc_list

    set_sel "${sel}"
    echo
}

#Stops the esg node
stop() {
    local sel=${1:-${sel:-$ALL_BIT}}
    read_sel
    source ${scripts_dir}/esg-search >& /dev/null && stop_search_services
    stop_globus $(( sel == 0 ? ALL_BIT : sel)) ${gridftp_config_args}
    stop_tomcat 
    stop_postgress 
    show_svc_list
}

#Displays the status of the node...
status() {
    #TODO conditionally reflect the status of globus (gridftp) process
    read_sel
    local ret=1
    if check_postgress_process && check_tomcat_process; then
        echo
        echo "Node Running... (${sel})"
        ret=0
    else
        echo
        echo "Stopped: No running processes detected"
        ret=1
    fi
    #This is here for sanity checking...
    show_svc_list
    return ${ret}
}

initial_setup_questions() {
    echo 
    echo "-------------------------------------------------------"
    echo 'Welcome to the ESGF Node installation program! :-)'
    echo 'First a few initial questions...'
    echo 
    mkdir -p ${esg_config_dir}

    pushd ${esg_config_dir} >& /dev/null

    get_property security_openid_host ${esgf_host}
    read -p "What is the name of this node [${security_openid_host}] " input
    [ -n "${input}" ] && set_property security_openid_host ${input}
    unset input
    
    get_property security_admin_password
    if [ -z "${security_admin_password}" ] || ((force_install)); then
        while [ 1 ]; do
            unset input
            echo
            read -s -p "What is the admin password to use for this installation (alph-numeric only): " input
            ( [ -z "${input}" ] || [ ! -z $(echo ${input} | sed -n -e 's/[a-zA-Z0-9]*//p') ] ) && echo "Invalid password... " && continue
            [ -n "${input}" ] && security_admin_password=${input}
            echo
            read -s -p "Please re-enter password: " verify_password
            if [ "${security_admin_password}" = "${verify_password}" ] ; then
                echo
                break
            else
                echo "Sorry, values did not match"
                echo
            fi
        done
        unset verify_password
        unset input
        set_property security_openid_port 443
        set_property security_admin_password

        #Use the same password when creating the postgress account
        pg_sys_acct_passwd=${security_admin_password}
    fi
    
    dedup_properties ${config_file}
    echo "-------------------------------------------------------"
    echo 
    echo
    popd >& /dev/null
    return 0
}

############################################
# Main
############################################
info() {

    printf " 

     The goal of this script is to automate as many tasks as possible
     regarding the installation of the software stack that is the ESGF
     Node.  A software stack is a collection of tools that work in
     concert to perform a particular task or set of tasks that are
     semantically united.  Essentially, the gestalt is the ESGF
     Node. The software stack is comprised of; Tomcat, Thredds,
     CDAT & CDMS, PostgreSQL, MyProxy and RedHat/CentOS. Through the
     installation process there are different accounts that are
     created that facilitate the communication between these separate
     software entities.  These credentials are internal to the stack.
     It is recommended that you use the defaults provided throughout
     this installation.  The security impact with regards to the
     visibility and accessibility of the constituent components of the
     stack depends on other factors to be addressed by your
     organization.

     Please be sure that you have gotten your Gateway (IdP)
     credentials from your configured Gateway.

     The primary/central Gateway for ESGF is:
     http://pcmdi3.llnl.gov/esgcet/home.htm -> \"create account\"

     This is required for publication.

     ESGF Node:
               ---------
               |Tomcat   |
               |-Node Mgr|
               |-Thredds |
               |-ORP     |
               |---------|
               |CDAT/CDMS|
               |---------|
               |Postgres |
               |---------|
               | MyProxy |  <===(HTTPS)===> [Gateway(s)]*
               |---------|
               | GridFTP |  <=============> [End User(s)]*
               >---------<
               | CentOS  |
               |(Virtual)|
               | Machine |
               |---------|
               ---------

     -ESG \n\n" | more 
    
}

usage() {
    printf "
usage:
(as root)
${progname} ([--<directive>] | [start] | [stop] | [status] [restart]
        --prefix      - specify the top level directory for this entire installation's \"external\" tools
                        (default:/usr/local - currently:$install_prefix)
        --workdir     - specify the directory used by the installation to download and build esg artifacts for installation
                        (default:~/workbench/esg - currently:$workdir)
        --install     - goes through the installation process
                         will automatically start up node services
        --verify      - runs the test code to verify installation
        --write-env   - writes the necessary env vars to file ${envfile}
        --version     - indicates the version of this script
        --check       - checks if this script is the most up-to-date posted <u|c|X> (Update|Continue|eXit)
        --clear       - removes the file holding the enironment state of last install
        --test-pub    - performs the publication test directly (same publication called in last step of install)
        --info        - provides a brief explaination of the DataNode
        --upgrade|--update|update - upgrades/updates the node manager
        --force       - Will allow execution of installation|update code to be executed beyond the up2date checks.
                        Basically allowing an installation|update as if starting from scratch.

        -------------------------------
        Configuration Type Selection
        -------------------------------
        --type | -t <data &| index &| idp &| compute> - Select type of node: 
                   \"data\" node, 
                   \"index\" node, 
                   \"idp\" (identity provider) node and/or 
                   \"compute\" node 
                  (note: there is no default one must be selected at least initially...
                         when in doubt use \"data\")
        --set-type  <data &| index &| idp &| compute> - Sets the type value to be used at next start up
        --get-type - returns the last stored type code value of the last run node configuration (data=4 +| index=8 +| idp=16)
        (note: (s|g)et-type flags are singular command flags, meaning they are NOT meant to work with other flags on the same command line!)

        -------------------------------
        Globus Tool Management
        -------------------------------
        --no-globus   - will not perform any operations affecting globus tools (for those with existing globus setups)
        --gridftp-config - [ with-bdm-config | bdm-config-only ] without this arg uses default end-user config only
        --myproxy - [gen-self-cert] <dir> | [regen-simpleca] [fetch-certs|gen-self-cert|keep-certs] | [install|update]

        -------------------------------
        Key Management Flags:
        -------------------------------
        --register    - connects to desired node, fetches and stores their certificate to enable ingress SSL connections
        --generate-ssl-key-and-csr - generate new key and cert request files <key file> <cert file> [<dn>]
                                     (The 'dn' value is of the form - Ex:'/O=ESG/OU=ESG-DATA-NODE/CN=<fqdn>')
        --install-keypair - takes as input private key and public cert files and installs them. <key> <cert> [<keystore> <alias> <password>]
        --fetch-esg-certs - fetches and installs all current public esg federation certificates (used by globus)
        --rebuild-truststore - converts globus' (public) ca certificates into a truststore.
        --add-my-cert-to-truststore - adds public cert from keystore to truststore: <keystore password>
        --clear-certs - removes the user-level public certificates' directory (used by myproxy)

        (deprecated) --install-signed-cert - installs signed host certificate into keystore and truststore <signed PEM file>
        (deprecated) --export-keys-to-globus  - exports keystore certificates to globus host{cert,key}.pem files.

        -------------------------------
        Database Management
        -------------------------------
        --config-db    - provides database only configuration to support based on note type (see --get-type)
        --backup-db    - creates a backup of node database to file <database name <schema name>>

        -------------------------------
        Node Life Cycle Flags:
        -------------------------------
        start   - start the node's services
        stop    - stops the node's services
        status  - status on node's services
        restart - restarts the node's services (calls stop then start :-/)
        update  - update's the node's software stack to prescribed versions
            (notice, no \"--\" flag prefix to make rc friendly also chkconfig-able ;-)

        -------------------------------
        To add this script to the linux boot sequence: (as root)
        > cd /etc/init.d
        > cp ${install_prefix}/bin/esg-node
        > chkconfig --add esg-node
        > chkconfig --list esg-node
        -------------------------------

    
      \"stop\" | \"start\" | \"status\" are meant to be run independent of other flags (and put LAST if other flags are used)
      \"--install\" may be used with \"--verify\" but neither are not intended for use
      with stop or start or status
      Ex:
         ${progname} --install OR
         ${progname} --verify OR
         ${progname} --install --verify  OR
         ${progname} --write-env OR
         ${progname} --version OR
         ${progname} --clear OR
         ${progname} --test-pub OR
         ${progname} --info OR
         ${progname} --register [gateway.host.address] ([truststore passwd])
         ${progname} --gridftp-config [ with-bdm-config | bdm-config-only ]
         ${progname} start OR
         ${progname} --gridftp-config [ with-bdm-config | bdm-config-only ] start OR
         ${progname} stop  OR
         ${progname} status OR
    
      NOTE:

      *You must be root or effectively root to run this program,
      *prefixing the command with sudo will not allow the use of
      *needed environment variables!!!! If you must use sudo, do so
      *only to become root proper then source your user's .[bash]rc
      *file so that root has it's envronment set accordingly!  Or you
      *can more simply become root using sudo's \"-s\" flag.  After a
      *full install there will be a file created ($envfile) that has
      *the basic environment vars that were used and set during the
      *installation - this should be sourced by users of this
      *application stack.

      --------------
      Typical usage:
      --------------

      Installation : esg-node --install --verify
          (submit csr and get back returned cert)
      Credentials  : esg-node --install-keypair <key> <cert>
      Test Publish : esg-node --test-pub
      Update Certs : esg-node [--force] --rebuild-truststore
      Life Cycle   : esg-node [start|stop|status|restart|update]

    " | more
    exit 0
}

done_remark() {
    echo ""
    echo "Finished!..."
    echo "In order to see if this node has been installed properly you may direct your browser to:"
    echo "http://${my_ip_address}/${node_manager_app_context_root}"
    echo "http://${my_ip_address}/thredds"
    echo "http://${my_ip_address}/OpenidRelyingParty"
    echo 
    echo "To see the published test, go your specified gateway: [${ESG_GATEWAY_NAME}]"
    echo "http://${ESG_GATEWAY_SVC_ROOT}"
    echo "and browse to \"Test Project\" -> pcmdi.${esg_root_id}.test.mytest"
    echo ""
}

#---------------
# s'all about the bits... :-)
#---------------
INSTALL_BIT=1
TEST_BIT=2
DATA_BIT=4
INDEX_BIT=8
IDP_BIT=16
COMPUTE_BIT=32
WRITE_ENV_BIT=64

#NOTE: remember to adjust (below) when adding new bits!!
MIN_BIT=4
MAX_BIT=64
ALL_BIT=$((DATA_BIT+INDEX_BIT+IDP_BIT+COMPUTE_BIT))
#---------------

show_type() {
    [ $((sel & DATA_BIT)) != 0 ] && resolved_to+="data "
    [ $((sel & INDEX_BIT)) != 0 ] && resolved_to+="index "
    [ $((sel & IDP_BIT)) != 0 ] && resolved_to+="idp "
    [ $((sel & COMPUTE_BIT)) != 0 ] && resolved_to+="compute "
    echo "node type: [ ${resolved_to}] (${sel}) "
}

main() {

    init
    let sel=0
    local selection_string
    while [ -n "$1" ]; do
    #echo "arg ${i} = $1"
        local unshift=0
        case $1 in
            --install | install)
                debug_print "INSTALL SERVICES"
                (( (sel & INSTALL_BIT) == 0 )) && ((sel+=INSTALL_BIT))
                ;;
            --verify | --test)
                debug_print "VERIFY SERVICES"
                (( (sel & TEST_BIT) == 0 )) && ((sel+=TEST_BIT))
                debug_print "sel = $sel "
                ;;
            --type | -t)
                #TODO: look for next arg if "data" node or if "index" node set the selection bit accordingly
                #This also means that I can nott use 1 for basic install will have to use 1 for prerequisite
                #and then another bit for "data" node vs "index" node
                local tvalue
                shift
                until [ $(echo $1 | egrep '^\s*--') ] || [ -z "$1" ] || [ "$1" = "stop" ] || [ "$1" = "start" ] || [ "$1" = "status" ] || [ "$1" = "restart" ] || [ "$1" = "update" ] || [ "$1" = "upgrade" ]; do
                    tvalue=$(echo "$1" | tr 'A-Z' 'a-z')
                    #turn on the proper bit when string is detected
                    [ "all"   = "${tvalue}" ]   && sel=$ALL_BIT && selection_string="all " && shift && break
                    [ "data"  = "${tvalue}" ]   && (( (sel & DATA_BIT) == 0 ))    && ((sel+=DATA_BIT))    && selection_string+="${tvalue} "
                    [ "index" = "${tvalue}" ]   && (( (sel & INDEX_BIT) == 0 ))   && ((sel+=INDEX_BIT))   && selection_string+="${tvalue} "
                    [ "idp"   = "${tvalue}" ]   && (( (sel & IDP_BIT) == 0 ))     && ((sel+=IDP_BIT))     && selection_string+="${tvalue} "
                    [ "compute" = "${tvalue}" ] && (( (sel & COMPUTE_BIT) == 0 )) && ((sel+=COMPUTE_BIT)) && selection_string+="${tvalue} "
                    shift
                done
                [ -z "${selection_string}" ] && echo "Unknown Node Type: [${tvalue}], Sorry :-(" && exit 1;
                echo "node type set to: [ $selection_string] (${sel}) "
                unshift=1
                ;;
            --set-type)
                let sel=0
                local tvalue
                shift
                until [ -z "$1" ]; do
                    tvalue=$(echo "$1" | tr 'A-Z' 'a-z')
                    #turn on the proper bit when string is detected
                    [ "all"   = "${tvalue}" ] && sel=$ALL_BIT && selection_string="all " && shift && break
                    [ "data"  = "${tvalue}" ] && ((sel+=DATA_BIT))  && selection_string+="${tvalue} "
                    [ "index" = "${tvalue}" ] && ((sel+=INDEX_BIT)) && selection_string+="${tvalue} "
                    [ "idp"   = "${tvalue}" ] && ((sel+=IDP_BIT))   && selection_string+="${tvalue} "
                    [ "compute" = "${tvalue}" ] && ((sel+=COMPUTE_BIT)) && selection_string+="${tvalue} "
                    shift
                done
                [ -z "${selection_string}" ] && echo "Unknown Node Type: [${tvalue}], Sorry :-(" && exit 1;
                echo "node type set to: [ $selection_string] (${sel}) "
                set_sel ${sel}
                exit 0
                ;;
            --get-type | --show-type)
                read_sel
                show_type
                exit 0
                ;;
            start | --start)
                shift
                (( $# != 0 ))  && echo "error: \"start\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                debug_print "START SERVICES: ${sel}"
                start ${sel}
                exit 0
                ;;
            stop | --stop)
                shift
                (( $# != 0 )) && echo "error: \"stop\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                debug_print "STOP SERVICES"
                stop ${sel}
                exit 0
                ;;
            restart | --restart)
                shift
                (( $# != 0 )) && echo "error: \"restart\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                stop ${sel}
                sleep 2
                start ${sel}
                exit 0
                ;;
            status | --status)
                shift
                (( $# != 0 )) && echo "error: \"status\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                check_prerequisites
                status
                exit $?
                ;;
            update | --update | upgrade | --upgrade )
                shift
                (( $# != 0 )) && echo "error: \"update\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                self_verify
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                
                read_sel

                #---------------
                #version checking...
                #---------------
                setup_curl
                setup_git
                setup_java
                setup_ant
                setup_postgress
                #TODO: no check for cdat yet :-(

                #The arg "1" indicates an upgrade (see function)
                setup_esgcet 1
                setup_tomcat 1
                setup_tds 1
                setup_subsystem node-manager esgf-node-manager 1
                #setup_subsystem dashboard esgf-dashboard 1
                [ $((sel & DATA_BIT ))   != 0 ] && setup_subsystem orp esg-orp 1
                [ $((sel & DATA_BIT))    != 0 ] && (( ! no_globus )) && my_setup_globus ${DATA_BIT} ${gridftp_config_args}
                [ $((sel & IDP_BIT ))    != 0 ] && (( ! no_globus )) && my_setup_globus ${IDP_BIT}  ${myproxy_config_args}
                [ $((sel & IDP_BIT ))    != 0 ] && setup_subsystem security esgf-security 1
                [ $((sel & IDP_BIT ))    != 0 ] && setup_subsystem idp esgf-idp 1
                [ $((sel & INDEX_BIT))   != 0 ] && setup_subsystem search esg-search 1
                [ $((sel & INDEX_BIT))   != 0 ] && setup_subsystem web-fe esgf-web-fe 1
                [ $((sel & COMPUTE_BIT)) != 0 ] && setup_subsystem product-server esgf-product-server 1

                #---
                start ${sel}

                exit 0
                ;;
            --write-env)
                (( (sel & WRITE_ENV_BIT) == 0 )) && ((sel+=WRITE_ENV_BIT))
                echo
                ;;
            -v | --version)
                echo "Version: $version"
                echo "Earth Systems Grid Federation (http://esgf.org)"
                echo "ESGF Node Installation Script"
                echo ""
                exit 0
                ;;
            --debug) 
                DEBUG=1
                ;;
            --verbose) 
                VERBOSE=1
                ;;
            --clear)
                self_verify
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                if [ -e ${envfile} ]; then 
                    mv -v ${envfile} ${envfile}.bak
                    echo "Cleared envfile ${envfile}"
                fi
                exit 0
                ;;
            --clear-certs)
                self_verify
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                echo "Clearing out certs..."
                local cert_dir=${HOME}/.globus/certificates
                [ -e ${cert_dir} ] && rm -rf ${cert_dir}
                exit 0
                ;;
            --test-pub)
                shift
                echo "test_publication" && test_publication $@
                exit
                ;;
            --info)
                info
                exit
                ;;
            --check)
                shift
                self_verify $1
                exit $?
                ;;
            --config-db)
                self_verify
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                read_sel
                config_db
                exit $?
                ;;
            --backup-db)
                self_verify
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                shift
                backup_db $@
                exit $?
                ;;
            --uninstall)
                self_verify
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                uninstall
                exit
                ;;
            --register)
                self_verify
                #First arg is the server
                #Second arg is the password (not required)
                shift
                register $1 $2
                exit
                ;;
            --fetch-esg-certs)
                self_verify
                shift
                (( $# != 0 ))  && echo "error: \"--fetch-esg-certs\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                fetch_esg_certificates
                exit $?
                ;;
            --rebuild-truststore)
                shift
                (( $# != 0 ))  && echo "error: \"--rebuild-truststore\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                self_verify
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                rebuild_truststore
                exit $?
                ;;
            --add-my-cert-to-truststore)
                self_verify
                shift
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                add_my_cert_to_truststore $@
                exit $?
                ;;
            --generate-ssl-key-and-csr)
                self_verify
                shift
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                #arg 1  -> what we want to name the private key
                #arg 2  -> what we want to name the public cert
                #arg 3  -> (what we want to DN to be for the public cert)
                #arg 4  -> (keystore password)
                #(no args necessary, all args have defaults)
                generate_ssl_key_and_csr $@
                exit $?
                ;;
            --install-keypair)
                self_verify
                shift
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                install_keypair $@
                exit $?
                ;;
            #*************
            #(deprecated)
            #*************
            --install-signed-cert)
                self_verify
                shift
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                install_signed_certificate $@
                exit $?
                ;;
            #*************
            #(deprecated)
            #*************
            --export-keys-to-globus)
                shift
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                export_keystore_as_globus_hostkeys
                exit $?
                ;;
            --prefix)
                local pvalue
                shift
                until [ $(echo $1 | egrep '^\s*--') ] || [ -z "$1" ] || [ "$1" = "stop" ] || [ "$1" = "start" ] || [ "$1" = "status" ] || [ "$1" = "restart" ] || [ "$1" = "update" ] || [ "$1" = "upgrade" ]; do
                    pvalue="$1"
                    debug_print "prefix value is: $1"
                    shift
                done
                unshift=1
                install_prefix=${pvalue}
                [ -z "${pvalue}" ] && printf "\nERROR: Did not properly set --prefix value!!!\n\n" && exit 1
                ;;
            --workdir)
                local wvalue
                shift
                until [ $(echo $1 | egrep '^\s*--') ] || [ -z "$1" ] || [ "$1" = "stop" ] || [ "$1" = "start" ] || [ "$1" = "status" ] || [ "$1" = "restart" ]  || [ "$1" = "update" ] || [ "$1" = "upgrade" ]; do
                    wvalue="$1"
                    debug_print "workdir value is: $1"
                    shift
                done
                unshift=1
                workdir=${wvalue}
                [ -z "${wvalue}" ] && printf "\nERROR: Did not properly set --workdir value!!!\n\n" && exit 1
                ;;
            --no-globus)
                no_globus=1
                ;;
            --force)
                force_install=1
                ;;
            --gridftp-config)
                (( (sel & DATA_BIT) == 0 )) && echo "Sorry, the --gridftp flag may only be used for \"data\" installation type" && exit 1
                #acceptable args:  "with-bdm-config" | "bdm-config-only"
                #Gather up tokens after this switch as long as the
                #subsequent tokens do not start with "--"
                local tmpargs="" #array to store args for this switch.
                local let index=0
                shift
                until [ $(echo $1 | egrep '^\s*--') ] || [ -z "$1" ] || [ "$1" = "stop" ] || [ "$1" = "start" ] || [ "$1" = "status" ] || [ "$1" = "restart" ] || [ "$1" = "update" ] || [ "$1" = "upgrade" ]; do
                    tmpargs[((index++))]=$1
                    debug_print "added $1 to args list: ${tmpargs[@]}"
                    shift
                done
                unshift=1
                [ "${#tmpargs}" = 0 ] && printf "\n\n must follow --gridftp-config with proper flag! \n\t[\"with-bdm-config\" | \"bdm-config-only\"]\n" && usage
                gridftp_config_args=${tmpargs[@]}
                ((DEBUG))&& echo "parsed from commandline - gridftp_config_args is [${gridftp_config_args}]"
                unset tmpargs
                ;;
            --myproxy)
                (( (sel & IDP_BIT) == 0 )) && echo "Sorry, the --myproxy flag may only be used for \"idp\" type commands" && exit 1
                #acceptable args:  [gen-self-cert] <dir> | [regen-simpleca] [fetch-certs|gen-self-cert|keep-certs] | [install|update]
                #Gather up tokens after this switch as long as the
                #subsequent tokens do not start with "--"
                local tmpargs=""#array to store args for this switch.
                local let index=0
                shift
                until [ $(echo $1 | egrep '^\s*--') ] || [ -z "$1" ] || [ "$1" = "stop" ] || [ "$1" = "start" ] || [ "$1" = "status" ] || [ "$1" = "restart" ] || [ "$1" = "update" ] || [ "$1" = "upgrade" ]; do
                    tmpargs[((index++))]=$1
                    debug_print "added $1 to args list: ${tmpargs[@]}"
                    shift
                done
                unshift=1
                [ "${#tmpargs}" = 0 ] && printf "\n\n must follow --myproxy with proper flags! \n\n" && usage
                myproxy_config_args=${tmpargs[@]}
                unset tmpargs
                ;;
            -h | --help)
                usage
                ;;
            *)
                printf "\n ERROR: unknown switch \"$1\" \n\n" && exit 1
                ;;
        esac
        ((!unshift)) && shift
    done

    check_prerequisites
    [ $? != 0 ] && echo && exit 1

    self_verify

    debug_print "SEL = $sel"
    [ $((sel)) == 0 ] && usage

    echo
    echo "-----------------------------------"
    echo "ESGF Node Installation Program"
    echo "-----------------------------------"
    echo 

    info

    local doit="n"
    echo "     ----------------------------------------------------------"
    echo "     Please make sure you have installed ALL the prerequisites"
    echo "     Please read the prerequisite list here:"
    echo "     http://esgf.org/wiki/Cmip5DataNode/FAQ#What_do_I_need_on_my_system_before_I_install.3F"
    echo "     Before continuing make sure they are ALL present on this system!!!!!!"
    echo "     ----------------------------------------------------------"
    echo
    read -p "Are you ready to begin the installation? [Y/n] " doit
    if [ "${doit}" = "N" ] || [ "${doit}" = "n" ] || [ "${doit}" = "no" ]; then
        exit 0
    fi    

    read_sel

    (( force_install ))  && echo "(force install is ON)"
    (( (sel & DATA_BIT ) != 0))    && echo "(data node type selected)"
    (( (sel & INDEX_BIT ) != 0))   && echo "(index node type selected)"
    (( (sel & IDP_BIT ) != 0))     && echo "(idp node type selected)"
    (( (sel & COMPUTE_BIT ) != 0)) && echo "(compute node type selected)"

    initial_setup_questions

    #---------------------------------------
    #Installation of basic system components.
    # (Only when one setup in the sequence is okay can we move to the next)
    #---------------------------------------
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_curl
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_git
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_java
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_ant
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_postgress
    [ $((sel & TEST_BIT))    != 0 ] && test_postgress
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT+COMPUTE_BIT)) != 0 ] && setup_cdat
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT+COMPUTE_BIT)) != 0 ] && setup_esgcet
    [ $((sel & TEST_BIT))    != 0 ] && [ $((sel & DATA_BIT+COMPUTE_BIT)) != 0 ] && test_esgcet
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_tomcat ${keystore_password}
    [ $((sel & TEST_BIT))    != 0 ] && test_tomcat
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT+COMPUTE_BIT)) != 0 ] && setup_tds
    [ $((sel & TEST_BIT))    != 0 ] && [ $((sel & DATA_BIT+COMPUTE_BIT)) != 0 ] && test_tds
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_subsystem node-manager esgf-node-manager #(tomcat off)
   #[ $((sel & INSTALL_BIT)) != 0 ] && setup_subsystem dashboard esgf-dashboard #(tomcat off)

    #---------------------------------------
    #Installation of "plugin" subsystems... & filters
    #---------------------------------------
    #---filters------
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "security filters subsystem (TOKEN)" && setup_subsystem security-token-filters filters $@
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "security filters subsystem (SAML/ORP)"  && setup_subsystem security-tokenless-filters filters $@

    #TODO - think about moving the two following scripts to be under the esgf-node-manager directory on the server instead of the filters dir.
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "access logging filter subsystem"  && setup_subsystem access-logging-filter filters $@
    #[ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "DRS/FS resolving filter subsystem"  && setup_subsystem drs-resolving-filter filters $@

    #---subsystems--- 
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "orp security subsystem" && setup_subsystem orp esg-orp $@
   #[ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "drslib subsystem"  && setup_subsystem drslib esgf-drslib $@


    #---------------------------------------
    # Globus Installation...
    #---------------------------------------
    #(gridftp)
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && (( ! no_globus )) && echo "calling... my_setup_globus [${DATA_BIT}]" && my_setup_globus ${DATA_BIT} ${gridftp_config_args}
    [ $((sel & TEST_BIT))    != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && (( ! no_globus )) && echo "calling... test_globus [${DATA_BIT}]"  && test_globus  ${DATA_BIT} ${gridftp_config_args}

    #(myproxy)
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & IDP_BIT))  != 0 ] && (( ! no_globus )) && echo "calling... setup_globus [${IDP_BIT}]" && my_setup_globus ${IDP_BIT}  ${myproxy_config_args}
    [ $((sel & TEST_BIT))    != 0 ] && [ $((sel & IDP_BIT)) != 0 ]  && (( ! no_globus )) && echo "calling... test_globus [${IDP_BIT}]"  && test_globus  ${IDP_BIT}  ${myproxy_config_args}

    #---------------------------------------
    # Security Services Installation...
    #---------------------------------------
    [ $((sel & IDP_BIT )) != 0 ] && setup_subsystem security esgf-security $@
    [ $((sel & IDP_BIT )) != 0 ] && setup_subsystem idp esgf-idp $@
    
    #---------------------------------------
    # Index type install...
    #---------------------------------------
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & INDEX_BIT)) != 0 ] && echo "search subsystem" && setup_subsystem search esg-search $@
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & INDEX_BIT)) != 0 ] && echo "web-fe subsystem" && setup_subsystem web-fe esgf-web-fe $@
    [ $((sel & TEST_BIT)) != 0 ]    && [ $((sel & INDEX_BIT)) != 0 ] && echo "test search subsystem" && \
        source ${scripts_dir}/esg-search >& /dev/null && test_search_services


    #---------------------------------------
    # Compute type install...
    #---------------------------------------
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & COMPUTE_BIT)) != 0 ] && setup_subsystem product-server esgf-product-server $@


    #---------------------------------------
    # Publishing Test...
    #---------------------------------------
    [ $((sel & TEST_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "test_publication" && test_publication


    #---------------------------------------
    #Summary and Installation Housekeeping...
    #---------------------------------------
    [ $((sel & INSTALL_BIT))   != 0 ] && echo "show_summary" && show_summary 
    [ $((sel & WRITE_ENV_BIT)) != 0 ] && echo "write_env" && write_env && exit 0
    

    #---------------------------------------
    #System Launch...
    #---------------------------------------
    start ${sel}
    done_remark
    echo "${version}" |tee ${esg_root_dir}/version
    echo 
}

esg_node_finally() {
    echo "(esg_datanode: cleaning up etc...)"
    chown -R ${installer_uid}:${installer_gid} ${X509_CERT_DIR} >& /dev/null
    chown -R ${installer_uid}:${installer_gid} ${HOME}/.globus >& /dev/null
    exit 0
}

#Set system traps
trap esg_node_finally INT TERM

[ -w "${logfile}" ] && echo "start time: `date`" >> ${logfile}
main $@
trap - INT TERM
esg_node_finally
[ -w "${logfile}" ] && echo "end time: `date`" >> ${logfile}
