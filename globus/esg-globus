#!/bin/bash

#####
# ESG GLOBUS TOOLS
# This script is intended to be an adjunct to the esg-node / esg-gway scripts
#             (author: gavin@llnl.gov)
#****************************************************************************
#*                                                                          *
#*  Organization: Lawrence Livermore National Lab (LLNL)                    *
#*   Directorate: Computation                                               *
#*    Department: Computing Applications and Research                       *
#*      Division: S&T Global Security                                       *
#*        Matrix: Atmospheric, Earth and Energy Division                    *
#*       Program: PCMDI                                                     *
#*       Project: Earth Systems Grid (ESG) Data Node Software Stack         *
#*  First Author: Gavin M. Bell (gavin@llnl.gov)                            *
#*                                                                          *
#****************************************************************************
#*                                                                          *
#*   Copyright (c) 2009, Lawrence Livermore National Security, LLC.         *
#*   Produced at the Lawrence Livermore National Laboratory                 *
#*   Written by: Gavin M. Bell (gavin@llnl.gov)                             *
#*   LLNL-CODE-420962                                                       *
#*                                                                          *
#*   All rights reserved. This file is part of the:                         *
#*   Earth System Grid (ESG) Data Node Software Stack, Version 1.0          *
#*                                                                          *
#*   For details, see http://esg-repo.llnl.gov/esg-node/                    *
#*   Please also read this link                                             *
#*    http://esg-repo.llnl.gov/LICENSE                                      *
#*                                                                          *
#*   * Redistribution and use in source and binary forms, with or           *
#*   without modification, are permitted provided that the following        *
#*   conditions are met:                                                    *
#*                                                                          *
#*   * Redistributions of source code must retain the above copyright       *
#*   notice, this list of conditions and the disclaimer below.              *
#*                                                                          *
#*   * Redistributions in binary form must reproduce the above copyright    *
#*   notice, this list of conditions and the disclaimer (as noted below)    *
#*   in the documentation and/or other materials provided with the          *
#*   distribution.                                                          *
#*                                                                          *
#*   Neither the name of the LLNS/LLNL nor the names of its contributors    *
#*   may be used to endorse or promote products derived from this           *
#*   software without specific prior written permission.                    *
#*                                                                          *
#*   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
#*   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
#*   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
#*   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE    *
#*   LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR     *
#*   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,           *
#*   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       *
#*   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF       *
#*   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND    *
#*   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,     *
#*   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT     *
#*   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF     *
#*   SUCH DAMAGE.                                                           *
#*                                                                          *
#****************************************************************************
######

#Should have been "INHERITED" from calling esg-node or esg-gway scripts
install_prefix=${install_prefix:-"/usr/local"}
DEBUG=${DEBUG:-1}
force_install=${force_install:-0}
workdir=${workdir:-~/workbench/esg}
install_manifest=${install_manifest:-"${esg_root_dir}/esgf-install-manifest"}
globus_global_certs_dir=${globus_global_certs_dir:-/etc/grid-security/certificates}
esg_functions_file=${esg_functions_file:-${install_prefix}/bin/esg-functions}

#------------------------------------------------------------
# We want globus to fully behave as though it's home is /root
orig_user_home=${HOME}
HOME=/root
#------------------------------------------------------------

#--------------
# ID Setting
#--------------
# this should get exported from caller preferably
if [[ -z "$installer_uid" || -z "$installer_gid" ]]; then 
    installer_user=${ESG_USER:-$(echo "$HOME" | sed 's#.*/\([^/]\+\)/\?$#\1#')}
    installer_uid=${ESG_USER_UID:-${SUDO_UID:-$(id -u $installer_user)}}
    installer_gid=${ESG_USER_GID:-${SUDO_GID:-$(id -g $installer_user)}}
    installer_home=${ESG_USER_HOME:-$(getent passwd ${installer_uid} | awk -F : '{print $6}')}
    
    #deprecate SUDO_?ID so we only use one variable for all this
    [[ $SUDO_UID ]] && ESG_USER_UID=${SUDO_UID} && unset SUDO_UID && echo "SUDO_UID is deprecated, use ESG_USER_UID instead"
    [[ $SUDO_GID ]] && ESG_USER_GID=${SUDO_GID} && unset SUDO_GID && echo "SUDO_GID is deprecated, use ESG_USER_GID instead"
fi   

esg_root_dir=${esg_root_dir:-"/esg"}
esg_backup_dir=${esg_backup_dir:-"${esg_root_dir}/backups"}
esg_config_dir=${esg_config_dir:-"${esg_root_dir}/config"}
esg_log_dir=${esg_log_dir:-"${esg_root_dir}/log"}
esg_tools_dir=${esg_tools_dir:-"${esg_root_dir}/tools"}

esg_dist_url=${esg_dist_url_root}$( ((devel == 1)) && echo "/devel" || echo "")

#maybe I am paranoid but I want to make sure someone can't just set
#the environment to any place and have us just accept it and pull from
#it -gavin
if $(echo "${esg_dist_url}" | grep "http://198.128.245.140/dist" >& /dev/null); then echo "*"; else (echo "illegal distribution url: ${esg_dist_url}" && checked_done 1); fi

compress_extensions=${compress_extensions:-".tar.gz|.tar.bz2|.tgz|.bz2"}
cdat_home=${cdat_home:-${install_prefix}/cdat}

#-----------
globus_version=${globus_version:-"5.0.4"}
gridftp_server_version=${gridftp_server_version:-"3.33"}
adq_version=${adq_version:-"0.9.1"}
myproxy_version=${myproxy_version:-"5.4"}
usage_parser_version=${usage_parser_version:-"0.1.1"}

mhash_version=${mhash_version:-"0.9.9.9"}
pam_pgsql_version=${pam_pgsql_version:-"0.7"}
bison_version=${bison_version:-"2.4"}
flex_version=${flex_version:-"2.5.35"}
gsoap_version=${gsoap_version:-"2.7.15"}

#-----------
globus_location=${GLOBUS_LOCATION:-${install_prefix}/globus}
# since script runs as root and simpleCA should be done as root, make it /root/.globus here
dot_globus=${HOME}/.globus
#NOTE-RedHat/CentOS specific...
globus_word_size=${globus_word_size:-$(file /bin/bash | perl -ple 's/^.*ELF\s*(32|64)-bit.*$/$1/g')}
num_cpus=${num_cpus:-1}
globus_install_dir=$globus_location
globus_workdir=${workdir}/extra/globus
globus_sys_acct=${globus_sys_acct:-globus}
globus_sys_acct_group=${globus_sys_acct_group:-globus}
globus_sys_acct_passwd=${globus_sys_acct_passwd:-$(cat ${esgf_secret_file} 2> /dev/null)}
globus_dist_url=${esg_dist_url}/globus/gt${globus_version}-all-source-installer.tar.bz2
#-----------
gridftp_config=${gridftp_config:-""}
gridftp_dist_url_base=${esg_dist_url}/globus/gridftp
gridftp_update_dist_url=${gridftp_dist_url_base}/globus_gridftp_server-${gridftp_server_version}.tar.gz
#gridftp_authz_esgsaml_dist_url=${gridftp_dist_url_base}/authz_esgsaml_callout-09-02-2010.tar.gz
#gridftp_authz_esgsaml_dist_url=${gridftp_dist_url_base}/authz_esgsaml_callout-07-18-2011.tar.gz
gridftp_authz_esgsaml_dist_url=${gridftp_dist_url_base}/authz_esgsaml_callout-06-06-2012.tar.gz
#gridftp_bdm_dist_url=${gridftp_dist_url_base}/BDM/authz_bdm_callout-12-17-2009.tar.gz
gridftp_bdm_dist_url=${gridftp_dist_url_base}/BDM/authz_bdm_callout-02-11-2011.tar.gz
gsi_authz_conf_dist_url=${gridftp_dist_url_base}/authz_callouts_esgsaml${globus_word_size}.cfg
customgsiauthz_dist_url=${gridftp_dist_url_base}/customgsiauthzinterface.tar.gz
gss_assist_patch_dist_url=${gridftp_dist_url_base}/globus_gss_assist-5.5.tar.gz
gridftp_chroot_jail=${esg_root_dir}/gridftp_root
#ports end-user configured:
gridftp_server_port=2811
gridftp_server_port_range=${gridftp_server_port_range:-60000,61000}
gridftp_server_source_range=${gridftp_server_source_range:-60000,61000}
gridftp_server_usage_log=${esg_log_dir}/esg-server-usage-gridftp.log
gridftp_server_usage_config=${esg_config_dir}/gridftp/esg-server-usage-gridftp.conf
#ports bdm-configured:
gridftp_bdm_server_port=2812
gridftp_bdm_server_port_range=${gridftp_bdm_server_port_range:-60000,61000}
gridftp_bdm_server_source_range=${gridftp_bdm_server_source_range:-60000,61000}
gridftp_bdm_server_usage_log=${esg_log_dir}/esg-bdm-usage-gridftp.log
gridftp_bdm_server_usage_config=${esg_config_dir}/gridftp/esg-bdm-usage-gridftp.conf
esg_crontab=${esg_config_dir}/esg_crontab
#-----------
myproxy_config_args=${myproxy_config_args:-""}
myproxy_dist_url_base=${esg_dist_url}/globus/myproxy
myproxy_dist_url=http://downloads.sourceforge.net/project/cilogon/myproxy/myproxy-${myproxy_version}.tar.gz
myproxy_endpoint=${myproxy_endpoint}
myproxy_location=${globus_location}/bin/
#-----------
#esg_usage_parser_dist_url=http://www.mcs.anl.gov/~neillm/esg/esg_usage_parser-0.1.0.tar.gz
esg_usage_parser_dist_url=${esg_dist_url}/globus/gridftp/esg_usage_parser-${usage_parser_version}.tar.bz2
mhash_dist_url=${myproxy_dist_url_base}/mhash-${mhash_version}.tar.bz2
mhash_workdir=${workdir}/extra/mhash
pam_pgsql_dist_url=${myproxy_dist_url_base}/pam-pgsql-${pam_pgsql_version}.tar.gz
pam_pgsql_workdir=${workdir}/extra/pam_pgsql
pam_pgsql_install_dir=${install_prefix}/pam
postgress_jar=${postgress_jar:-postgresql-8.3-603.jdbc3.jar}
bison_dist_url=http://ftp.gnu.org/gnu/bison/bison-${bison_version}.tar.gz
flex_dist_url=http://downloads.sourceforge.net/project/flex/flex/flex-${flex_version}/flex-${flex_version}.tar.gz
gsoap_dist_url=${esg_dist_url}/thirdparty/gsoap_${gsoap_version}-nm-patched.tar.gz
#gsoap_dist_url=http://downloads.sourceforge.net/project/gsoap2/gSOAP/gSOAP%20${gsoap_version}%20stable/gsoap_${gsoap_version}.tar.gz
#gsoap_dist_url=http://sourceforge.net/projects/gsoap2/files/gSOAP/gsoap_2.7.17.zip/download
gsoap_install_dir=${install_prefix}/gsoap
gsoap_workdir=${workdir}/extra/gsoap
libglobus_adq_dist_url=${gridftp_dist_url_base}/libglobus_adq-${adq_version}.tar.gz

#-----------
#"PRIVATE" variables that are expected to be set and overridden by calling script!!
#-----------
openid_dirname=${openid_dirname:-"https://${esgf_host}/esgf-idp/openid/"}
esgf_db_name=${ESGF_DB_NAME:-${GATEWAY_DB_NAME:-esgcet}} #(originating instance of this var)
postgress_install_dir=${postgress_install_dir:-${install_prefix}/pgsql}
postgress_user=${postgress_user:-dbsuper}
postgress_host=${postgress_host:-localhost}
postgress_port=${postgress_port:-5432}
pg_sys_acct=${pg_sys_acct:-postgres}
#-----------

#-----------
#NOTE: These should have been written by the install of openssl,
#      if it was deamed necessary to do so. see esg-node:setup_openssl()
#      Values needed for globus compilation to include SSL support when 
#      not in default location - i.e. we installed our own.
#export OPENSSL_INCLUDES="-I${OPENSSL_HOME}/include"
#export OPENSSL_CFLAGS="-fPIC"
#export OPENSSL_LDFLAGS="-L${OPENSSL_HOME}/lib"
#export OPENSSL_LIBS="-lssl -lcrypto"
#-----------

globus_flavor=gcc${globus_word_size}dbg
debug_print "(globus_flavor = ${globus_flavor})"

date_format=${date_format:-"+%Y_%m_%d_%H%M%S"}

export X509_CERT_DIR=${X509_CERT_DIR:-/etc/grid-security/certificates/}
export GLOBUS_SYS_ACCT=${globus_sys_acct}  #TODO: why is this an exported var?

#NOTE: This is just here as a note, should be set already by th
#      calling environment. Maybe refactor this out of esg-node and
#      pull test_publication into separate test publication script?
#      Hmmmm.... No harm in doubling up, but come back and make crispy
#      and clean later
prefix_to_path LD_LIBRARY_PATH $GLOBUS_LOCATION/lib >> ${envfile}
prefix_to_path PATH $GLOBUS_LOCATION/bin >> ${envfile}
dedup ${envfile} && source ${envfile}


#NTP is so important to distributed systems that it should be started on G.P.
/etc/init.d/ntpd start >& /dev/null

#--------------------------------------------------------------
# PROCEDURE 
#--------------------------------------------------------------

#arg1 - config_type ("datanode" ["bdm"|"end-user"] | 
#                    "gateway"  [gen-self-cert] <dir> | (<regen-simpleca> [fetch-certs|gen-self-cert|keep-certs] | ["install"|"update"])
setup_globus_services() {

    local config_type="$1"
    
    echo
    echo "*******************************"
    echo "Setting up Globus... ($1: $config_type) - (flavor: ${globus_flavor})"
    echo "*******************************"
    echo

    local dosetup
    local default_val="n"
    if [ -e ${globus_install_dir} ]; then
        echo "Detected an existing Globus installation at ${globus_install_dir}"
	if [ -x ${globus_location}/bin/globus-version ]; then
	    echo "Checking for globus ${globus_version}"
            echo "Current globus version: $(${globus_install_dir}/bin/globus-version)"
            check_version_atleast ${globus_location}/bin/globus-version ${globus_version}
            [ $? == 0 ] && default_val="n" && echo "Globus version appears sufficiently current"
	else
	    echo "Globus installation does NOT appear to be complete.  Installation is recommended."
	fi

	if [ "${config_type}" = "datanode" ]; then
	    if [ ! -e ${globus_location}/sbin/globus-gridftp-server ]; then
		echo "GridFTP is not installed.  Installation is recommended";
	    fi
	else
	    if [ ! -d ${dot_globus} ]; then
		echo "The MyProxy SimpleCA is not found in official location [${dot_globus}] "
                if [ -e "${orig_user_home}/.globus" ]; then
                    echo "(It looks like a migration is can be performed from [${orig_user_home}/.globus])"
                else
                    echo "Installation is recommended";
                fi
	    fi
	fi

        read -p "Do you want to continue with the Globus installation and setup? $([ "$default_val" = "Y" ] && echo "[Y/n]" || echo "[y/N]") " dosetup
        [ -z "${dosetup}" ] && dosetup=$default_val

        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping Globus installation and setup - will assume Globus is setup properly"
            return 0
        fi
        echo
    fi

    echo "setup_globus_services for ${config_type} - ${globus_word_size}bit arch : [$*]"
    if [ "${config_type}" = "datanode" ]; then

        echo
        echo "*******************************"
        echo "Setting up ESGF Globus GridFTP Service(s)"
        echo "*******************************"
        echo

	if [ -x ${globus_location}/sbin/globus-gridftp-server ]; then
            echo -n "Checking for GridFTP server version ${gridftp_server_version}"
            local g_ver="(${globus_location}/sbin/globus-gridftp-server -v 2>&1 | cut -b 24-27)"
            check_version_with globus-gridftp-server "$g_ver" "${gridftp_server_version}"
#            local ret=$?
#            ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0
            echo ""

            read -p "Do you want to make a back up of the existing Globus distribution? $([ "$default_val" = "N" ] && echo "[Y/n]" || echo "[y/N]") " dosetup
            [ -z "${dosetup}" ] && dosetup=$default_val

            if [ "${dosetup}" != "N" ] && [ "${dosetup}" != "n" ]; then
                backup_and_remove_globus_location
            fi
	else
	    echo "GridFTP is not installed.  Installation is recommended."
	fi

        create_globus_account
        setup_globus datanode
        setup_gridftp_metrics_logging

        #now for configuration of the portions we just "setup" (installed)
        shift
        while [ -n "$1" ]; do 
            case $1 in
                "bdm")
                    echo " bdm configuration..."
                    config_bdm_gridftp_server && \
                        config_gridftp_metrics_logging "bdm"
                    [ $? != 0 ] && echo " WARNING: Unable to complete $1 gridftp configuration!!" && return 1
                    ;;
                "end-user")
                    echo " end-user configuration..."
                    config_gridftp_server && \
                        config_gridftp_metrics_logging "end-user"
                    [ $? != 0 ] && echo " WARNING: Unable to complete $1 gridftp configuration!!" && return 2
                    ;;
                *)
                    echo "Unknown gridftp configuration [$2] please select \"bdm\" and/or \"end-user\")"
                    return 4;
                    ;;
            esac
            shift
        done

        upgrade_gridftp_server
        
        [ -e ${globus_location}/sbin/globus-gridftp-server ] && \
            write_as_property gridftp_app_home ${globus_location}/sbin/globus-gridftp-server || \
            echo "WARNING: Cannot find executable ${globus_location}/sbin/globus-gridftp-server"
        setup_gridftp_jail

    elif [ "${config_type}" = "gateway" ]; then

        echo
        echo "*******************************"
        echo "Setting up The ESGF Globus MyProxy Services"
        echo "*******************************"
        echo

        _mv_simpleca_to_root

        if [ -d ${dot_globus}/simpleCA ]; then
            echo -n "Checking for MyProxy server version ${myproxy_version}"
            local m_ver="(${globus_location}/sbin/myproxy-server -V | cut -b 36-39)"
            check_version_with myproxy-server "$m_ver" "${myproxy_version}"
#            local ret=$?
#            ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0
            echo ""

            read -p "Do you want to make a back up of the existing MyProxy SimpleCA ($1)? $([ "$default_val" = "N" ] && echo "[Y/n]" || echo "[y/N]") " dosetup
            [ -z "${dosetup}" ] && dosetup=$default_val

            if [ "${dosetup}" != "N" ] && [ "${dosetup}" != "n" ]; then
                backup_simpleca
            fi
	else
	    echo "MyProxy Server is not installed.  Installation is recommended."
        fi

        create_globus_account
        shift
        local ret=1
        if [ "$1" = "gen-self-cert" ]; then
            shift
            generate_self_signed_cert $@
            [ $? != 0 ] && return 1
        elif [ "$1" = "regen-simpleca" ]; then
            echo "Following directive to Regenerate SimpleCA only..."
            shift
            config_myproxy_server $@
            [ $? != 0 ] && return 2
        else
            setup_globus gateway
            upgrade_myproxy_server
            config_myproxy_server $@
            ret=$?
            _mv_simpleca_to_root
            [ $ret != 0 ] && return 3
        fi
        
    else
        echo "You must provide a configuration type arg [datanode | gateway]"
        return 1
    fi

    # install this patch after both gridftp and myproxy
    install_gss_assist_patch

    return 0
}

_mv_simpleca_to_root() {
    #------------------------------------------------------------------------
    # A bit of migration code.  Older installations installed in ${orig_user_home}/.globus
    # Current installations are always under ${dot_globus} (defined at top)
    #------------------------------------------------------------------------
    if [ -e "${orig_user_home}/.globus" ] && [ ! -d ${dot_globus} ]; then
        echo "Noticed that you have a simpleCA in ${orig_user_home}/.globus, hmmm...."
        echo "The only valid location for simpleCA setup is in ${dot_globus}.... "
        pushd ${orig_user_home} >& /dev/null
        echo -n "transferring... ${orig_user_home}/.globus -to-> ${dot_globus} "
        tar czpf - .globus | (cd ${dot_globus%/*}; tar xzpf - )
        [ -d "${dot_globus}" ] && echo "[OK]"
        echo -n "backing up detected installation... "
        if tar czpf .globus-$(date ${date_format}).tgz .globus ; then
            echo "[OK]"
            echo -n "cleaning up... "
            rm -rf "${orig_user_home}/.globus" && echo "[OK]" || (echo "[FAIL]" && popd >& /dev/null && return 1)
        else
            echo "[FAIL]"
        fi
        popd >& /dev/null
        echo
        _performed_simpleCA_migration=1
    fi
    #------------------------------------------------------------------------
}

backup_and_remove_globus_location() {
    if [ -d ${globus_location} ]; then
	backup ${globus_location}
	rm -rf ${globus_location}
    fi
}

backup_simpleca() {
    if [ -d ${dot_globus} ]; then
	backup ${dot_globus}
    fi
    if [ -d "/etc/grid-security" ]; then
	backup /etc/grid-security
    fi
}

#arg1 - config_type ("datanode" ["bdm" | "end-user"] | "gateway")
start_globus_services() {
    local config_type="$1"
    echo "Starting Globus services for ${config_type}"
    if [ "${config_type}" = "datanode" ]; then
        shift
        start_gridftp_server $@ #i.e. the gridftp_config
        write_as_property gridftp_endpoint "gsiftp://${esgf_host:-$(hostname --fqdn)}"
        #zoiks TODO: setup code to check on the crontab for gridftp usage parser.
        return $?
    elif [ "${config_type}" = "gateway" ]; then
        start_myproxy_server
        return $?
    else
        echo "You must provide a configuration type arg [datanode | gateway]"
        return 1
    fi
}

#arg1 - config_type ("datanode" ["bdm" | "end-user"] | "gateway")
stop_globus_services() {
    local config_type="$1"
    echo "stop_globus_services for ${config_type}"
    if [ "${config_type}" = "datanode" ]; then
        shift
        stop_gridftp_server $@
        return $?
    elif [ "${config_type}" = "gateway" ]; then
        stop_myproxy_server
        return $?
    else
        echo "You must provide a configuration type arg [datanode | gateway]"
        return 1
    fi
}

#arg1 - config_type ("datanode" | "gateway")
test_globus_services() {
    local config_type="$1"
    debug_print "test_globus_services for ${config_type} -> [$@]"
    if [ "${config_type}" = "datanode" ]; then
        shift
        test_auth_service
        test_gridftp_server $@
        return $?
    elif [ "${config_type}" = "gateway" ]; then
        shift
        test_myproxy_server $@
        return $?
    else
        echo "You must provide a configuration type arg [datanode | gateway]"
        return 1
    fi
}

#--------------------------------------------------------------
# GLOBUS INSTALL (subset)
#--------------------------------------------------------------

# All methods below this point should be considered "private" functions

setup_globus() {
    local config_type
    if [ $1 = "datanode" ]; then
        config_type="gridftp gsi-myproxy globus_simple_ca_setup"
    elif [ $1 = "gateway" ]; then
        config_type="gsi-myproxy globus_simple_ca_setup"
    else
        echo "You must provide a configuration type arg [datanode | gateway]"
        checked_done 1
    fi

    mkdir -p $globus_workdir
    [ $? != 0 ] && checked_done 1
    chmod a+rw $globus_workdir
    pushd $globus_workdir >& /dev/null
    
    globus_dist_file=${globus_dist_url##*/}
    #strip off ".tar.bz2" at the end
    globus_dist_dir=$(echo ${globus_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')
    
    #Check to see if we have a globus distribution directory
    if [ ! -e ${globus_dist_dir} ]; then
        echo "Don't see globus distribution dir ${globus_dist_dir}"
        if [ ! -e ${globus_dist_file} ]; then
            echo "Don't see globus distribution file ${globus_dist_file} either"
            echo "Downloading Globus from ${globus_dist_url}"
            wget -O ${globus_dist_file} ${globus_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download Globus:${globus_dist_file}" && popd && checked_done 1
            echo "One moment please, unpacking..." && tar xjf ${globus_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract Globus: ${globus_dist_file}" && popd && checked_done 1
        fi
    fi
    
    #If you don't see the directory but see the tar.bz2 distribution
    #then expand it and go from there....
    if [ -e ${globus_dist_file} ] && [ ! -e ${globus_dist_dir} ]; then
        tar xvjf ${globus_dist_file}
    fi
    
    pushd ${globus_dist_dir} >& /dev/null
    ((force_install)) && (echo "Cleaning the source tree.. $(pwd) " && gmake clean && echo "[OK]" || echo "[FAIL]")
    echo "./configure --prefix=${globus_install_dir} --with-flavor=${globus_flavor}"
    if  ./configure --prefix=${globus_install_dir} --with-flavor=${globus_flavor} \
        && gmake ${config_type} \
        && gmake install
    then
        echo "Successfully Configured and Built Globus in: ${globus_install_dir}"
    else
        echo " ERROR: Could NOT successfully build GLOBUS!"
        popd >& /dev/null
        checked_done 1
    fi
    
    popd >& /dev/null
    checked_done 0
}

#--------------------------------------------------------------
# GRID FTP
#--------------------------------------------------------------

upgrade_gridftp_server() {

    #-------
    echo "Installing custom gsi authz interface patch..."
    checked_get ${customgsiauthz_dist_url##*/} ${customgsiauthz_dist_url} $((force_install))
    (( $? > 1 )) && popd && checked_done 1
    tar -xzf ${customgsiauthz_dist_url##*/}
    pushd $(echo ${customgsiauthz_dist_url##*/} | awk 'gsub(/('$compress_extensions')/,"")') >& /dev/null
    ./bootstrap
    ./configure --prefix=${globus_location} --with-flavor=${globus_flavor}
    make && make install
    [ $? != 0 ] && (echo " ERROR: unable to build from ${gridftp_update_dist_file}" && popd && popd && checked_done 1) || echo " [OK] "
    popd >& /dev/null
    checked_done 0
    #-------
}

install_gss_assist_patch() {

    #-------
    echo "Installing gss assist patch..."
    gss_assist_patch_dist_file=${gss_assist_patch_dist_url##*/}
    if [ ! -e ${gss_assist_patch_dist_file} ]; then
        checked_get ${gss_assist_patch_dist_file} ${gss_assist_patch_dist_url} $((force_install))
        (( $? > 1 )) && popd && checked_done 1
    fi

    ${globus_location}/sbin/gpt-build -force -update ${gss_assist_patch_dist_file} ${globus_flavor} ${globus_flavor}
    [ $? != 0 ] && echo " ERROR: unable to build from ${gss_assist_patch_dist_file}" || echo " [OK] "

    echo "${globus_location}/sbin/gpt-postinstall"
    ${globus_location}/sbin/gpt-postinstall
    [ $? != 0 ] && echo " ERROR: unable to perform postinstall" || echo " [OK] "

    ${globus_location}/sbin/globus-gridftp-server -v
    popd >& /dev/null
    checked_done 0
    #-------
}


# Note: grid ftp servers live on data-nodes (with a myProxy install)
# http://www.ci.uchicago.edu/wiki/bin/view/ESGProject/SAMLAuthzClientInstructions
setup_gsoap() {

    #----------------------------------------
    echo "Checking pre-requisites for gridftp configuration... "

    echo -n "Checking for flex... "
    flex --version >& /dev/null
    [ $? != 0 ] && echo "[FAIL] You may download it from: ${flex_dist_url}" && checked_done 1
    echo "[OK]"

    echo -n "Checking for bison... "
    bison --version >& /dev/null
    [ $? != 0 ] && echo "[FAIL] You may download it from: ${bison_dist_url}" && checked_done 1
    echo "[OK]"
    #----------------------------------------

    if [ ! -e ${gsoap_install_dir} ]; then 
        mkdir -p ${gsoap_workdir}
        [ $? != 0 ] && checked_done 1
        chmod a+rw ${gsoap_workdir}
        pushd $gsoap_workdir >& /dev/null
        local gsoap_dist_file

        #------
        #For installing gsoap 2.7.15
        #http://downloads.sourceforge.net/project/gsoap2/gSOAP/2.7.15%20stable/gsoap_2.7.15.tar.gz
        #
        gsoap_dist_file=${gsoap_dist_url##*/}
        #strip off .##.tar.gz at the end, i.e. last 10 chars, to get untarred dir name
        gsoap_dist_dir=$(echo ${gsoap_dist_file} | awk '{print substr($1,1,length($1)-10)}' | sed 's/_/-/g')
        #------
        
        
        #------
        #For installing gsoap 2.7.17 do the follwing
        #(current) http://sourceforge.net/projects/gsoap2/files/gSOAP/gsoap_2.7.17.zip/download
        #
        #gsoap_dist_file=${gsoap_dist_url%/*}
        #gsoap_dist_file=${gsoap_dist_file##*/}
        #strip off .##.zip at the end, i.e. last 7 chars, to get unzipped dir name
        #gsoap_dist_dir=$(echo ${gsoap_dist_file} | awk '{print substr($1,1,length($1)-7)}' | sed 's/_/-/g')
        #------
        
        #There is this pesky case of having a zero sized dist file... WTF!?
        if [ -e ${gsoap_dist_file} ]; then
            ls -l ${gsoap_dist_file}
            #NOTE: I know there must be a cleaner way to get this, maybe stat?
            local size=$(ls -l | grep ${gsoap_dist_file} | tr -s " " | cut -d " " -f 5)
            (( size == 0 )) && rm -v ${gsoap_dist_file}
        fi

        #Check to see if we have postgres distribution directory
        if [ ! -e ${gsoap_dist_dir} ]; then
            echo "Don't see gSOAP distribution dir ${gsoap_dist_dir}"
            if [ ! -e ${gsoap_dist_file} ]; then
                echo "Don't see gSOAP distribution file ${gsoap_dist_file} either"
                echo "Downloading gSOAP from ${gsoap_dist_url}"
                checked_get ${gsoap_dist_file} ${gsoap_dist_url} $((force_install))
                (( $? > 1 )) && echo " ERROR: Could not download gSOAP:${gsoap_dist_file}" && popd && checked_done 1
                [ "${gsoap_dist_file##*.}" = "zip" ] && unzip ${gsoap_dist_file} || tar xvf ${gsoap_dist_file}
                [ $? != 0 ] && echo " ERROR: Could not extract gSOAP: ${gsoap_dist_file}" && popd && checked_done 1
            fi
        fi
        
        #If you don't see the directory but see the tar.gz distribution
        #then expand it and go from there....
        if [ -e ${gsoap_dist_file} ] && [ ! -e ${gsoap_dist_dir} ]; then
            [ "${gsoap_dist_file##*.}" = "zip" ] && unzip ${gsoap_dist_file} || tar xvf ${gsoap_dist_file}
        fi
        
        pwd

        pushd ${gsoap_dist_dir} >& /dev/null
        cd gsoap-2.7
        ((force_install)) && (echo "Cleaning the source tree.. $(pwd) " && gmake clean && echo "[OK]" || echo "[FAIL]")
        echo "./configure --prefix=${gsoap_install_dir}"
        if ./configure --prefix=${gsoap_install_dir} \
            && gmake \
            && gmake install
        then
            echo "Successfully Configured and Built gSOAP in: ${gsoap_install_dir}"
            echo "$(date ${date_format}) gsoap=${gsoap_version} ${gsoap_install_dir}" >> ${install_manifest}
            dedup ${install_manifest}

        else
            echo " ERROR: Could NOT successfully build gSOAP!"
            popd >& /dev/null
            checked_done 1
        fi
        cd ../
        popd >& /dev/null
        popd >& /dev/null
    else
        echo "Detected a gSOAP installation... will not re-install gSOAP"
    fi

    return 0
}

setup_libglobus_adq() {
    
    #prerequisite
    setup_gsoap
    
    echo "setup_libglobus_adq..."
    
    if [ ! -e ${GLOBUS_LOCATION}/lib/libglobus_adq.so ] || ((force_install)); then
        #go back to workbench dir...
        pushd ${globus_workdir} #>& /dev/null
	local lastdir=`pwd`
	cd ${globus_workdir}
        #----------
        #Our globus stuff for callouts
        #----------
        local libglobus_adq_file=${libglobus_adq_dist_url##*/}
        checked_get ${libglobus_adq_file} ${libglobus_adq_dist_url} $((force_install))
        (( $? > 1 )) && popd && checked_done 1
        tar -xzf  ${libglobus_adq_file}

        #-----
        #It turns out that when you untar the $libglobus_adq_file the
        #top level directory is "libglobus_adq" - notice there is no
        #version number extension at the end. So it is not sufficient
        #to just remove the compression suffix ".tar.gz" but also to
        #remove the version value to get down to libglobus_adq.  Yes,
        #since I know the ultimate name I could just use it, but that
        #ain't flexible or sexy... right? ;-)
        local libglobus_adq_dir=$(echo ${libglobus_adq_file} | awk 'gsub(/('$compress_extensions')/,"")')
        local libglobus_adq_dir=$(readlink -f ${libglobus_adq_dir})
        ((DEBUG)) && echo "libglobus_adq_dir = ${libglobus_adq_dir}"
        #-----

	local lastdir2=`pwd`
        cd ${libglobus_adq_dir}
        sh build.sh 
        [ -n "${GLOBUS_LOCATION}" ] && rm -rvf ${GLOBUS_LOCATION}/lib/libglobus_adq.so*
        cp -v libglobus_adq.so.0.0.0 $GLOBUS_LOCATION/lib
        pushd $GLOBUS_LOCATION/lib
        ln -s libglobus_adq.so.0.0.0 libglobus_adq.so.0
        ln -s libglobus_adq.so.0.0.0 libglobus_adq.so
        popd >& /dev/null
	cd ${lastdir2}
        #----------
        popd >& /dev/null
	cd ${lastdir}
    else
        echo "Detected a libglobus_adq installation... will not re-install libglobus_adq"       
    fi
    
    return 0
}

setup_gridftp_metrics_logging() {

    echo -n "Checking for esg_usage_parser >= ${usage_parser_version} "
    check_version ${esg_tools_dir}/esg_usage_parser ${usage_parser_version}
    [ $? == 0 ] && (( ! force_install )) && echo " [OK]" && return 0

    echo "GridFTP Usage - Configuration..."
    echo
    echo "*******************************"
    echo "Setting up GridFTP Usage..."
    echo "*******************************"
    echo

    mkdir -p ${esg_backup_dir}  && \
        mkdir -p ${esg_tools_dir} && \
        mkdir -p ${esg_log_dir} && \
        mkdir -p ${esg_config_dir}
    [ $? != 0 ] && echo "ERROR: could not create ${esg_root_dir} dir and/or subdirectories" && checked_done 1

    yum -y install perl-DBD-Pg
    [ $? == 0 ] && echo "Successfully intalled perl DBD" || echo "ERROR: Was not able to install perl DBD"

    local esg_usage_parser_dist_file=${esg_usage_parser_dist_url##*/}
    #strip off "-##-##-####.tar.bz2 at the end
    esg_usage_parser_dist_dir=${globus_workdir}/$(echo ${esg_usage_parser_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')
    esg_usage_parser_dist_dir=${esg_usage_parser_dist_dir%-*}

    #NOTE: Things are done this way because the distribution does not create its own top level directory (grrrr)
    mkdir -p ${esg_usage_parser_dist_dir}
    [ $? != 0 ] && checked_done 1
    chmod a+rw ${globus_workdir}
    pushd ${esg_usage_parser_dist_dir} >& /dev/null

    echo "Downloading Globus GridFTP Usage Parser from ${esg_usage_parser_dist_url}"
    wget -O ${esg_usage_parser_dist_file} ${esg_usage_parser_dist_url}

    # expand it and go from there....
    if [ -e ${esg_usage_parser_dist_file} ]; then
        pwd
        tar xvjf ${esg_usage_parser_dist_file}
    fi

    #pushd esg-usage-parser
    cp -v esg_usage_parser ${esg_tools_dir}
    chmod 755 ${esg_tools_dir}/esg_usage_parser
    popd >& /dev/null
}

#http://www.ci.uchicago.edu/wiki/bin/view/ESGProject/ESGUsageParser
#http://rainbow.llnl.gov/dist/esg-node/esg-node

config_gridftp_metrics_logging() {
    echo -n "Configuring gridftp metrics collection..."

    local config_type=${1-:"end-user"}

    if [ "${config_type}" = "end-user" ]; then
        echo "for ${config_type}"
        mkdir -p ${gridftp_server_usage_config%/*}
        #generate config file for gridftp server
        printf "DBNAME=${node_db_name}
DBHOST=${postgress_host}
DBPORT=${postgress_port}
DBUSER=${postgress_user}
DBPASS=${pg_sys_acct_passwd}
USAGEFILE=${gridftp_server_usage_log}
TMPFILE=/tmp/__up_tmpfile
DEBUG=0
NODBWRITE=0\n" > ${gridftp_server_usage_config}

        local cronscript=${gridftp_server_usage_config%.*}.cron
        printf "5 0,12 * * * ESG_USAGE_PARSER_CONF=${gridftp_server_usage_config} ${esg_tools_dir}/esg_usage_parser \n" > ${cronscript}
        
        #start crontab
        start_gridftp_usage_parsing ${cronscript} ${config_type}
        unset cronscript
        
    elif [ "${config_type}" = "bdm" ]; then
        echo "for ${config_type}"
        mkdir -p ${gridftp_bdm_server_usage_config%/*}
        #generate config file for bdm (if enabled)
        printf "DBNAME=${node_db_name}
DBHOST=${postgress_host}
DBPORT=${postgress_port}
DBUSER=${postgress_user}
DBPASS=${pg_sys_acct_passwd}
USAGEFILE=${gridftp_bdm_server_usage_log}
TMPFILE=/tmp/__up_tmpfile
DEBUG=0
NODBWRITE=0\n" > ${gridftp_bdm_server_usage_config}
        
        cronscript=${gridftp_bdm_server_usage_config%.*}.cron
        printf "35 0,12 * * * ESG_USAGE_PARSER_CONF=${gridftp_bdm_server_usage_config} ${esg_tools_dir}/esg_usage_parser \n" > ${cronscript}
        
        #start crontab
        start_gridftp_usage_parsing ${cronscript} ${config_type}
        unset cronscript
    else
        echo
        echo "Unknown metrics configuration type [${config_type}]"
        return 1
    fi
    return 0
}

#Puts in crontab entries for running the gridftp usage parsing code periodically
start_gridftp_usage_parsing() {
    local cronscript=$1
    local config_type=${2:-"<unknown type>"}
    
    [ -z "${cronscript}" ] && "No cronscript [${cronscript}] specified" && return 1

    # setup crontab here
    if [ -e ${cronscript} ]; then
        pushd ${cronscript%/*} >& /dev/null
        cat ${cronscript} >> ${esg_crontab}
        [ $? != 0 ] && echo " ERROR: could not add cronfile [${cronscript}] to ${esg_crontab}" && popd >& /dev/null && return 3
        echo "Adding ${cronscript} to ${esg_crontab} file"
        
        local username=$(/usr/bin/getent passwd ${installer_uid} | awk -F: {'print $1'})
        if [ -n "${username}" ] ; then

                    echo -n "Installing crontab entry... for ${username} running ${cronscript} via ${esg_crontab} "
            
            local backup_cron="$esg_backup_dir/oldcron_${username}_$(date +%y%m%d_%k%M%S)"
            local start_mark="# ESGF cronjob BEGIN ###"
            local end_mark="# ESGF cronjob END ###"
            local current_cron=$(crontab -u $username -l)
            local simple_update
            echo "$current_cron" | grep -q "$start_mark" && simple_update=1
            if ((simple_update)); then
                #we know what we are doing. Replace the content within the markings
                new_cron=$(echo "$current_cron" |  sed "/^$start_mark\$/,/^$end_mark\$/ {
                    /^$start_mark\$/ {
                        r $esg_crontab
                        ba}
                 /^$end_mark\$/ba
                 d
                 :a}" | awk '!x[$0]++')
            else
                # try to figure out if we have alread touched this or it's the very first time.
                cleaned_cron=$(echo "$current_cron" | sed -e '/esg_usage_parser/ d')
                new_cron=$(echo "$cleaned_cron"; echo $start_mark; cat $esg_crontab; echo $end_mark)
                
                #after this always ask the user if it's ok.
            fi
            
            #ok. Compare what we did to that what we have
             if [[ "$new_cron" != "$current_cron" ]]; then
                echo "Current crontab for user ($installer_user):"; echo "$current_cron"
                echo "will be updated to:"; echo "$new_cron"
                read -p "Is this ok ? [Y/n]" answ
                if [[ -z "$answ" || "$answ" == y || "$answ" == Y ]]; then
                    echo "$current_cron" > $backup_cron
                    crontab -u $username <(echo "$new_cron" | awk '!x[$0]++')
                     local ret=$?
                fi
            fi
            [ $ret == 0 ] && echo "[OK]" || "[FAILED]"
            return $ret
        else
            echo "Crontab for user: [${username}] - to run script: [${cronscript}] is already present!"
            $(/usr/bin/crontab -u ${username} -l | grep ${cronscript##*/})
        fi
        popd >& /dev/null
    else
        echo " *WARNING: No Crontab File Found For ${config_type} Usage parsing"
        return 2
    fi
    return 0
}

setup_gridftp_jail() {
    echo
    echo
    echo "*******************************"
    echo "Setting up GridFTP... chroot jail"
    echo "*******************************"
    echo

    [ -z "${gridftp_chroot_jail}" ] && echo "setup_gridftp_jail() rendered impotent \$gridftp_chroot_jail not set" && return 2
    [ ! -e ${gridftp_chroot_jail}  ] && echo "${gridftp_chroot_jail} does not exist, making it..." && mkdir -p ${gridftp_chroot_jail}

    echo "Creating chroot jail @ ${gridftp_chroot_jail}"
    ${globus_location}/sbin/globus-gridftp-server-setup-chroot -r ${gridftp_chroot_jail}

    [ ! -e "${ESGINI}" ] && echo "Cannot find ESGINI=[${ESGINI}] file that describes data dir location" && return 1
    echo "Reading ESGINI=[${ESGINI}] for thredds_dataset_roots to mount..."

    while read mount_name mount_dir; do
        [ -z ${mount_name} ] && debug_print "blank entry: [${mount_name}]" && continue;
        [ -z ${mount_dir} ] && debug_print "blank dir entry: [${mount_dir}]" && continue;
        echo "mounting [${mount_dir}] into chroot jail [${gridftp_chroot_jail}/] as [${mount_name##*/}]"
        if [ -z "${mount_name}" ] || [ -z "${mount_dir}" ] ; then
            echo 'WARNING: Was not able to find the mount directory [${mount_dir}] or mount name [${mount_name}] to use for proper chroot gridftp installation!!!'
            return 999
        fi
        local chroot_mount=($(mount -l | grep ^${mount_dir}' ' | awk '{print $3}' | sort -u))
        if (( ${#chroot_mount[@]} == 0 )); then
            [ ! -e ${gridftp_chroot_jail}/${mount_name##*/} ] && mkdir -p ${gridftp_chroot_jail}/${mount_name##*/}
            ((DEBUG)) && echo "mount --bind ${mount_dir} ${gridftp_chroot_jail}/${mount_name##*/}"
            mount --bind $(readlink -f ${mount_dir}) ${gridftp_chroot_jail}/${mount_name##*/}
        else
            echo "There is already a mount for [${mount_dir}] -> [${chroot_mount}] on this host, NOT re-mounting"
        fi
    done < <(echo "$(python <(curl -s ${esg_dist_url}/utils/pull_key.py) -k thredds_dataset_roots -f ${ESGINI} | awk ' BEGIN {FS="|"} { if ($0 !~ /^[[:space:]]*#/) {print $1" "$2}}')")
    return $?
}

post_gridftp_jail_setup() {
    #Write our trimmed version of /etc/password in the chroot location 
    [ ! -e ${gridftp_chroot_jail} ] && return 1

    if $(echo "${gridftp_chroot_jail}" | grep "${esg_root_dir}" >& /dev/null); then echo "*"; else (echo "illegal chroot location: ${gridftp_chroot_jail}" && return 1); fi


    echo -n "writing sanitized passwd file to [${gridftp_chroot_jail}/etc/passwd]"
    if [ -e ${gridftp_chroot_jail}/etc/passwd ]; then
        cat > ${gridftp_chroot_jail}/etc/passwd <<EOF
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/dev/null
ftp:x:14:50:FTP User:/var/ftp:/dev/null
globus:x:101:156:Globus System User:/home/globus:/bin/bash
EOF
        echo " [OK]"
    else
        echo " [FAILED]"
    fi

    #Write our trimmed version of /etc/group in the chroot location
    echo -n "writing sanitized group file to [${gridftp_chroot_jail}/etc/group]"
    if [ -e ${gridftp_chroot_jail}/etc/group ]; then
        cat > ${gridftp_chroot_jail}/etc/group <<EOF
root:x:0:root
bin:x:1:root,bin,daemon
ftp:x:50:
globus:x:156:
EOF
        echo " [OK]"
    else
        echo " [FAILED]"
    fi
}

# (OLD WAY) http://www.ci.uchicago.edu/wiki/bin/view/ESGProject/GridFTPServerWithTokenAuthorizationModuleConfig
# http://www.ci.uchicago.edu/wiki/bin/view/ESGProject/EnhancedEndUserDownloadGridFTPModule
config_gridftp_server() {
    
    echo "GridFTP - Configuration..."
    echo
    echo "*******************************"
    echo "Setting up GridFTP..."
    echo "*******************************"
    echo

    local dosetup
    local default_val="Y"
#    if [ -x ${globus_install_dir}/sbin/globus-gridftp-server ]; then
#        echo "Detected an existing Globus GridFTP Server installation..."
        
        write_as_property gridftp_server_port

#        check_version ${globus_install_dir}/sbin/globus-gridftp-server ${gridftp_server_version}
#        [ $? == 0 ] && default_val="n" && echo "GridFTP version is sufficiently current, upgrade not required"
#
#        read -p "Do you want to continue with GridFTP ESG Configuration? $([ "$default_val" = "Y" ] && echo "[Y/n]" || echo "[y/N]") " dosetup
#        [ -z "${dosetup}" ] && dosetup=$default_val

#        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ] ; then 
#            echo "Skipping Globus installation and setup - will assume Globus is setup properly"
#            return 0
#        fi
#        echo
#    fi

    #TODO: Decide how to maintain semantic integrity
    [ -z ${globus_sys_acct} ] && echo " ERROR: globus_sys_acct=[${globus_sys_acct}] must be set" && checked_done 1
    
    mkdir -p ${globus_workdir}
    [ $? != 0 ] && checked_done 1
    chmod a+rw ${globus_workdir}
    pushd ${globus_workdir} >& /dev/null

    local gridftp_dist_file=${gridftp_authz_esgsaml_dist_url##*/}
    #strip off "-##-##-####.tar.gz at the end, i.e. last 18 chars, to get untarred dir name
    #(TODO - use a regex here instead of counting characters)
    gridftp_authz_esgsaml_dist_dir=$(echo ${gridftp_dist_file} | awk '{print substr($1,1,length($1)-18)}')
    

    #Check to see if we have a gridftp distribution directory
    if [ ! -e ${gridftp_authz_esgsaml_dist_dir} ]; then
        echo "Don't see gridftp distribution dir ${gridftp_authz_esgsaml_dist_dir}"
        if [ ! -e ${gridftp_dist_file} ]; then
            echo "Don't see gridftp distribution file ${gridftp_dist_file} either"
            echo "Downloading Gridftp from ${gridftp_authz_esgsaml_dist_url}"
            checked_get ${gridftp_dist_file} ${gridftp_authz_esgsaml_dist_url} $((force_install))
            (( $? > 1 )) && echo " ERROR: Could not download ${gridftp_authz_esgsaml_dist_url}" && popd && checked_done 1
            tar xvzf ${gridftp_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract ${gridftp_authz_esgsaml_dist_url}" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it and go from there....
    if [ -e ${gridftp_dist_file} ] && [ ! -e ${gridftp_authz_esgsaml_dist_dir} ]; then
        tar xvzf ${gridftp_dist_file}
    fi
    
    #install prerequisites before we go any further
    setup_libglobus_adq
    
    pushd ${gridftp_authz_esgsaml_dist_dir}/source >& /dev/null
    cd ${gridftp_authz_esgsaml_dist_dir}/source
    if [ -e ${globus_workdir}/libglobus_adq-${adq_version} ]; then 
        ln -v -s ${globus_workdir}/libglobus_adq-${adq_version} libglobus_adq
    else
        echo "To properly configure this gridftp server libglobus_adq must first be setup and configured!" && checked_done 1
    fi

    ./bootstrap 
    [ $? != 0 ] && echo " ERROR: could not perform bootstrap" && checked_done 1
    
    ((force_install)) && (echo "Cleaning the source tree.. $(pwd) " && gmake clean && echo "[OK]" || echo "[FAIL]")
    echo "./configure --prefix=${globus_install_dir} --with-flavor=${globus_flavor} --with-globus-tcp-port-range=${gridftp_server_port_range}"
    if ./configure --prefix=${globus_install_dir} --with-flavor=${globus_flavor} --with-globus-tcp-port-range=${gridftp_server_port_range}\
        && gmake \
        && gmake install
    then
        echo "Successfully Configured and Built Gridftp in: ${globus_install_dir}"
    else
        echo " ERROR: Could NOT successfully build GRIDFTP!"
        popd >& /dev/null
        checked_done 1
    fi
    cd ..

    mkdir -p /etc/grid-security
    
    # generate the /etc/grid-security/gsi-authz.conf
    echo "GLOBUS_GSI_AUTHZ_SYSTEM_INIT libglobus_authz_esgsaml_callout_${globus_flavor}.so authz_esgsaml_system_init_callout" > /etc/grid-security/gsi-authz.conf
    echo "GLOBUS_GSI_AUTHZ_SYSTEM_DESTROY libglobus_authz_esgsaml_callout_${globus_flavor}.so authz_esgsaml_system_destroy" >> /etc/grid-security/gsi-authz.conf
    echo "GLOBUS_GSI_AUTHZ_HANDLE_INIT libglobus_authz_esgsaml_callout_${globus_flavor}.so authz_esgsaml_handle_init_callout" >> /etc/grid-security/gsi-authz.conf
    echo "GLOBUS_GSI_AUTHORIZE_ASYNC libglobus_authz_esgsaml_callout_${globus_flavor}.so authz_esgsaml_authorize_async_callout" >> /etc/grid-security/gsi-authz.conf
    echo "GLOBUS_GSI_AUTHZ_CANCEL libglobus_authz_esgsaml_callout_${globus_flavor}.so authz_esgsaml_cancel_callout" >> /etc/grid-security/gsi-authz.conf
    echo "GLOBUS_GSI_AUTHZ_HANDLE_DESTROY libglobus_authz_esgsaml_callout_${globus_flavor}.so authz_esgsaml_handle_destroy_callout" >> /etc/grid-security/gsi-authz.conf
    echo "GLOBUS_GSI_GET_AUTHORIZATION_IDENTITY libglobus_authz_esgsaml_callout_${globus_flavor}.so globus_gsi_authz_esgsaml_get_authorization_identity_callout" >> /etc/grid-security/gsi-authz.conf
    
    # generate ESG SAML Auth config file
    write_esgsaml_auth_conf

    create_globus_account

    #TODO: find out how to set this "dn" appropriately...
    # sample wildcard dn (an entry from the pcmdi server)
    # Ex: "^/O=Grid/OU=GlobusTest/OU=simpleCA-pcmdi3.llnl.gov/.*$" neillm
    # basically certs that have this CA subject line are accepted and squashed to globus_sys_acct
    #dnode_root_dn_wildcard="^/O=Grid/OU=GlobusTest/OU=simpleCA-${myproxy_endpoint}/.*\$"
    dnode_root_dn_wildcard='^.*$'
    ${globus_location}/sbin/grid-mapfile-add-entry -dn ${dnode_root_dn_wildcard} -ln ${globus_sys_acct}

    chown -R ${globus_sys_acct} ${globus_location}
    chgrp -R ${globus_sys_acct_group} ${globus_location}

    popd >& /dev/null
    checked_done 0
}

#By making this a separate function it may be called directly in the
#event that the gateway_service_root needs to be repointed. (another Estani gem :-))
write_esgsaml_auth_conf() {
    echo "AUTHSERVICE=https://${myproxy_endpoint:-${esgf_idp_peer}}/esg-orp/saml/soap/secure/authorizationService.htm" > /etc/grid-security/esgsaml_auth.conf
    echo 
    echo "---------esgsaml_auth.conf---------"
    cat /etc/grid-security/esgsaml_auth.conf
    echo "---------------------------------"
    echo     
    return 0
}


# http://www.ci.uchicago.edu/wiki/bin/view/ESGProject/BDMSecurityDatanodeAdminGuide
config_bdm_gridftp_server() {
    echo "GridFTP - Configuration... for Bulk Data Mover (BDM)"
    echo
    echo "*******************************"
    echo "Setting up GridFTP... (BDM Configuration)"
    echo "*******************************"
    echo

    local dosetup
    local default_val="Y"
#    if [ -x ${globus_install_dir}/sbin/globus-gridftp-server ]; then
#        echo "Detected an existing Globus BDM GridFTP Server installation..."
#        echo "$(${globus_install_dir}/sbin/globus-gridftp-server --version)"

        write_as_property gridftp_bdm_server_port

#        check_version ${globus_install_dir}/sbin/globus-gridftp-server ${gridftp_server_version}
#        [ $? == 0 ] && default_val="n" && echo "GridFTP version is sufficiently current, upgrade not required"
#        
#        read -p "Do you want to continue with BDM GridFTP ESG Configuration? $([ "$default_val" = "Y" ] && echo "[Y/n]" || echo "[y/N]") " dosetup
#        [ -z "${dosetup}" ] && dosetup=$default_val
#        
#        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ] ; then 
#            echo "Skipping Globus installation and setup - will assume Globus is setup properly"
#            return 0
#        fi
#        echo
#    fi

    #TODO: Decide how to maintain semantic integrity
    [ -z ${globus_sys_acct} ] && echo " ERROR: globus_sys_acct=[${globus_sys_acct}] must be set" && checked_done 1
    
    mkdir -p $globus_workdir
    [ $? != 0 ] && checked_done 1
    chmod a+rw $globus_workdir
    pushd $globus_workdir >& /dev/null

    #-----------

    local gridftp_dist_file=${gridftp_bdm_dist_url##*/}
    #strip off "-##-##-####.tar.gz at the end, i.e. last 18 chars, to get untarred dir name
    #(TODO - use a regex here instead of counting characters)
    gridftp_bdm_dist_dir=$(echo ${gridftp_dist_file} | awk '{print substr($1,1,length($1)-18)}')
    
    #Check to see if we have a gridftp distribution directory
    if [ ! -e ${gridftp_bdm_dist_dir} ]; then
        echo "Don't see gridftp distribution dir ${gridftp_bdm_dist_dir}"
        if [ ! -e ${gridftp_dist_file} ]; then
            echo "Don't see gridftp distribution file ${gridftp_dist_file} either"
            echo "Downloading Gridftp from ${gridftp_bdm_dist_url}"
            checked_get ${gridftp_dist_file} ${gridftp_bdm_dist_url} $((force_install))
            (( $? > 1 )) && echo " ERROR: Could not download Gridftp:${gridftp_dist_file}" && popd && checked_done 1
            tar xvzf ${gridftp_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract Gridftp: ${gridftp_dist_file}" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it and go from there....
    if [ -e ${gridftp_dist_file} ] && [ ! -e ${gridftp_bdm_dist_dir} ]; then
        tar xvzf ${gridftp_dist_file}
    fi

    pushd ${gridftp_bdm_dist_dir}/source >& /dev/null
    lastdir=`pwd`
    cd ${gridftp_bdm_dist_dir}/source
    ./bootstrap 
    [ $? != 0 ] && echo " ERROR: could not perform bootstrap" && checked_done 1

    ((force_install)) && (echo "Cleaning the source tree.. $(pwd) " && gmake clean && echo "[OK]" || echo "[FAIL]")
    echo "./configure --prefix=${globus_install_dir} --with-flavor=${globus_flavor} --with-globus-tcp-port-range=${gridftp_bdm_server_port_range}"
    if ./configure --prefix=${globus_install_dir} --with-flavor=${globus_flavor} --with-globus-tcp-port-range=${gridftp_bdm_server_port_range}\
        && gmake \
        && gmake install
    then
        echo "Successfully Configured and Built Gridftp in: ${globus_install_dir}"
    else
        echo " ERROR: Could NOT successfully build GRIDFTP!"
        popd >& /dev/null
	cd ${lastdir}
        checked_done 1
    fi

    # generate /etc/grid-security/gsi-authz-bdm.conf
    [ ! -d /etc/grid-security ] && echo "WARNING: Could not find directory /etc/grid-security, making it..." && mkdir -p /etc/grid-security
    echo "globus_mapping libglobus_authz_bdm_callout_${globus_flavor}.so globus_gsi_authz_bdm_gridmap_callout" > /etc/grid-security/gsi-authz-bdm.conf
    echo 
    echo "---------gsi-authz-bdm.conf---------"
    cat /etc/grid-security/gsi-authz-bdm.conf
    echo "---------------------------------"
    echo 

    # generate /etc/grid-security/esg_gridmap_assist.conf
    [ ! -d /etc/grid-security ] && mkdir -p /etc/grid-security
    echo "attribute=group_BDM_role_publisher" > /etc/grid-security/esg_gridmap_assist.conf
    echo "localAccount=${globus_sys_acct}" >> /etc/grid-security/esg_gridmap_assist.conf
    echo 
    echo "---------esg_gridmap_assist.conf---------"
    cat /etc/grid-security/esg_gridmap_assist.conf
    echo "---------------------------------"
    echo 

    chown -R ${globus_sys_acct} ${globus_location}
    chgrp -R ${globus_sys_acct_group} ${globus_location}

    popd >& /dev/null
    cd ${lastdir}
    checked_done 0
    write_as_property gridftp.service.type "Replication"
}

test_auth_service() {
    local installer_home=${installer_home:-${ESG_USER_HOME:-/usr/local/src/esgf}}
    echo -n "Testing authorization service on ${esgf_host} ... "
    ! ${installer_home}/workbench/esg/extra/globus/libglobus_adq-0.9.1/libglobus_adq_client https://${esgf_host}/esg-orp/saml/soap/secure/authorizationService.htm https://${esgf_host}/esgf-idp/openid/rootAdmin gsiftp://${esgf_host}:${gridftp_server_port}//esg_dataroot/test/sftlf.nc | grep -q 'NOT PERMIT' >& /dev/null
    local ret=$?
    [ ${ret} == 0 ] && echo "[OK]" || echo "[FAIL]"
    return ${ret}
}

test_gridftp_server() {
    local ret=0
    local tmpdestfile
    debug_print "test_gridftp_server: [$@]"

    local personal_credential_repo="$HOME/.globus"

    mkdir -p ${personal_credential_repo}
    chown -R ${installer_uid}:${installer_gid} ${personal_credential_repo}

    rm -rf ${personal_credential_repo}/esgf_credentials >& /dev/null
    local _X509_CERT_DIR=${personal_credential_repo}/esgf_credentials
    local _X509_USER_KEY=${personal_credential_repo}/esgf_credentials
    local _X509_USER_CERT=${personal_credential_repo}/esgf_credentials

    while [ -n "$1" ]; do
        case $1 in
            end-user)
                echo "$globus_location/bin/myproxy-logon -s $myproxy_endpoint -l rootAdmin -p $myproxy_port -T"
                X509_CERT_DIR=${_X509_CERT_DIR} \
                    X509_USER_KEY=${_X509_USER_KEY} \
                    X509_USER_CERT=${_X509_USER_CERT} \
                    $globus_location/bin/myproxy-logon -s $myproxy_endpoint -l rootAdmin -p $myproxy_port -T
                [ $? != 0 ] && echo " ERROR: MyProxy not setup properly.  Unable to execute command." && return 1

                echo -n "GridFTP - End-User Test... [$1]"
                tmpdestfile=$(mktemp)
                X509_CERT_DIR=${_X509_CERT_DIR} \
                    X509_USER_KEY=${_X509_USER_KEY} \
                    X509_USER_CERT=${_X509_USER_CERT} \
                    ${globus_location}/bin/globus-url-copy gsiftp://${esgf_host:-localhost}:${gridftp_server_port}/esg_dataroot/test/sftlf.nc ${tmpdestfile} && \
                    diff <(echo $(md5sum ${tmpdestfile} | awk '{print $1}')) <(echo $(md5sum /esg/gridftp_root/esg_dataroot/test/sftlf.nc | awk '{print $1}')) && \
                    rm -f ${tmpdestfile} && echo "[OK]" || ( echo "[FAIL]" && ((ret++)) )
                ;;
            bdm)
                echo -n "GridFTP - BDM Test... [$1]"
                tmpdestfile=$(mktemp)
                ${globus_location}/bin/globus-url-copy gsiftp://${esgf_host:-localhost}:${gridftp_bdm_server_port}/esg_dataroot/test/sftlf.nc ${tmpdestfile} && \
                    diff <(echo $(md5sum ${tmpdestfile} | awk '{print $1}')) <(echo $(md5sum /esg/gridftp_root/esg_dataroot/test/sftlf.nc | awk '{print $1}')) && \
                    rm -f ${tmpdestfile} && echo "[OK]" || ( echo "[FAIL]" && ((ret++)) )
                ;;
            *)
                [ -n "$1" ] && echo "unknown parameter [$1]"
                break
                ;;
        esac
        shift
    done
    return ${ret}
}

configure_esgf_publisher_for_gridftp() {
    echo -n " configuring publisher to use this GridFTP server... "
    if [ -e ${publisher_home}/${publisher_config} ]; then
        cp ${publisher_home}/${publisher_config}{,.bak}
        sed -i 's#\(gsiftp://\)\([^:]*\):\([^/].*\)/#\1'${esgf_gridftp_host:-${esgf_host}}':'${gridftp_server_port}'/#' ${publisher_home}/${publisher_config}
        echo "[OK]"
        return 0
    fi
    echo "[FAIL]"
    return 1
}

#Could takes the arg(s): "bdm" | "end-user"
#see caller start_globus_services() above.
#returns true  (0) if this function actively started the process
#returns false (1) if this function did not have to start the process since already running
start_gridftp_server() {
    local global_x509_cert_dir=${global_x509_cert_dir:-${X509_CERT_DIR:-"/etc/grid-security/certificates"}}
    local ret=0
    echo " GridFTP - Starting server... $*"
    #TODO: Does it matter if root starts the server vs the globus_sys_acct ??? Neill?
    #      Is there a difference between who starts the server and who the server
    #      xfrs file as?
    write_esgsaml_auth_conf
    setup_gridftp_jail
    post_gridftp_jail_setup

    echo -n " syncing local certificates into chroot jail... "
    [ -n "${gridftp_chroot_jail}" ] && [ "${gridftp_chroot_jail}" != "/" ] && [ -e "${gridftp_chroot_jail}/etc/grid-security/certificates" ] && \
        rm -rf ${gridftp_chroot_jail}/etc/grid-security/certificates && \
        mkdir -p ${gridftp_chroot_jail}/etc/grid-security && \
        (cd /etc/grid-security; tar czpf - certificates) | tar xzpf - -C ${gridftp_chroot_jail}/etc/grid-security
    [ $? == 0 ] && echo "[OK]" || echo "[FAIL]"

    configure_esgf_publisher_for_gridftp
    
    pushd ${globus_location}/sbin >& /dev/null

    #disable_command_list="-disable-command-list APPE,DELE,ESTO,MKD,RMD,RNFR,RNTO,RDEL,STOR,STOU,XMKD,XRMD,CHMOD"
    disable_command_list=""

    while [ -n "$1" ]; do
        case $1 in

            bdm)
                if ! check_gridftp_process ${gridftp_bdm_server_port} && ret=0 ; then
                    echo " *Launching BDM configured GridFTP server on port: ${gridftp_bdm_server_port} : pr ${gridftp_bdm_server_port_range} : sr ${gridftp_bdm_server_source_range}"
                    ((DEBUG)) && echo "X509_CERT_DIR=${global_x509_cert_dir} \
                GLOBUS_TCP_PORT_RANGE=${gridftp_bdm_server_port_range} \
                GLOBUS_TCP_SOURCE_RANGE=${gridftp_bdm_server_source_range} \
                GSI_AUTHZ_CONF=/etc/grid-security/gsi-authz-bdm.conf \
                GLOBUS_USAGE_DEBUG=MESSAGES,${gridftp_bdm_server_usage_log} \
                ${globus_location}/sbin/globus-gridftp-server ${disable_command_list} -p ${gridftp_bdm_server_port} -chroot-path ${gridftp_chroot_jail} -usage-stats-id ${gridftp_bdm_server_port} -usage-stats-target localhost:0\!all -acl customgsiauthzinterface -no-cas &"

                    X509_CERT_DIR=${global_x509_cert_dir} \
                        GLOBUS_TCP_PORT_RANGE=${gridftp_bdm_server_port_range} \
                        GLOBUS_TCP_SOURCE_RANGE=${gridftp_bdm_server_source_range} \
                        GSI_AUTHZ_CONF=/etc/grid-security/gsi-authz-bdm.conf \
                        GLOBUS_USAGE_DEBUG=MESSAGES,${gridftp_bdm_server_usage_log} \
                        ${globus_location}/sbin/globus-gridftp-server ${disable_command_list} -p ${gridftp_bdm_server_port} -chroot-path ${gridftp_chroot_jail} -usage-stats-id ${gridftp_bdm_server_port} -usage-stats-target localhost:0\!all -acl customgsiauthzinterface -no-cas &
                    ret=$?
                    ((ret == 0)) && echo " please wait..." && sleep 1
                fi
                ;;

            end-user)
                if ! check_gridftp_process ${gridftp_server_port} && ret=0 ; then
                    echo " *Launching end-user configured GridFTP server on port: ${gridftp_server_port} : pr ${gridftp_server_port_range} : sr ${gridftp_server_source_range}"
                    ((DEBUG)) && echo "X509_CERT_DIR=${global_x509_cert_dir} \
                GLOBUS_TCP_PORT_RANGE=${gridftp_server_port_range} \
                GLOBUS_TCP_SOURCE_RANGE=${gridftp_server_source_range} \
                GSI_AUTHZ_CONF=/etc/grid-security/gsi-authz.conf \
                GLOBUS_USAGE_DEBUG=MESSAGES,${gridftp_server_usage_log} \
                ${globus_location}/sbin/globus-gridftp-server ${disable_command_list} -p ${gridftp_server_port} -chroot-path ${gridftp_chroot_jail} -usage-stats-id ${gridftp_server_port} -usage-stats-target localhost:0\!all -acl customgsiauthzinterface -no-cas &"

                    X509_CERT_DIR=${global_x509_cert_dir} \
                        GLOBUS_TCP_PORT_RANGE=${gridftp_server_port_range} \
                        GLOBUS_TCP_SOURCE_RANGE=${gridftp_server_source_range} \
                        GSI_AUTHZ_CONF=/etc/grid-security/gsi-authz.conf \
                        GLOBUS_USAGE_DEBUG=MESSAGES,${gridftp_server_usage_log} \
                        ${globus_location}/sbin/globus-gridftp-server ${disable_command_list} -p ${gridftp_server_port} -chroot-path ${gridftp_chroot_jail} -usage-stats-id ${gridftp_server_port} -usage-stats-target localhost:0\!all -acl customgsiauthzinterface -no-cas &
                    ret=$?
                    ((ret == 0)) && echo " please wait..." && sleep 1
                fi
                ;;
        esac
        shift
    done
    popd >& /dev/null
    return ${ret}
}


#arg (1) - server port number
stop_gridftp_server() {

    if check_gridftp_process
    then 
        echo "Detected Running globus-gridftp-server..."
    else
        echo "No Globus GridFTP Process Currently Running..." && return 1
    fi

    killall globus-gridftp-server && echo " [OK] " || echo " [FAIL] "
    return $?
}

#This function "succeeds" (is true -> returns 0)  if there *are* running processes found
check_gridftp_process() {
    local port="$1"
    val=$(ps -elf | grep globus-gridftp-server | grep -v grep | grep "${port}" | awk ' END { print NR }')
    [ $(($val > 0 )) == 1 ] && echo " gridftp-server process is running on port [${port}]..." && return 0
    return 1
}


#--------------------------------------------------------------
# MY PROXY
#--------------------------------------------------------------

upgrade_myproxy_server() {

    echo -n "Checking for globus ${globus_version}"
    check_version ${globus_location}/bin/globus-version ${globus_version}
    [ $? == 0 ] && echo " [OK]" || checked_done 1

    echo -n "Checking for myproxy-server ${myproxy_version}"
    check_version ${globus_location}/sbin/myproxy-server ${myproxy_version}
    [ $? == 0 ] && (( ! force_install )) && echo " [OK]" && return 0
    echo "MyProxy - Upgrading..."
    pushd ${globus_workdir} >& /dev/null
    myproxy_dist_file=${myproxy_dist_url##*/}

    #pesky 0 file size checking.  
    #This happens if the site is down, etc...
    #(It may be a wget thing... NOTE: I should look if curl does the same)
    if [ -e ${myproxy_dist_file} ]; then
        ls -l ${myproxy_dist_file}
        local size=$(stat -c%s ${myproxy_dist_file})
        (( size == 0 )) && rm -v ${myproxy_dist_file}
    fi

    if [ ! -e ${myproxy_dist_file} ]; then
        wget -O ${myproxy_dist_file} ${myproxy_dist_url}
        [ $? != 0 ] && echo "Could not download ${myproxy_dist_url}, please check that the endpoint is available" && checked_done 1
    fi

    /etc/init.d/myproxy stop
    ${globus_location}/sbin/gpt-build -force -verbose ${myproxy_dist_file} ${globus_flavor}
    ${globus_location}/sbin/gpt-postinstall
    ${globus_location}/sbin/myproxy-server --version
    echo "--------"
    echo
    popd >& /dev/null
    checked_done 0
}

#--------------------------------------------------------------
# CERTIFICATE MANAGMENT FUNCTIONS
#--------------------------------------------------------------
generate_globus_key_and_csr() {
    debug_print "generate_globus_key_and_csr( $@ )"
    echo "Generating (globus) private host key... "
    local gendir=${1:-gen-self-cert}
    mkdir -p ${gendir}
    rm -rf ${gendir}/hostkey*.pem
    rm -rf ${gendir}/hostcert*.pem

    local my_cert=/etc/grid-security/hostcert.pem
    local my_key=/etc/grid-security/hostkey.pem
    local my_csr=/etc/grid-security/${esgf_host:-$(hostname --fqdn)}-esg-node-globus.csr

    #backup the last cert
    mv -v ${my_cert}{,.bak}
    #----------------------(command)----------------------------------
    echo "Generating (globus) Certificate Signing Request (csr)... "
    debug_print "$GLOBUS_LOCATION/bin/grid-cert-request -host ${esgf_host:-$(hostname --fqdn)} -dir ${gendir} -force"
    $GLOBUS_LOCATION/bin/grid-cert-request -host ${esgf_host:-$(hostname --fqdn)} -dir ${gendir} -force &> /dev/null
    #-----------------------------------------------------------------
    [ $? != 0 ] && echo "oops" && return 1

    echo "Placing cert and request... "
    [ -e /etc/grid-security/hostkey.pem ] && mv /etc/grid-security/hostkey.pem /etc/grid-security/hostkey.pem.bak

    local size=$(stat -c%s ${gendir}/hostkey.pem)
    if (( size != 0 )); then
        cp -f -v ${gendir}/hostkey.pem /etc/grid-security/hostkey.pem
    else
        printf "ERROR: Generated ${gendir}/hostkey.pem file is [${size}]bytes\n\n"
        return 1
    fi
    unset size

    size=$(stat -c%s ${gendir}/hostcert_request.pem)
    if (( size != 0 )); then
        cp -f -v ${gendir}/hostcert_request.pem /etc/grid-security/${esgf_host:-$(hostname --fqdn)}-esg-node-globus.csr
    else
        printf "ERROR: Generated ${gendir}/hostcert_request.pem file is [${size}]bytes\n\n"
        return 2
    fi
    unset size

    chmod 600 /etc/grid-security/hostkey.pem
    chmod 644 /etc/grid-security/${esgf_host:-$(hostname --fqdn)}-esg-node-globus.csr

    echo -n "Globus CSR Generated [/etc/grid-security/${esgf_host:-$(hostname --fqdn)}-esg-node-globus.csr] "

    #---
    #NOTES: This is how you check that certs belong to eachother... the resulting values must all be the same
    #---
    #openssl req  -noout -modulus -in esgf-node3.llnl.gov-esg-node-globus.csr | openssl md5
    #openssl rsa  -noout -modulus -in hostkey.pem  | openssl md5
    #openssl x509 -noout -modulus -in hostcert.pem | openssl md5
    #---

    local pair_hash=($((openssl req -noout -modulus -in /etc/grid-security/${esgf_host:-$(hostname --fqdn)}-esg-node-globus.csr | openssl md5 ; openssl rsa -noout -modulus -in /etc/grid-security/hostkey.pem | openssl md5) | uniq))
    if (( 1 == ${#pair_hash[@]} )); then
        printf "[OK] (${pair_hash})\n\n"
        printf "Please email the generated csr to esgf-ca@lists.llnl.gov, Thank you\n\n"
    else
        printf "[FAIL]\n\n"
        return 3
    fi

    return 0
}

#Generates certs from this machine's simpleCA keys
generate_self_signed_cert() {
    echo "generate_self_signed_cert( $@ )"
    local gendir=${1:-gen-self-cert}
    mkdir -p ${gendir}
    rm -v -rf ${gendir}/host*.pem

    ! generate_globus_key_and_csr && echo "ERROR: Could not perform generation" && return 1

    local my_cert=/etc/grid-security/hostcert.pem
    local my_key=/etc/grid-security/hostkey.pem
    local my_csr=/etc/grid-security/${esgf_host:-$(hostname --fqdn)}-esg-node-globus.csr
    
    [ ! -e "${my_csr}" ] && echo "ERROR: Must first have a csr file to sign :-(" && return 2
    [ ! -e "${my_key}" ] && echo "ERROR: Must first have a key file to sign :-(" && return 3
    [ -e "${my_cert}" ] && mv -v ${my_cert}{,.bak}

    #------------------------(command)--------------------------------
    echo "$GLOBUS_LOCATION/bin/grid-ca-sign -in ${my_csr} -out ${my_cert}"
    $GLOBUS_LOCATION/bin/grid-ca-sign -in ${my_csr} -out ${my_cert}
    #-----------------------------------------------------------------
    [ $? != 0 ] && echo "ooops" && mv -v ${my_cert}{.bak,} && return 3

    chmod 644 ${my_cert}

    echo "self signed globus key generation is complete..."
    return 0
}

# This function bascially copies and renames the signed cert into the right place.
# It also does the bookkeeping needed in the overall property file to reflect the DN
# arg (optional) -> the signed certificate (.pem) file to be installed
install_globus_keypair() {
    #--------------------------------------------------
    #Install signed globus pem file
    #--------------------------------------------------
    local globus_grid_security_dir=${globus_global_certs_dir%/*}
    if [ -d  ${globus_grid_security_dir} ]; then
        local globus_signed_cert=${1:-${globus_grid_security_dir}/${esgf_host:-$(hostname --fqdn)}-esg-node-globus.pem}
        if [ -e "${globus_signed_cert}" ]; then
            [ -e ${globus_grid_security_dir}/hostcert.pem ] && mv ${globus_grid_security_dir}/hostcert.pem{,.bak}
            mv -v ${globus_signed_cert} ${globus_grid_security_dir}/hostcert.pem && \
                chmod 644 ${globus_grid_security_dir}/hostcert.pem && \
                openssl x509 -noout -text -in ${globus_grid_security_dir}/hostcert.pem
        else
            echo "ERROR: Could not find certificate ${globus_signed_cert}"
            exit 5
        fi
    else
        echo "ERROR: Could not locate target globus key location:[${globus_grid_security_dir}]"
        exit 6
    fi

    [ -e "${globus_grid_security_dir}/hostcert.pem" ] && \
        write_as_property node_dn $(extract_openssl_dn ${globus_grid_security_dir}/hostcert.pem) && echo "properly updated [OK]"
    echo
}

globus_check_certificates() {
    debug_print "globus_check_certificates..."
    local my_cert=/etc/grid-security/hostcert.pem
    #do this in a subshell
    (source ${esg_functions_file} && check_cert_expiry_for_files ${my_cert})
}
#--------------------------------------------------------------

# Note: myproxy servers live on gateway machines
# see - http://www.ci.uchicago.edu/wiki/bin/view/ESGProject/MyProxyWithAttributeCalloutConfig
# arg =  "fetch-certs" -- download certificates from dist server |
#       *"gen-certs ----- generate self signed certificates |
#        "keep-certs ---- Do not mess with the host keys you have in place
# arg = *"install" ------ run in install mode [install_mode=1]
#        "update" ------- update the simpleCA [install_mode=0]
config_myproxy_server() {
    
    echo "MyProxy - Configuration... [$@]"
    
    #set initial default values...
    local fetch_certs=0
    local gen_self_certs=1
    local keep_certs=0

    #toggle var install(1)/update(0)
    local install_mode=1

    for arg in $@
    do
        case $arg in
            "fetch-certs")
                fetch_certs=1
                ;;
            "gen-self-certs")
                gen_self_certs=1
                ;;
            "keep-certs")
                keep_certs=1
                ;;
            "install")
                install_mode=1
                ;;
            "update")
                install_mode=0
                ;;
            *)
                printf "

    ERROR: You have entered an invalid argument: [$@]\n

    Usage: 
    function - esg-globus:config_myproxy_server [*gen-self-certs|fetch-certs|keep-certs] [*install|update]
    (* indicates default values if no args are given)

    \n"
                return 1
                ;;
        esac
    done

    #------------------------------------
    #Double check with the user under these conditions
    #------------------------------------

    #You have decided to do an install but an installation is already detected
#    if ((install_mode)) && [ -e ${globus_location}/sbin/myproxy-server ]; then
#        local answer="Y"
#        echo "NOTICE:"
#        echo "   Detected that the myproxy-server is already present!"
#        read -p "   Do you still wish to INSTALL myproxy (and usurp what is present)? [y/N] " answer
#        [ -z "${answer}" ] && answer="N"
#        if [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
#            install_mode=1
#            echo "(${answer})"
#        else
#            install_mode=0
#            echo "(n)"
#        fi
#        unset answer
#    fi

    #You have selected to do an update but the program is not even installed in the first place!
    if ((!install_mode)) && [ ! -e ${globus_location}/sbin/myproxy-server ]; then
        echo "WARNING:"
        echo "   You do not seem to have an existing installation to UPDATE!"
        echo "   Switching to install mode..."
        install_mode=1
    fi

    #You wish to generate self certs, but it seems you already have certs in place (you should use them)
    if ((gen_self_certs)) && [ -f /etc/grid-security/hostkey.pem ] && [ -f /etc/grid-security/hostcert.pem ]; then
        local answer="Y"
        echo "NOTICE:"
        echo "   Detected a keypair already in place "
        read -p "   Do you still wish to (re)GENERATE self signed certs (and usurp what is present)? [y/N] " answer
        [ -z "${answer}" ] && answer="N"
        if [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
            keep_certs=0
            gen_self_certs=1
            fetch_certs=0
            echo "(${answer})"
        else
            keep_certs=1
            gen_self_certs=0
            fetch_certs=0
            echo "(n)"
        fi
        unset answer
    fi


    #todo do selection....
    echo "(install_mode = ${install_mode})"
    echo "(fetch_certs = ${fetch_certs})"
    pushd ${globus_workdir} >& /dev/null
    
    local tfile
    local ca_subject
    local ca_hash
    
    export GPT_LOCATION=${globus_location}
    
    if [ -d ${dot_globus} ]; then
       read -p "Do you wish to install a simple CA? [y/N] " answer
       [ -z "${answer}" ] && answer="N"
    else
       answer="Y"
    fi


    if [ "${answer}" = "Y" ] || [ "${answer}" = "y" ]; then
        #answer="Y"

        #TODO: ZOIKS... this does not work... Next thing to try is to do a
        #while read on the output of setup-simple-ca, and then regexp each
        #line and set if there is a hit and echo lines back5A out to user.
        #I have to leave this now to do other things (10/22/2009).  this
        #is where I should pick up from.  Everything else works! (at least
        #should!)  Throw in a command block and direct the output onf
        #setup-simple-ca to it. Throw the while read into the command
        #block.
            
        # #########################################
        # #Grab the "CA Subject" by scraping the output of setup-simple-ca output
        # local grab
        
        #[ -d /tmp/root_tmp_ca_setup ] && tar cvzf /tmp/root_tmp_ca_setup.$(date ${date_format}).tgz /tmp/root_tmp_ca_setup && rm -rf /tmp/root_tmp_ca_setup
        [ -d ${dot_globus}/simpleCA ] && read -p "Would you like to remove the current CA setup? [Y/n] " && rm -rf ${dot_globus}/simpleCA
        echo "%> GRID_CA_DIR=${dot_globus}/simpleCA ${globus_location}/setup/globus/setup-simple-ca"
	rm -rf /tmp/root_tmp_ca_setup
	mkdir -p ${dot_globus}/simpleCA

        #-----------(command)-------------
        GRID_CA_DIR=${dot_globus}/simpleCA ${globus_location}/setup/globus/setup-simple-ca -subject "CN=ESGF CA, OU=ESGF-${esgf_host:-$(hostname --fqdn)}, OU=ESGF.ORG, O=ESGF" -days 1825 | tee /tmp/globus_simpleca.log #> output
        [ $? != 0 ] && echo "May have to remove offending dir" && popd && return 1
        #---------------------------------
        
        # 
        # #(NOTE: The `hostname` calls are CentOS/RedHat flavored)
        # #Ex: /O=Grid/OU=GlobusTest/OU=simpleCA-$(echo `hostname -s`.`hostname --domain`)/CN=
        # grab=$(echo ${output} | egrep -i '^/O=.+CN=')
        # ca_subject=${grab%=*}=
        # echo "Grabbed ca_subject: [${ca_subject}]"
        # 
        # #Ex: ecdb249f
        # grab=($(cat ${output} | egrep '^.+globus_simple_ca_(.+)_setup.*$' | cut -d "_" -f 4))
        # ca_hash=${grab}
        # echo "Grabbed ca_hash: [${ca_hash}]"
        # unset grab
        # rm -v output
        # #########################################
        
        ca_hash=$(sed -n -e 's/$.*globus_simple_ca_\([a-f0-9]*\).*/\1/p' /tmp/globus_simpleca.log)
        ca_subject=$(sed -n -e 's#^/.*=.*$#&#p' /tmp/globus_simpleca.log | sed -n 's#/CN=[^/]*#/CN=#gp')
        
        printf "

    Please inspect the output on the last command
    'setup-simple-ca'. Locate the CA subject that should look like
    \"${ca_subject}. \"

    Also locate the CA hash value that is embedded in the name of
    the generated tar.gz file.  It should look something like
    \"${ca_hash}\". You will need them for the next two prompts.

    "
        
        local answer
        echo "What is the CA subject string [${ca_subject}] ? "
        while [ 1 ]; do
            read -p "> " answer
            [ -n "${answer}" ] &&  ca_subject=${answer} 
            unset answer
            read -p "ca_subject = [${ca_subject}] : [Y/n]?" answer
            if [ "${answer}" = "n" ]; then
                unset answer
                continue
            else
                break
            fi
        done
        unset answer
        echo
        
        echo "What is the CA hash value [${ca_hash}] ?"
        while [ 1 ]; do
            read -p "> " answer
            [ -n "${answer}" ] && ca_hash=${answer}
            unset answer
            echo -p "ca_hash = [${ca_hash}] : [Y/n]? " answer
            if [ "${answer}" = "n" ]; then
                unset answer
                continue
            else
                break
            fi
        done
        unset answer
        echo
        
        # #########################################
        
        
        echo "command: ${globus_location}/setup/globus_simple_ca_${ca_hash}_setup/setup-gsi -default"
        
        #move the old files outta the way!
        [ -e ${dot_globus}/host/hostcert_request.pem ] && cp -v ${dot_globus}/host/hostcert_request.pem ${dot_globus}/host/hostcert_request.pem.$(date ${date_format}).bak
        [ -e ${dot_globus}/host/hostcert.pem ] && cp -v ${dot_globus}/host/hostcert.pem ${dot_globus}/host/hostcert.pem.$(date ${date_format}).bak
        [ -e ${dot_globus}/host/hostkey.pem ] && cp -v ${dot_globus}/host/hostkey.pem ${dot_globus}/host/hostkey.pem.$(date ${date_format}).bak
        
        #----------(command)--------------
        ${globus_location}/setup/globus_simple_ca_${ca_hash}_setup/setup-gsi -default
        #---------------------------------
        
    fi
    unset answer
    echo
    
    if ((fetch_certs)); then
        #totally superfluous, vestigial decision path.
        local certfile=hostcert.pem
        pushd /etc/grid-security/ >& /dev/null
        [ -e "${certfile}" ] && chmod 644 ${certfile}
        local keyfile=hostkey.pem
        [ -e "${keyfile}" ] && chmod 600 ${keyfile}
        popd >& /dev/null
    elif ((gen_self_certs)); then
        echo "Generating self signed cert and key...(pwd = $(pwd))"
        generate_self_signed_cert
    elif ((keep_certs)); then
        echo "Will keep the current keypair... (/etc/grid-security/host[cert,key].pem files)"
    else
        echo "Do not regognize directive... return 1"
    fi

    local simpleCA_cert=${dot_globus}/simpleCA/cacert.pem
    if [ -e "${simpleCA_cert}" ]; then
        cp -v ${simpleCA_cert} /etc/grid-security/certificates/ && echo -n "." || echo -n "x"
	chown -R $(id -u):$(id -g) /etc/grid-security/certificates/${simpleCA_cert##/*/} >& /dev/null && echo -n "." || echo -n "x"
	chown -R $(id -u):$(id -g) /etc/grid-security/certificates/${simpleCA_cert##/*/} >& /dev/null && echo -n "." || echo -n "x"
        #echo
        [ -e "/etc/grid-security/certificates/${simpleCA_cert##/*/}" ] && rebuild_truststore
    fi

    #--------------------
    # Configure /etc/myproxy-server.config
    #--------------------
    edit_myproxy_server_config
    #--------------------

    [ $((install_mode)) == 0 ] && return 0

    #allow for fetched keys to be written in this location.
    echo "chown -R $(id -u):$(id -g) ${dot_globus}"
    chown -R $(id -u):$(id -g) ${dot_globus}
    [ $? != 0 ] && echo "**WARNING**: Could not change owner successfully - this will lead to inability to use myproxy and publisher properly!"
    
    #NOTE: for more info on keys and troubleshooting see:
    #http://www.ci.uchicago.edu/wiki/bin/view/ESGProject/MyProxyCertificateReplacementTesting

    #NOTE: To test that the simple CA's key's password is what you think it is:
    #openssl rsa -in ${dot_globus}/simpleCA/private/cakey.pem -text -noout


    #--------------------
    # Compile Java Code Used by "callout" scripts in ${globus_location}/bin
    #--------------------
    if [ ! -e ESGOpenIDRetriever.class ] || [ ! -e ESGGroupRetriever ]; then
        pushd ${globus_location}/bin >& /dev/null
        echo "Download and building ESGOpenIDRetriever and ESGGroupRetriever..."
        wget -O ESGOpenIDRetriever.java ${myproxy_dist_url_base}/ESGOpenIDRetriever.java
        wget -O ESGGroupRetriever.java  ${myproxy_dist_url_base}/ESGGroupRetriever.java
        
        #NOTE: "gateway_app_home" is available if this file is sourced from esg-gway
        if [ -e ${gateway_app_home}/WEB-INF/lib/${postgress_jar} ]; then
            echo " Found postgres jar in gateway web application's lib"
            ln -s ${gateway_app_home}/WEB-INF/lib/${postgress_jar}
        else
            echo " Could not find postgresql jdbc jar in gateway web application's lib"
            echo " getting it..."
            wget -O ${postgress_jar} ${myproxy_dist_url_base}/${postgress_jar}
        fi
        
        local cp=.:`pwd`:$(find `pwd`| grep .jar | xargs | perl -pe 's/ /:/g')
        echo "javac -classpath ${cp} ESGOpenIDRetriever.java"
        javac -classpath ${cp} ESGOpenIDRetriever.java
        echo "javac -classpath ${cp} ESGGroupRetriever.java"
        javac -classpath ${cp} ESGGroupRetriever.java
        popd >& /dev/null
        unset cp
    fi
    #--------------------


    #--------------------
    #Build mhash (libpam-sql needs it)
    #--------------------
    mkdir -p ${mhash_workdir} >& /dev/null
    pushd ${mhash_workdir} >& /dev/null

    mhash_dist_file=${mhash_dist_url##*/}
    mhash_dist_dir=$(echo ${mhash_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')

    if [ ! -e ${mhash_dist_dir} ]; then
        echo "Don't see mhash distribution dir ${mhash_dist_dir}"
        if [ ! -e ${mhash_dist_file} ]; then
            echo "Don't see mhash distribution file ${mhash_dist_file} either"
            echo "Downloading mhash from ${mhash_dist_url}"
            wget -O ${mhash_dist_file} ${mhash_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download mhash: ${mhash_dist_file}" && popd && checked_done 1
            tar xvjf ${mhash_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract mhash's: ${mhash_dist_file}" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it and go from there....
    if [ -e ${mhash_dist_file} ] && [ ! -e ${mhash_dist_dir} ]; then
        tar xvjf ${mhash_dist_file}
    fi

    cd ${mhash_dist_dir}
    echo "./configure"
    if ./configure \
        && gmake \
        && gmake install
    then
        echo "Successfully Configured and Built mhash"
        echo "$(date ${date_format}) mhash=${mhash_version}" >> ${install_manifest}
        dedup ${install_manifest}

    else
        echo " ERROR: Could NOT successfully build mhash!"
        popd >& /dev/null
        checked_done 1
    fi
    popd >& /dev/null
    #--------------------




    #--------------------
    #Build libpam-pgsql
    #--------------------
    mkdir -p ${pam_pgsql_workdir} >& /dev/null
    pushd ${pam_pgsql_workdir} >& /dev/null

    pam_pgsql_dist_file=${pam_pgsql_dist_url##*/}
    pam_pgsql_dist_dir=$(echo ${pam_pgsql_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')

    if [ ! -e ${pam_pgsql_dist_dir} ]; then
        echo "Don't see pam_pgsql distribution dir ${pam_pgsql_dist_dir}"
        if [ ! -e ${pam_pgsql_dist_file} ]; then
            echo "Don't see pam_pgsql distribution file ${pam_pgsql_dist_file} either"
            echo "Downloading pam_pgsql from ${pam_pgsql_dist_url}"
            wget -O ${pam_pgsql_dist_file} ${pam_pgsql_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download PAM PGSQL: ${pam_pgsql_dist_file}" && popd && checked_done 1
            tar xvzf ${pam_pgsql_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract PAM PGSQL's: ${pam_pgsql_dist_file}" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it and go from there....
    if [ -e ${pam_pgsql_dist_file} ] && [ ! -e ${pam_pgsql_dist_dir} ]; then
        tar xvzf ${pam_pgsql_dist_file}
    fi

    cd ${pam_pgsql_dist_dir}
    ((force_install)) && (echo "Cleaning the source tree.. $(pwd) " && gmake clean && echo "[OK]" || echo "[FAIL]")
    echo "./configure --prefix=${pam_pgsql_install_dir}"
    if CFLAGS=-I${postgress_install_dir}/include LDFLAGS=-L${postgress_install_dir}/lib ./configure --prefix=${pam_pgsql_install_dir} \
        && gmake \
        && gmake install
    then
        echo "Successfully Configured and Built PAM PGSQL in: ${pam_pgsql_install_dir}"
        echo "$(date ${date_format}) pam-pgsql=${pam_pgsql_version} ${pam_pgsql_install_dir}" >> ${install_manifest}
        dedup ${install_manifest}
    else
        echo " ERROR: Could NOT successfully build PAM PGSQL!"
        popd >& /dev/null
        checked_done 1
    fi
    popd >& /dev/null
    #--------------------

    #--------------------
    # Get myproxy-certificate-mapapp file
    #--------------------
    fetch_myproxy_certificate_mapapp $((_performed_simpleCA_migration))
    #--------------------

    #--------------------
    # Configure pam_sql.conf
    #--------------------
    edit_pam_pgsql_conf
    #--------------------


    #NOTE: since installing pam_pgsql from source in prefix
    #/usr/local/pam, I may have to pushd to /usr/local/pam/etc to
    #find pam.d directory below to put in the myproxy file.

    #--------------------
    # Fetch -> pam resource file used for myproxy
    #--------------------
    fetch_etc_pam_d_myproxy
    #--------------------

    
    #--------------------
    # Get esg_attribute_callout_app file
    #--------------------
    fetch_esg_attribute_callout_app
    #--------------------

    write_db_name_env

    #--------------------
    # Get myproxy startup/shutdown script (/etc/init.d/myproxy)
    #--------------------
    fetch_init_d_myproxy
    #--------------------

    popd >& /dev/null
    write_myproxy_install_log
    checked_done 0
}

write_myproxy_install_log() {
    [ -e ${globus_location}/sbin/myproxy-server ] && \
        write_as_property myproxy_app_home ${globus_location}/sbin/myproxy-server || \
        echo "WARNING: Cannot find executable ${globus_location}/sbin/myproxy-server"
    ! grep myproxy.endpoint ${esg_config_dir}/esgf.properties && write_as_property myproxy_endpoint "${esgf_host:-$(hostname --fqdn)}"
    ! grep myproxy.port ${esg_config_dir}/esgf.properties && write_as_property myproxy_port
    write_as_property myproxy_dn "/$(openssl x509 -text -noout -in /etc/grid-security/hostcert.pem | sed -n 's#.*Subject: \(.*$\)#\1#p' | tr -s " " | sed -n 's#, #/#gp')"
    
    echo "$(date ${date_format}) globus:myproxy=${myproxy_version} ${myproxy_app_home}" >> ${install_manifest}
    dedup ${install_manifest}
    return 0

}

write_db_name_env() {
    ((show_summary_latch++))
    echo "export ESGF_DB_NAME=${esgf_db_name}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}


test_myproxy_server() {
    echo "MyProxy - Test... (faux) [$@]"
    #TODO: Sanity check code...
    return 0
}

start_myproxy_server() {
    check_myproxy_process && return 0
    echo " MyProxy - Starting server..."
    [ -x /etc/init.d/myproxy ] && X509_CERT_DIR=${globus_global_certs_dir} /etc/init.d/myproxy start && return 0
    return 1
}

stop_myproxy_server() {
    [ -x /etc/init.d/myproxy ] && /etc/init.d/myproxy stop

    if check_myproxy_process 
    then 
        echo "Detected Running myproxy-server..."
    else
        echo "No MyProxy Process Currently Running..." && return 1
    fi

    killall myproxy-server && echo " [OK] " || echo " [FAIL] "
    return $?
}

restart_myproxy_server() {
    stop_myproxy_server
    start_myproxy_server
}

#This function "succeeds" (is true -> returns 0)  if there *are* running processes found
check_myproxy_process() {
    val=$(ps -elf | grep myproxy-server* | grep -v grep | awk ' END { print NR }')
    [ $(($val > 0 )) == 1 ] && echo "myproxy-server process is running..." && return 0
    return 1
}

############################################
# Configuration File Editing Functions
############################################

edit_myproxy_server_config() {
    local _force_install=$((force_install + ${1:-0}))
    local cert_password
    pushd /etc >& /dev/null
    local tfile=myproxy-server.config
    echo "Download and Modifying myproxy server configuration file: `pwd`/${tfile}"
    checked_get ${tfile}.tmpl ${myproxy_dist_url_base}/${tfile} $((_force_install))
    [ -e "${tfile}" ] && mv -v ${tfile}{,.bak}
    cp -vf ${tfile}{.tmpl,}
    [ $? != 0 ] && return 1

    #This is the password of the CA's certs created via the simple ca (setup-gsi)
    while [ 1 ]; do
	local input
        read -s -p "Enter (simple) CA's certificate password - (use same password used in setup-gsi): $([ -n "${cert_password}" ] && echo [****] || echo "[]") " input
	[ -n "${input}" ] && cert_password="${input}"  && unset input && break
    done
    
    local myproxy_config_dir=${esg_config_dir}/myproxy

    echo -n "editing myproxy certificate information "

    esgf_home=${esg_root_dir:-${ESGF_HOME}}
    if [ -z "${esgf_home}" ]; then
        eval $(grep ESGF_HOME /etc/esg.env)
        esgf_home=${ESGF_HOME:-"/esg"}
    fi

    eval "perl -p -i -e 's/\\@\\@PASSWORD\\@\\@/\"${cert_password}\"/g' ${tfile}"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@myproxy_config_dir\\@\\@#${myproxy_config_dir}#g' ${tfile}"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@dot_globus\\@\\@#${dot_globus}#g' ${tfile}"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@esgf_home\\@\\@#${esgf_home}#g' ${tfile}"
    echo -n "*"
    sed  -i -r 's/(.*certificate_issuer_key_passphrase)[ ]*([^"].*[^"])[ ]*$/\1 "\2"/' ${tfile}
    echo -n "<+>"
    echo " [OK]"
    
    chmod 600 ${tfile}
    ((DEBUG)) && cat ${tfile}
    popd >& /dev/null
    unset tfile
    unset cert_password
    #--------------------
    return 0
}

edit_pam_pgsql_conf() {
    local _force_install=$((force_install + ${1:-0}))
    pushd /etc >& /dev/null
    local tfile=pam_pgsql.conf
    echo "Download and Modifying pam pgsql configuration file: `pwd`/${tfile}"
    checked_get ${tfile}.tmpl ${myproxy_dist_url_base}/etc_${tfile} $((_force_install))
    [ -e "${tfile}" ] && mv -v ${tfile}{,.bak}
    cp -vf ${tfile}{.tmpl,}
    [ -n "${tfile}" ] && chmod 600 ${tfile}* >& /dev/null
    [ $? != 0 ] && return 1
    eval "perl -p -i -e 's/\\@\\@postgress_host\\@\\@/${postgress_host}/g' ${tfile}"
    echo -n "*"
    eval "perl -p -i -e 's/\\@\\@postgress_port\\@\\@/${postgress_port}/g' ${tfile}"
    echo -n "*"
    eval "perl -p -i -e 's/\\@\\@postgress_user\\@\\@/${postgress_user}/g' ${tfile}"
    echo -n "*"
    eval "perl -p -i -e 's/\\@\\@pg_sys_acct_passwd\\@\\@/${pg_sys_acct_passwd}/g' ${tfile}"
    echo -n "*"
    eval "perl -p -i -e 's/\\@\\@esgf_db_name\\@\\@/${esgf_db_name}/g' ${tfile}"
    echo -n "*"
    echo " [OK]"
    ((DEBUG)) && cat ${tfile}
    popd >& /dev/null
    unset tfile
    return 0
}

fetch_myproxy_certificate_mapapp() {
    local _force_install=$((force_install + ${1:-0}))
    local myproxy_config_dir=${esg_config_dir}/myproxy
    mkdir -p ${myproxy_config_dir}
    pushd ${myproxy_config_dir} >& /dev/null

    local tfile=myproxy-certificate-mapapp
    echo "Downloading configuration file: `pwd`/${tfile}"
    checked_get ${tfile}.tmpl ${myproxy_dist_url_base}/${tfile} $((_force_install))
    local ret=$?
    (( ret >= 1 )) && return 0
    [ -e "${tfile}.tmpl" ] && chmod 640 ${tfile}.tmpl && cp -v ${tfile}{.tmpl,} && chmod 751 ${tfile} && \
        sed -i.bak 's#\(ca_subject=.*-in \)\(.*\)\(/simpleCA/\)#\1'${dot_globus}'\3#' ${tfile}
    ((DEBUG)) && cat ${tfile}
    popd >& /dev/null
    unset tfile
    return 0
}

fetch_etc_pam_d_myproxy() {
    local _force_install=$((force_install + ${1:-0}))
    pushd /etc/pam.d >& /dev/null
    local tfile=myproxy
    echo "Fetching pam's myproxy resource file: `pwd`/${tfile}"
    checked_get ${tfile} ${myproxy_dist_url_base}/etc_pam.d_${tfile} $((_force_install))
    ((DEBUG)) && cat ${tfile}
    popd >& /dev/null
    unset tfile
}

fetch_esg_attribute_callout_app() {
    local _force_install=$((force_install + ${1:-0}))
   #Configure External Attribute Callout with MyProxy
    local myproxy_config_dir=${esg_config_dir}/myproxy
    mkdir -p ${myproxy_config_dir}
    pushd ${myproxy_config_dir} >& /dev/null

    local tfile=esg_attribute_callout_app
    echo "Downloading configuration file: `pwd`/${tfile}"
    checked_get ${tfile} ${myproxy_dist_url_base}/${tfile} $((_force_install))
    [ -e "${tfile}" ] && chmod 751 ${tfile}
    ((DEBUG)) && cat ${tfile}
    popd >& /dev/null
    unset tfile
}

fetch_init_d_myproxy() {
    local _force_install=$((force_install + ${1:-0}))
    pushd /etc/init.d/ >& /dev/null
    local tfile=myproxy
    echo "Download MyProxy rc script: `pwd`/${tfile}"
    checked_get ${tfile} ${myproxy_dist_url_base}/init.d_${tfile} $((_force_install))
    [ -e "${tfile}" ] && chmod 755 ${tfile}
    ((DEBUG)) && cat ${tfile}
    popd >& /dev/null
    unset tfile
}

simpleCA_relink() {
    [[ ! ${globus_location} ]] && echo "Sorry, GLOBUS_LOCATION is not set, cannot continue. Set value and retry" && return 1
    [[ ! -d ${dot_globus}/simpleCA ]] && "Sorry, simpleCA installation NOT detected, please (re) install simpleCA" && return 1
    ${globus_location}/sbin/gpt-postinstall
    ${globus_location}/setup/globus_simple_ca_$(ls ${dot_globus}/simpleCA/ | grep globus_simple_ca_* | awk -F '_' '{print $4}')_setup/setup-gsi
}

sanity_check_myproxy_configurations() {
    local _force_install=$((force_install + ${1:-0}))
    edit_myproxy_server_config $((_force_install))
    edit_pam_pgsql_conf $((_force_install))
    fetch_myproxy_certificate_mapapp $((_force_install))
    fetch_etc_pam_d_myproxy $((_force_install))
    fetch_esg_attribute_callout_app $((_force_install))
    fetch_init_d_myproxy $((_force_install))
}

############################################
# Utility Functions
############################################

create_globus_account() {
    ########
    #Create the system account for globus to run as.
    ########
    [ -z "${globus_sys_acct}" ] && echo "no globus account specfied, must be specified to continue!" && checked_done
    echo -n "checking globus account \"${globus_sys_acct}\"... "
    
    id ${globus_sys_acct}
    if [ $? != 0 ]; then
        echo
	echo " Hmmm...: There is no globus system account user \"$globus_sys_acct\" present on system, making one... "
	#NOTE: "useradd/groupadd" are a RedHat/CentOS thing... to make this cross distro compatible clean this up.
	if [ ! $(getent group ${globus_sys_acct_group}) ]; then
	    /usr/sbin/groupadd -r ${globus_sys_acct_group}
	    [ $? != 0 ] && [ $? != 9 ] && echo "ERROR: Could not add globus system group: ${globus_sys_acct_group}" && checked_done 1
	fi

	if [ -z "${globus_sys_acct_passwd}" ]; then
	    #set the password for the system user...
	    while [ 1 ]; do
		local input
		read -s -p "Create password for globus system account: \"${globus_sys_acct}\" " input
		[ -n "${input}" ] && globus_sys_acct_passwd=${input}  && unset input && break
	    done
	fi
	echo -n "Creating account... "
	/usr/sbin/useradd -r -c"Globus System User" -g ${globus_sys_acct_group} -p ${globus_sys_acct_passwd} -s /bin/bash ${globus_sys_acct}
	[ $? != 0 ] && [ $? != 9 ] && echo "ERROR: Could not add globus system account user" && popd && checked_done 1
        echo "[OK]"
    else
        echo "[OK]"
    fi
}

#Optionally takes expiration duration of cert in days
#Default is 1 year
update_simple_ca_cert() {
    local days=${1:-365}
    echo "Updating SimpleCA Certificate... for ${days} days"
    local simpleCA_dir=$HOME/.globus/simpleCA
    backup ${simpleCA_dir}

    [ ! -d "${simpleCA_dir}" ] && [FAIL] && echo "Could not find simpleCA directory (${simpleCA_dir})" && return 1
    pushd $HOME/.globus/simpleCA >& /dev/null

  # Generate CSR based on existing cert
    openssl x509 -x509toreq -in ./cacert.pem -signkey ./private/cakey.pem -out ./renewedcacertreq.csr
    [ $? != 0 ] && [FAIL] && echo " Could not update cert... unable to generate request" && popd >& /dev/null && return 2

  # Sign the CSR
    openssl x509 -req -days ${days} -in ./renewedcacertreq.csr -signkey ./private/cakey.pem  -out ./renewedcacert.pem -extfile ./grid-ca-ssl.conf -extensions v3_ca
    [ $? != 0 ] && [FAIL] && echo " Could not update cert... unable to sign" && popd >& /dev/null && return 3

    mv ./cacert.pem ./cacert.expired
    mv renewedcacert.pem ./cacert.pem

    openssl x509 -text -hash -in $HOME/.globus/simpleCA/cacert.pem |tee ${tomcat_install_dir}/webapps/ROOT/cacert.pem |  grep "Not After" | sed -r -n -e  's/[^:]*:(.*)/New Cert Expires: \1/p'
    [ $? != 0 ] && [FAIL] && echo " Could not update cert... unable to post cacert" && popd >& /dev/null && return 4

    local pair_hash=($((openssl x509 -noout -modulus -in $HOME/.globus/simpleCA/cacert.pem | openssl md5 ; openssl x509 -noout -modulus -in ${tomcat_install_dir}/webapps/ROOT/cacert.pem | openssl md5)  | uniq))
    if (( 1 == ${#pair_hash[@]} )); then
        [OK]
        printf "$([OK]) Please email the new certificate to esgf-ca@lists.llnl.gov, with subject \"NEW CA CERT for ${esgf_host:-$(hostname --fqdn)}. Thank you\n\n"
    else
        printf "$([FAIL]) Posted cacert doesn't match :-( \n\n"
        return 5
    fi
    return 0
}

############################################
# Globus Online Setup
############################################
setup_globus_online() {
    printf "
    Setting up Globus Online / ESGF integration...

    NOTE: You MUST have created a Globus Online account for
    this node: In order for oAuth to work correctly such that
    the user does not have to link their ESG credential with their
    Globus Online account, this node must have its own account.

        https://www.globusonline.org/SignUp

"
    local local=y
    read -e -p "Continue? [Y/n] " input
    [ "n" = "$(echo "${input}" | tr [A-Z] [a-z])" ] && return 1
    unset input

    (
        local config_file=${esg_config_dir}/globusonline.properties
        load_properties ${config_file}

        local input
        while [ 1 ]; do
            read -e -p "Please enter your Globus Online ID [${GOesgfPortalID}]: " input
            [ -n "${input}" ] && GOesgfPortalID=${input} && break
            [ -n "${GOesgfPortalID}" ] && break
        done
        unset input
        write_as_property GOesgfPortalID

        while [ 1 ]; do
            read -e -p "Please enter your Globus Online Password [$([ -n "${GOesgfPortalPassword}" ] && echo "*********")]: " input
            [ -n "${input}" ] && GOesgfPortalPassword=${input} && break
            [ -n "${GOesgfPortalPassword}" ] && break
        done
        unset input
        write_as_property GOesgfPortalPassword

        chmod 600 ${config_file}
        chown ${tomcat_user:-tomcat}.${tomcat_group:-tomcat} ${config_file}

        local mkproxy_dist_url="${esg_dist_url}/externals/bootstrap/mkproxy-10-15-2012.tar.gz"
        local mkproxy_dist_file=${mkproxy_dist_url##*/}
        pushd /tmp/
        checked_get ${mkproxy_dist_file} ${mkproxy_dist_url} $((force_install))
        (( $? > 1 )) && echo " ERROR: Could not download Globus Online install script" && popd >& /dev/null && checked_done 1
        tar xvzf ${mkproxy_dist_file}
        [ $? != 0 ] && echo " WARNING: Could not extract Globus Online install script (properly)" && popd >& /dev/null #&& checked_done 1
        cd /tmp/mkproxy
        [ $? != 0 ] && echo " ERROR: Could not Chang to mkproxy directory" && popd >& /dev/null && checked_done 1
        make
        [ $? != 0 ] && echo " ERROR: Could not build mkproxy program" && popd >& /dev/null && checked_done 1
        cp -v /tmp/mkproxy/mkproxy /usr/local/bin
        cd ../
        [ -e "/tmp/${mkproxy_dist_file}" ] && rm -rf mkproxy /tmp/${mkproxy_dist_file}
        popd >& /dev/null
        (config_file=${esg_config_dir}/searchconfig.properties write_as_property enableGlobusOnline true && chmod 600 ${config_file})
    )
    echo "<<<<$?>>>>"
}
